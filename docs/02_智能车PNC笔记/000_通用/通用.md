# 通用基础

## 曲线平滑处理

参考：

1.  Savitzky-Golay 平滑算法：

Savitzky-Golay 算法是一种广泛应用于曲线平滑的线性滤波算法。该算法通过拟合多项式来近似曲线，然后使用滑动窗口对每个点进行平滑处理。这种方法可以减少噪声的影响，同时保留曲线的特征。

2.  Loess 平滑算法：

Loess 平滑算法是一种非参数回归算法，适用于对非线性曲线进行平滑处理。该算法通过在数据点附近拟合局部多项式来平滑曲线。与 Savitzky-Golay 算法相比，Loess 算法具有更高的平滑度，但可能会失去一些曲线特征。

3.  Kalman 滤波算法：

Kalman 滤波算法是一种经典的滤波算法，适用于动态系统建模和控制。该算法通过预测和修正来估计系统状态，可以用于曲线平滑和噪声去除。Kalman 滤波算法适用于带有高斯噪声的曲线平滑，但对于非高斯噪声的曲线，可能需要其他算法。

以上三种都是很常见的曲线平滑算法；那么第二个问题是：

他们各自有什么优缺点？

图片

三种曲线平滑算法各自优缺点

1. Savitzky-Golay 平滑算法

优点：

● 实现简单。

● 可以保留曲线的特征。

● 平滑效果好，能够减少噪声的影响。

缺点：

● 对于高斯白噪声以外的噪声，效果不好。

● 对于数据点稀疏的曲线，可能会出现过度拟合的情况。

● 对于需要高阶多项式拟合的曲线，计算复杂度会增加。
2.  Loess 平滑算法

优点：

● 可以保留曲线的特征。

● 能够拟合非线性曲线，平滑效果好。

● 对于数据点稀疏的曲线也能较好地处理。

缺点：

● 可能会出现过拟合从而损失曲线的特征。

● 由于使用局部多项式进行拟合，计算复杂度较高。

● 平滑效果会随着窗口大小的变化而变化，需要选取合适的窗口大小。
3.  Kalman 滤波算法

优点：

● 对于多维数据可以做到同时平滑。

● 对高斯白噪声效果好，平滑效果较好。

● 通过动态模型进行预测和修正，可以适应动态系统变化。

缺点：

● 对于非高斯噪声，效果较差。

● 对于高维数据，计算复杂度会增加。

● 实现相对复杂，需要了解系统的动态模型。

由于每种算法都有各自的适用范围，所以在遇到问题的时候需要根据具体的情况来选用最合适的算法。

第三个问题是：

如何用代码（这里指用 Python 语言）来实现上面三种算法？

图片

三种算法的代码实现示例

  Savitzky-Golay 平滑算法代码示例

import numpy as np
from scipy.signal import savgol_filter
import matplotlib.pyplot as plt

# 生成一个带噪声的正弦曲线
t = np.linspace(0, 2*np.pi, 100)
x = np.sin(t) + np.random.normal(0, 0.1, 100)

# 使用Savitzky-Golay算法进行曲线平滑
y = savgol_filter(x, window_length=11, polyorder=2)

# 绘制原始曲线和平滑后的曲线
plt.plot(t, x, label='Original')
plt.plot(t, y, label='Savitzky-Golay')
plt.legend()
plt.show()
上面的示例代码首先随机生成了一个带噪声的正弦曲线，然后通过使用Savitzky - Golay 算法函数进行曲线平滑操作，最后生成对比图如下：



图片
2.  Loess 平滑算法的代码示例

import numpy as np
from statsmodels.nonparametric.smoothers_lowess import lowess
import matplotlib.pyplot as plt

# 生成一个带噪声的正弦曲线
t = np.linspace(0, 2*np.pi, 100)
x = np.sin(t) + np.random.normal(0, 0.1, 100)

# 使用Loess算法进行曲线平滑
y = lowess(x, t, frac=0.1, it=0)[:, 1]

# 绘制原始曲线和平滑后的曲线
plt.plot(t, x, label='Original')
plt.plot(t, y, label='Loess')
plt.legend()
plt.show()
这里也是直接调用 statsmodels 库里面的 lowess 函数来绘制曲线平滑的操作，最后生成如下：

图片

看完上面两组示例代码，大家是不是觉得都还挺简单的？最后看看 Kalman 滤波算法该如何绘制。
3.  Kalman 滤波算法的代码示例

import numpy as np
import matplotlib.pyplot as plt
from filterpy.kalman import KalmanFilter

# 生成一组噪音数据
t = np.linspace(0, 10, 100)
y = np.sin(t) + np.random.normal(0, 0.1, 100)

# 生成一个滤波器对象
kf = KalmanFilter(dim_x=2, dim_z=1)
kf.x = np.array([0, 0])  # 设置初始化状态 
kf.F = np.array([[1, 1], [0, 1]])  #设置状态转移矩阵 
kf.H = np.array([[1, 0]])  #测量矩阵 
kf.P = np.diag([1, 1])  #协方差矩阵 
kf.Q *= 1e-5  # 过程噪声方差 
kf.R = 0.1  # 测量噪声方差 

#使用Kalman滤波器来预测和更新状态，最后将平滑的位置保存到列表中
xhat_list = []
P_list = []
for i in range(len(t)):
    kf.predict()
    kf.update(y[i])
    xhat_list.append(kf.x[0])
    P_list.append(kf.P[0, 0])

#绘制对比图
plt.plot(t, y, label='Noisy data')
plt.plot(t, xhat_list, label='Smoothed data')
plt.legend()
plt.show()

这里依然随机生成一组噪音数据，然后使用 filterpy 库中的 KalmanFilter 类来创建 Kalman 滤波器对象，并设置初始状态、状态转移矩阵、测量矩阵、协方差矩阵、过程噪声方差和测量噪声方差。接着使用predict() 和 update() 方法来预测和更新状态，最后将平滑的位置保存到列表中，并绘制出变换前后的结果。

图片

总的来说，这里用 Python 来实现上述三种算法还是比较简单的，因为都有现成的库直接调用。最后我们再看看这三种算法背后的原理。
图片

三种算法背后的原理简析

1. Savitzky-Golay 平滑算法

Savitzky-Golay 平滑算法是一种基于多项式拟合的曲线平滑算法。该算法的核心思想是使用局部多项式来拟合数据，并使用拟合结果来近似估计数据的平滑值。

Savitzky-Golay 平滑算法通过寻找最佳拟合多项式的系数来平滑数据，其基本思想是将拟合多项式的系数视为一个线性滤波器的系数，从而实现对数据的平滑。

2. Loess平滑算法

Loess 平滑算法（局部加权散点图拟合算法）是一种基于局部加权回归的曲线平滑算法。该算法的核心思想是对于每个数据点，使用一个局部的加权回归模型来拟合其周围的数据点，从而得到该点的平滑值。

Loess 平滑算法的平滑程度可以通过权重函数来调整，这使得该算法能够适应各种不同的数据类型和平滑要求。

3. Kalman滤波算法

Kalman 滤波算法是一种递归滤波算法，用于动态系统的状态估计和预测。在曲线平滑中，Kalman 滤波算法的核心思想是根据测量值和状态转移方程，对状态进行递归估计和预测，并使用卡尔曼增益来调整预测值和测量值之间的权重。

Kalman 滤波算法对于噪声和不确定性具有较好的抗干扰能力，因此在一些特殊场合，如传感器数据处理和机器人路径规划等方面得到广泛应用。