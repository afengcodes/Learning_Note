# 常用算法

# 全局规划



# 局部规划



# 路径规划算法
(PnC用)

## 介绍
- 基于图搜索的算法：Dijkstra、A*、D*（全局路径规划）
- 基于曲线拟合的算法：圆弧与直线、多项式曲线、样条曲线、贝塞尔曲线、微分平坦（局部路径规划）
- 基于数值优化的算法：利用目标函数和约束对规划问题进行描述和求解（局部路径规划）
- 基于人工势场的算法：人工势场法（全局路径规划）
- 基于采样的算法：RRT（全局路径规划）
- 基于智能法的算法：模糊逻辑、神经网络、遗传算法（略）


各算法介绍  和 优劣对比  使用场景


## Dijkstra

Dijkstra算法的主要特点是以起始点为中心向外层层扩展（广度优先搜索思想），直到扩展到终点为止。迪杰斯特拉算法的成功率是最高的，因为它每次必能搜索到最优路径。但迪杰斯特拉算法的搜索速度是最慢的：随着图维度的增大，其计算效率会明显变低。




## A*

Dijkstra算法是广度优先算法，是一种发散式的搜索，搜索速度是很慢。这里引入一种启发式算法的深度优先算法：A*。


基本步骤：

把起点加入 open list 。
重复如下过程：
a ) 遍历 open list ，查找 F 值最小的节点移到 close list ，把它作为当前要处理的节点。
b ) 判断当前方格的 8 个相邻方格的每一个方格，若为unreachalbe或者已在 close list 中则忽略。否则做如下操作。
c ) 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。
d ) 如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 **G** 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。
直到openlist为空，从终点开始，每个方格沿着父节点移动直至起点，这就是最优路径。


具体讲解见下文：


在计算机科学、人工智能和最优化领域，人们设计出启发式算法来解决那些用常规方法解决起来太慢的问题，或者找出一个对精确结果的近似。使用启发式算法是对**最优性、完全性、准确度、精确度和计算速度**之间的**权衡**。

启发式算法常常用于图搜索，称为启发式搜索算法。启发式搜索算法包含一个启发式方程，h(n)，它可以给出从一个给定节点到目标节点（即终点）所需要走的路径开销（长度、时间等）的一个估计。如果给定的节点就是目标节点，则h(n)必须等于0。

许多搜索问题都是NP完全问题，所以在最坏情况下，时间复杂度为指数级。然而一个好的启发式搜索算法可以：

- 在平均情况下，可以很**高效**地找到一个解
- 高效地找到一个**相当好**（但不一定是最优）的解

三种启发式搜索算法：最佳优先搜索（Best-First Search）、集束搜索（Beam Search）和 A* 算法

本文主要讲A*算法：

**A*算法**

(BFS-> Dijkstra -> A* -> D*)
(BFS和Dijkstra算法的区别：广度优先是先将未访问的邻居压入队列，再将未访问邻居的未访问过的邻居压入队列再依次访问；而Dijkstra是在剩余的所有未访问过的顶点中找出最小的并访问，循环做这个是直到所有点都被访问完。)


Dijkstra算法是广度优先算法，是一种发散式的搜索，搜索速度是很慢。这里引入一种启发式算法的深度优先算法：A*。其基本思想：

>深度优先搜索、广度优先搜索？、选代加深搜索和等代价搜索算法使用了**回溯**技术实施搜索，它从起始状态出发沿着树的深度，遍历树的结点，尽可能深地搜索树的分支，直至要么到达目标状态，要么到达一个搜索终止点。如果发现了**目标状态**，它退出搜索并返回解路径；如果到达的是一个**搜索终止点**，那么它将回溯到路径上含有未搜索过的结点的临近结点，并沿着这个分支继续搜索下去。因此，这类算法比较适合于解决环境中结点数目较少情况下的路径搜索问题，当结点数目比较多时，算法搜索速度慢、效率低。
而**启发式搜索算法**在决定结点扩展顺序的估价函数中引人了启发值，即当前结点状态到目标状态之间的估计消耗，从而引导搜索朝向目标状态的方向，避免了盲目搜索，有助于提高算法的搜索效率，因而启发式搜索算法越来越广泛地应用于路径规划。







基本步骤：

把起点加入 Open list 。

重复如下过程：

a ) 遍历 Open list ，查找 F 值最小的节点移到 Close list ，把它作为当前要处理的节点。

b ) 判断当前方格的 8 个相邻方格的每一个方格，若为Unreachalbe或者已在 Close list 中则忽略。否则做如下操作。
c ) 如果它不在 Open list 中，把它加入 Open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。
d ) 如果它已经在 Open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。
直到Openlist为空，从终点开始，每个方格沿着父节点移动直至起点，这就是最优路径。


代码：
初始化两个空的列表openlist和closelist，将起点加入openlist中，并设置代价值为0。



```c++  
while(1)
{
    if(openlist != null)
    {
         从openlist中选取代价值最小的节点n.
         1. 如果节点n为终点，则从终点开始逐步追踪parent节点，一直达到起点，返回找到的结果路径，
            跳出循环，算法结束，break;
         2. 如果节点n不是终点，
            2.1 将节点n从openlist中删除，加入到closelist中.
            2.2 遍历节点n的8个相邻无碰撞节点
                //2.2.1 如果相邻节点在closelist或者不可达，则跳过该节点，计算下一个节点。
                //2.2.2 如果已经在openlist中，查看是否需要更新。如需更新，还要相应更新父节点，并则上滤。
                //2.2.3 如果相邻节点不在openlist中，则设置该节点父节点为n，通过f(n)计算该节点的代价值，并将该节点放入openlist中。
     }
     else
         break; //不能找到一条最优路径
}
```










A*搜索算法：最小化全局路径开销
A*算法结合了常规方法（完备、最优、低效）和**最佳优先搜索**（不完备、非最优、高效）。

A*算法在进行优先队列排序时使用的全局评价函数f(n)，f(n)=g(n)+h(n)。其中，g(n)是对已走路程的测量，是实际值而非估计值。

记h0(n)节点n到目标节点的实际距离，若h(n)总是小于等于h0(n)，我们就说h(n)是可接纳的。如果h(n)是可接纳的，那么f(n)就不会高估任何经过节点n的最佳路径。

如果h(n)是可接纳的，那么A*算法总能找到一条到目标节点的最优路径

**应用场景**
- 起点→终点的最短距离
- 状态空间 >> 1e10 
- 启发函数减小搜索空间
- 必须有解 否则会遍历所有，且效率低于bfs。 注意！！！ 
- 只能保证终点在出队时 距离为最优，其他点包括路径上的点都不能不保证 ！！ 需要继续思考 [视频第50min左右](https://www.acwing.com/video/455/)
- 点可能不止被拓展一次 不 同于bfs
- 估计函数 0<=h<=realCost

**流程**
```c++  
while(q.size())
    t ← 优先队列的队头  小根堆
        当终点第一次出队时 break;
        从起点到当前点的真实距离 g
        从当前点到终点的估计距离 h
        选择一个估计距离最小的点 min(h)  / ?? 不是f = g + h 最小的点吗
    for j in ne[t]:
        将邻边入队
```
具体可参考： 智能车pnc笔记中的基础准备部分的介绍。



**算法特点**
- 相对与bfs，把队列换成优先队列(小根堆)。而且可计算带边权的问题。
- 相对与Dijkstra，把估计代价由0变成一新的代价h(0 < h <= realCost, 越接近realCost越好，影响速度和精度)
- 区别于对dfs优化的IDA*

**正确性证明**
以下字符与yxc不一致
用f表示dist， f = g + h , g 为当前代价， h 为预估代价，h'表示真实代价

A*算法条件:  ?? 
估计距离<=真实距离
f[state] + h[state] = 起点到state的真实距离 + state到终点的估计距离=估计距离
<
f[state] + h[state] = 起点到state的真实距离 + state到终点的真实距离=真实距离

一定是有解才有 f[i]   >= f[最优] = f[u]+h[u]
        h[u] >= 0


```c++  
证明终点第一次出队列即最优解
1 假设终点第一次出队列时不是最优 
  则说明当前队列中存在点u
     有 f[估计]< f[真实]
  f[u] + h[u] <= f[u] + h[u] = f[队头终点]
  即队列中存在比f[终点]小的值,
2 但我们维护的是一个小根堆,没有比f[队头终点]小的f[u],矛盾
证毕
```


```c++  
A* 不用判重
以边权都为1为例
  A o→o→o
    ↑   ↓
  S o→o→o→o→o→o→o T
      B
dist[A] = dist[S]+1 + f[A] = 7
dist[B] = dist[S]+1 + f[B] = 5
则会优先从B这条路走到T
B走到T后再从A这条路走到T
```

![](./assets/A_star_chudui.jpg)








**附：**
1. **启发式函数在A* 中的作用**
启发式函数h(n)告诉A*从任何结点n到目标结点的最小代价评估值。因此选择一个好的启发式函数很重要。

启发式函数在A* 中的作用
启发式函数可以用来控制A* 的行为。一种极端情况，如果h(n)是0，则只有g(n)起作用，此时A* 算法退化成Dijkstra算法，就能保证找到最短路径。

如果h(n)总是比从n移动到目标的代价小（或相等），那么A* 保证能找到一条最短路径。h(n)越小，A* 需要扩展的点越多，运行速度越慢。

如果h(n)正好等于从n移动到目标的代价，那么A* 将只遵循最佳路径而不会扩展到其他任何结点，能够运行地很快。尽管这不可能在所有情况下发生，但你仍可以在某些特殊情况下让h(n)正好等于实际代价值。只要所给的信息完善，A* 将运行得很完美。

如果h(n)比从n移动到目标的代价高，则A* 不能保证找到一条最短路径，但它可以运行得更快。

另一种极端情况，如果h(n)比g(n)大很多，则只有h(n)起作用，同时A* 算法演变成贪婪最佳优先搜索算法（Greedy Best-First-Search）。
所以h(n)的选择成了一个有趣的情况，它取决于我们想要A* 算法中获得什么结果。h(n)合适的时候，我们会非常快速地得到最短路径。如果h(n)估计的代价太低，

我们仍会得到最短路径，但运行速度会减慢。如果估计的代价太高，我们就放弃最短路径，但A* 将运行得更快。


理解：
如果h比真值大，则A*搜索策略会优先拓展距离终点较近的节点，这些节点之所以具有较小的f值，是因为f值中的大部分由真实里程g值贡献，虚高的h值在其f值中只占小部分；？？
如果h比真值小，则A*搜索倾向于优先拓展距离起点更近的节点，那些节点同比之下具有较小的f值的原因是f值中大部分由被低估的h值所贡献 。



2. 混合A*

HybridAstar算法原理
HybridAstar算法主要分为两部分，一部分是最短路径的栅格代价值生成，有两种方式，一种是采用A*，另一种采用djkstra，但目标都一样，形成最短路径上的栅格代价值；另一部分是曲率采样，也就是所谓路径平滑，和A* 的思想一样采用节点的方式产生树结构，在树结构中引入openlist和closelist两个列表，以此进行树的剪枝和回退操作。根据代价函数，将采样节点放到openlist中，同时根据最优代价从openlist中取出节点，并存放到closelist中，其操作过程和前面提到的A*算法过程一致。





参考：

[启发式搜索算法](https://keson96.github.io/2016/08/02/2016-08-02-Heuristic-Search-Methods/)
[PNC:最短路径搜索之A*算法](https://blog.csdn.net/yuxuan20062007/article/details/80914210)
[详细：A*算法性质及优化!](https://www.docin.com/p-441624963.html)



### IDA*


### 混合A*
(可忽略此部分，更多用于PNC领域，如泊车等场景)
2010年，斯坦福Dmitri Dolgov, Sebastian Thrun, Michael Montemerlo等人在国际顶级期刊International Journal of Robotics Reaserch上首次提出一种满足车辆运动学的算法(Hybrid A*),并在(DARPA)的城市挑战赛中得以运用。Hybrid A*算法是一种图搜索算法，改进于A*算法。与普通的A*算法区别在于，Hybrid A*规划的路径考虑了车辆的运动学约束，即满足了车辆的最大曲率约束。Hybrid A*算法的启发式包括两种: non-holonomic without-obstacles和holonomic with obstacles。前者考虑了车辆的运动约束，但不考虑障碍物，一般使用RS曲线，Dubins曲线；后者将车辆当成网格地图上面的点，但考虑了障碍物。



实际复杂环境中，栅格数目众多，并且环境随时间动态变化，会导致搜索结点过多，因此发展出了多种改进算法，用以处理不同的具体场景：

1) Hybrid A* 算法，在A*算法的基础上考虑了车的最大转向问题，例如限定计算的路径上车最大转向不超过5°。该算法目前的应用场景有车掉头(Stanford 参加DARPA 挑战赛使用的Junior车采用了该算法进行uturn)，泊车等等对方向盘控制要求较高的场景。

2)D*、D*Lite算法，事先由终点向起点进行搜索，使用Dijkstra算法，存储路网中目标点到每个点的最短路径长度k, 和该节点到目标点的实际长度值h，开始情况下 k==h， 并且存储每个节点的上一个节点，保证能够沿着链接走下去。

计算结束后，获取了一条当时最优路径。当车行驶到某个节点时，通过传感器发现该节点已经无法通行(有障碍物)，则对已存储的路网信息一些相关点的h值进行修改(变大)，选择一个邻居点满足仍然h==k的，即仍然是最优路径上的点，作为下一个点。

然后走到终点。该类算法适用于在未知环境中的导航以及路径规划，广泛用于目前各种移动机器人和自主车辆载具，例如“机遇号”和“勇气号”火星车。



#### Dubins曲线

Dubins曲线是在满足**曲率约束**和**规定的始端和末端的切线方向**的条件下，连接两个二维平面（即X-Y平面）的**最短路径**，并假设车辆行驶的道路**只能向前行进**。在1957年, Lester Eli Dubins (1920C2010) 证明任何路径都可以由最大曲率弧或直线段组成（两点之间的路径必须存在）。 换句话说，**连接两点的最短路径将通过最大曲率的圆弧和直线段的构成**。

**车辆单车模型**

**Dubins曲线计算**
令S为车辆直行的Motion Primitive，L和R分别为车辆左转和右转的Motion Primitive，可以证明，**任意起点到终点的Dubins最短路径可以由不超过三个Motion Primitives构成**。由三个Motion Primitives构成的序列称为一个Word。由于两个连续的、相同的Motion Primitive可以合并为一个Motion Primitive，因此所有可能的Word有10中组合，**Dubins证明最优的Word组合只能是6种组合之一**。如下图，分别是LSL，RSR，RSL，LSR，RLR，LRL（注意：对于RLR和LRL两种情况，那个大圆的半径是与两个小圆的半径相等的，否则采用其他4种情况更优)
LSL情况 RSR情况 RSL情况
LSR情况 LRL情况 RLR情况

#### Reeds-Shepp曲线
相比于Dubins曲线只允许车辆向前运动，**Reeds Shepp曲线运动模型既允许车辆向前运动，也允许车辆向后运动**。J Reeds和L Shepp证明Reeds Shepp Car从起点到终点的最短路径一定是下面的word的其中之一。word中的"|"表示车辆运动朝向由正向转为反向或者由反向转为正向。

**位置姿态统一化**

一般在计算之前，会将车辆的姿态归一化。假设车辆的初始姿态为q_{I}=(x_{1},y_{1},\theta _{1})，目标姿态为q_{G}=(x_{2},y_{2},\theta _{2})，车辆的半径为r=\rho。归一化的过程就是向量的平移和旋转的过程，使得变换后的起始位姿q_{I}=(0,0,0)，目标姿态为q_{G}=(x,y,\phi )，车辆的转弯半径r=1。其中，

**利用对称关系降低求解复杂度**
Reeds shepp曲线有48种组合，编程时一一编码计算比较麻烦，因此可以利用其对称性降低求解工作量。具体原理为，将目标点变更后，相当于原目标点A关于y轴与x轴进行对称，得到新的目标点B，生成一组新的路径t，u，v。

**timefilp对称性（符号对称性）**
**reflect对称性（RL对称性）**
**timeflip+reflect**

**Reeds-Shepp曲线结算流程图**

#### 维诺地图

在路径规划中，地图是最基本的要素，也是反映现实世界的一种重要的表达。在常用的地图中，**距离地图、栅格地图和维诺地图**等。其中，栅格地图是地图分成一个个边长相等的栅格来表示环境信息。距离地图是在规划算法进行搜索过程中提供扩展节点到障碍物的最近距离。其中，最近距离是通过欧式距离所计算得到。维诺地图是一种对距离地图的扩展。通过距离地图和广义泰森多边形(generalized Voronoi diagram，GVD)相结合所形成。

**Voronoi图的定义**
又叫泰森多边形或Dirichlet图，它是由一组由连接两邻点直线的垂直平分线组成的连续多边形组成。如图所示：



**Voronoi图的特点**
（1）每个V多边形内有一个生成元；

（2）每个V多边形内点到该生成元距离短于到其它生成元距离；

（3）多边形边界上的点到生成此边界的生成元距离相等；

（4）邻接图形的Voronoi多边形界线以原邻接界线作为子集。

##### 应用
在Hybrid A*算法中，通过使用**维诺地图**获得扩展节点的**势能值**，并将其**作为启发函数的部分代价值**添加到代价函数中，使用这样的方式**让扩展节点与障碍物形成一定的距离**。


![](./assets/混合A_star_势能.jpg)


#### 算法描述

![](./assets/混合A_star与A_star区别.jpg)


Hybrid A*算法是标准A*算法的一种改进，通过这种方式能够使得A*算法满足车辆运动学。与A*算法类似，先将起始点加入开启列表中。在将开启列表中优先级最高的节点加入到关闭列表中前，**判断当前节点是否小于阈值**（源码中为15米），如果小于阈值，则用Reed-Shepp曲线或Dubins曲线与目标相**连接**，并加入车身轮廓**判断是否与障碍物碰撞**。如果和障碍物无碰撞，则保留该曲线并生成路径。如果与障碍物发生碰撞则放弃该曲线，并从开启列表中重新寻找节点，重新进行扩展。

A* 算法的扩展节点是栅格的交点，因此不能解决在连续空间内车辆朝向和位置的问题。而Hybrid A* 算法通过使用车辆运动学生成的轨迹替代A*算法中的节点，从而解决路径不满足车辆运动学的问题。如图所示，A* 算法扩展节点时为八个格子，Hybrid A* 算法扩展节点时有六个运动基原，向前扩展三个运动模式，向后扩展三个运动模式。
 
![](./assets/混合A_star与A_star区别2.jpg)



在Hybrid A*算法中将启发函数分成两种：
**无障碍物的非完整性约束**启发代价和**有障碍物的完整性**启发式代价。

- 无障碍物的非完整约束启发代价

这第一个启发式代价主要是忽略了在路径规划中障碍物对规划器的影响。这项启发函数必须获得**车辆的最小转弯半径**作为输入。并且，改启发函数主要是通过离散周围的栅格地图，获得不同方向坐标点并使用最优曲线计算路径长度。
比如，在需要计算起始点到目标点的最优曲线的路径长度时。首先，是在起始点使用Dubins曲线或者Reeds-Shepp曲线**连接***目标点，得到最优曲线的路径长度。然后，计算最优曲线的距离，并作为启发函数的代价值 。因为这项代价函数忽略了环境中障碍物的影响，所以可以通过离线的形式计算出来。同时，这项代价函数的主要目的是为**修剪**A*搜索树的分支，**避免**了到达目标点时，所规划路径方向与目标**方向不一致**的问题。

- 有障碍物的完整性启发式代价

第二项代价函数主要是**考虑环境中障碍物信息**，但**忽略了车辆的最小转弯半径**对其的影响。通过在每个节点上使用**Djikstra算法**获得该节点到达目标点的**最近距离**作为其代价函数的代价值。由于Djikstra算法能够在类似迷宫环境中获得扩展节点到目标点的最近路径，因此可以避免在扩展过程中Hybrid A*算法**扩展朝向不正确**的问题。

通过比较无障碍物的非完整约束启发代价的代价值和有障碍物的完整性启发式代价的代价值 的大小，**选中其中较大的代价作为Hybrid A*的代价值**。

对于耗散函数，除了要考虑起始点到节点n的距离外，父节点和子节点的运动方向是否一致、控制方向是否一致也需要作为代价值加入到函数中。
其余过程与A*算法类似，每次**从开启列表中选择F值最小的节点进行符合车辆运动学的运动基元进行扩展**。

#### 区别
- 1.混合A*算法更改了连通图的构建方式，混合A*算法是三个维度的； [x, y, theta]
- 2.混合A*算法更改了节点的拓展方式，以[v1, v2, ...]和[δ1, δ2, δ3...] 的组合，按固定值离散来计算车辆状态的，也使混合A *算法**不再具备完备性**；
- 3.混合A*算法新增了节点的属性类别，除了f,g,h, parent, is_opened, is_closed外， 每个节点会记录该节点父节点的状态值和相应的输入控制量；
- 4.混合A*算法变更了搜索策略，引入了RS曲线，可以满足终止位姿的精度，并且削弱使用控制采样带来的非完备性； (RS曲线：将所有圆弧及直线段的排列组合归纳为48种，据此可对平面上的任意七点终点位姿实现衔接，并在车辆运动学意义下保证路径长度最短。  缺点：无法避障，当计算速度快，可先构造rs曲线，再检验碰撞。)
- 5.混合A*算法更改了节点碰撞检测的方式； 区别于A * 中直接查询某点是否存在obs，是通过[x, y, theta]计算车辆轮廓，并验证轮廓内是否有obs。
- 6.混合A*算法更改了启发函数的定义；（由于混合A *旨在提高精度更高的路径，因此不适合用 曼哈顿距离估算h。 而是用两个子启发函数取较大值的方式， max(h_nonholonomics, h_collision_avoidance),即分别为：
1.符合车辆运动学约束但无视碰撞的路径长度。可由RS曲线长度表征。
2.考虑避障但未必符合运动学可行的路径长度。可由A *路径成都与曼哈顿长度取较大值来表征。
为什么要使用两种启发信息？作者是这样解释的，使用第一种（“考虑约束不考虑障碍物”）是为了防止机器人从错误的方向到达目标，作者说实际试验中使用这种启发比不使用的效率提高了一个数量级，看来是必不可少了。使用第二种（“考虑障碍物不考虑约束”）是为了防止在断头路或者U型障碍物里浪费时间。
- 混合A*算法更改了函数g的定义；
    为防止混合A * 搜索得到形态扭曲、反复震荡的路径，在g函数中适当施加对频繁切换输入控制量[v, δ]的惩罚。 由于各节点记录自身由何种拓展到，因此通过将当前子节点与父节点的输入控制量进行对比，可以评估控制量的偏差绝对值，将其补入g中。频繁切换速度或前轮转向均会 导致行车过程损耗时间或能量，虽然在路径生成时不考虑时间相关限制，但基于上述设计的g会使得输出的路径更为合理。





#### 应用场景
● 混合A星**适用**于什么场景？
存在**障碍物**的环境，**低速、有运动约束**的机器人或无人车。在无人驾驶上具体可以用于停车场的自动泊车的路径规划。
这里的关键词是“约束”，如果你看到有人把混合A星用在差速机器人或者全向机器人上，那你就可以得出判断：使用者不懂混合A星。因为，如果机器人没有运动约束，那么完全没有必要用混合A星。
#### 缺点：

不完备！
    混合A * 在拓展子节点时 采样控制变量，而非状态变量。即状态变量是由控制变量*dt 通过前向模型生成的，显然并非所有节点均有可以被拓展到。以为着混合A *不具有完备性（即无法保证有解时 一定找到解） 
    因此虽然针对控制输入变量有利于保证路径的运动学可行性，但会损失完备性，控制变量采样精度越低 则搜索失败率越高。
    而融入rs曲线好处： 


    
        1. 终止位姿可以借此得到精确满足
        2. 在搜索中 间歇性
同时混合A算法产生的路径并非最优的，进行两个阶段进行优化：1. 对轨迹上的顶点进行非线性优化，以改善解的长度和平滑度。2. 执行非参数插值。

知己知彼才能用好，混合A星一个比较大的问题是，它输出的路径质量一般比较差，这里差的意思是指路径包含一些不必要的拐弯或者倒车动作，这就是为什么一般在混合A星之后再**优化**一下，或者把混合A星当成一个给优化算法提供初始路径的子模块，而不是单独使用。
还有，混合A星也是一种**依赖分辨率**的方法，受制于分辨率，它要么有可能找不到解，要么花的时间太多，实时性不好。
　　需要设置的参数有：
　　机器人控制量采样值
　　空间离散的分辨率。空间离散的分辨率如何选择呢？机器人每次运动的距离如何设置呢，显然与空间分辨率有关，如果分辨率太小，计算量就太大；如果分辨率太大，机器人运动距离太小，那么每次生成的节点都在一个栅格里，探索树就没办法扩展。

#### 改进

1 双向探索，即不仅在起点向终点扩展，也从终点向起点扩展。这在终点障碍物密集时比较有效。
2 变分辨率，不使用均匀一致的分辨率，在障碍物附近使用较高的分辨率，原理障碍物使用低分辨率，减少不必要的计算。
3 轨迹片段仿真使用连续变化的控制量。
4 离线化处理 拓展子节点的步骤 查表获取 h_nonholonomics








[Hybrid A *启发式函数](https://zhuanlan.zhihu.com/p/344304259)
[Hybrd A*(混合A*)算法](https://blog.csdn.net/u010241908/article/details/123328550)
[混合A*算法研究!](https://blog.csdn.net/tjcwt2011/article/details/119946259)

### D*

Dijkstra算法，A*（A Star）算法都是一种静态路径最短路径算法，即外界环境不变，计算最短路径。

而外界环境改变时候，它们就无能为力了，这是就需要用到D* (D Star)，也称作Dynamic A*，可以看出来它是A* 的一种**为处理动态环境而改进**的算法。

相比A-star算法，D-star的主要特点就是由目标位置开始向起始位置进行路径搜索，当物体由起始位置向目标位置运行过程中，发现路径中**存在新的障碍时**，对于目标位置到新障碍之间的范围内的路径节点，新的障碍是不会影响到其到目标的路径的。**新障碍只会影响的是物体所在位置到障碍之间范围的节点的路径**。在这时通过将新的障碍周围的节点加入到Openlist中进行处理然后向物体所在位置进行传播，能最小程度的减少计算开销。 

路径搜索的过程感觉其实和Dijkstra算法比较像，A-star算法中`f(n)=g(n)+h(n)`，h(n)在D-star中并没有体现，路径的搜索并没有A-star所具有的方向感，即朝着目标搜索的感觉，这种搜索更多的是一种**由目标位置向四周发散搜索，直到把起始位置纳入搜索范围为止**，更像是Dijkstra算法。



[D*算法详解 一看就会 手把手推导 完整代码注释](https://zhuanlan.zhihu.com/p/366462473) 

[D_star路径搜索算法](https://blog.csdn.net/a380331382/article/details/82841071)
(附录代码见./files/..)
[dijkstra算法 c_干货 | 自动驾驶中的决策规划算法概述](https://blog.csdn.net/weixin_42317626/article/details/112097284)


## RRT
### 1.基础



RRT（快速扩展随机树）算法不同于图搜索算法，它通过在全图中不断随机撒点，将路径像树一样拉伸直至终点，这样它不需要对环境进行数学建模，很适合在动态环境下的快速开拓路径，能够有效地解决高维空间和复杂约束的路径规划问题。实际上，RRT算法正是维护树状结构的过程。适合解决多自由度机器人在复杂环境下和动态环境中的路径规划。

基于采样的算法
RRT随机树：快速随机地扩张，一群像树一样的路径以探索（填充）空间的大部分区域，伺机找到可行的路径。

基本步骤：

起点作为一颗种子，从它开始生长枝丫；
在车辆所处的空间中，生成一个随机点 ；
在树上找到距离 最近的那个点；
朝着的方向生长，如果没有碰到障碍物就把生长后的树枝和端点添加到树上，返回 2；



*伪代码*

```c++  
T.init(root)
for i = 1 to N
        randnode = Sample()
        nearestnode = FindNearest(T, randnode)
        newnode = ExtendByStep(nearestnode, randnode, step)
        if IsValid(newnode)
            T.AddNode(newnode)
        if  Distance(newnode, goal) < threshold then
            return true
        else
            return false
```

思路很简单，先初始化一棵树的根节点，接着在N次迭代中不断撒点，与该点最近的树节点向该点延伸一个步长距离，如果新生长的树枝合法（不与障碍物碰撞）则加入到随机树中。当新生长的树枝与终点足够接近，说明成功找到终点了。


c++实现：

首先定义树状结构的节点，为了方便与栅格地图（数组形式）进行交互，我们用数组下标x，y（而并非笛卡尔坐标xy）来表示节点所占用的体素栅格的位置，节点拥有自身位置、父节点与子节点三项数据。由于RRT节点的子节点数量不定，用一个vector表示，而父节点是为了方便随机树找到终点后回溯路径而设定的。


```c++  

struct PointCell
{
  int x, y;
};
 
struct TreeNode
{
  PointCell cell;
  TreeNode* father;
  std::vector<TreeNode*> children;

```




- 缺点：
不能保证所得出的可行路径是相对优化的



**总结：**

RRT是一种基于采样的规划算法，在机器人领域比较流行。通过对状态空间中的采样点进行碰撞检测，避免了对空间的建模，能够有效地解决高维空间和复杂约束的路径规划问题。

以及一些缺点：

RRT是一种概率完备且不最优的算法，纯粹的随机搜索算法对环境类型不敏感，当空间中包含大量障碍物或狭窄通道约束时，算法的收敛速度慢，效率会大幅下降。另外，难以在有狭窄通道的环境找到路径。因为狭窄通道面积小，被碰到的概率低。

RRT 得到的路径一般质量都不是很好，例如可能包含棱角，不够光滑；
通常也远离最优路径；


### 2.RRT*
RRT*
RRT算法的最优性无法保证，所以又出现了RRT*算法，兼具概率完备性和概率最优性。



RRT* 相比较RRT，多了两点改进：
1，临近空间搜索，
2，树的重新连接。

临近空间搜索就是新节点不再以最近点作为父节点，而是在以新节点为圆心的一个半径内所有节点作为父节点来计算到出发点的距离，选取距离最小的节点作为父节点。

树的重新连接还是以这个圆为范围，将新节点作为圆内所有节点的父节点，计算到出发点距离，如果距离小于原先的到达该节点的距离，就将新节点作为其父节点。

RRT改进：A* + RRT , FN+RRT* ,Informed RRT* ,BIT等等。

[RRT、RRTConnect、RRT*――Matlab算法 ](https://www.cnblogs.com/guojun-junguo/p/10198144.html)


主要特征是能快速的找出初始路径，之后随着采样点的增加，**不断地进行优化**直到找到目标点或者达到设定的最大循环次数。

RRT* 算法是**渐进优化**的，也就是随着迭代次数的增加，得出的路径是越来越优化的，而且永远不可能在有限的时间中得出最优的路径。因此换句话说，要想得出相对满意的优化路径，是需要一定的运算时间的。
所以RRT* 算法的收敛时间是一个比较突出的研究问题。但不可否认的是，RRT* 算法计算出的路径的代价相比RRT来说减小了不少。RRT* 算法与RRT算法的区别主要在于两个针对新节点 $x_{new}$ 的重计算过程，分别为：

1 **重新**为 $x_{new}$ **选择父节点**的过程， 比起RRT多了一个rewire的过程。
2 **重布线**随机树的过程

**重布线**过程的意义在于每当生成了新的节点后，是否可以通过重新布线，使得某些节点的路径代价减少。如果以整体的眼光看，并不是每一个重新布线的节点都会出现在最终生成的路径中，但在生成随机树的过程中，每一次的重布线都尽可能的为最终路径代价减小创造机会。



RRT*算法的核心在于上述的两个过程：重新选择父节点和重布线。
这两个过程相辅相成，**重新选择父节点**使新生成的节点路径代价尽可能小，**重布线**使得生成新节点后的随机树减少冗余通路，减小路径代价。

![](./assets/RRTstar伪代码.jpg)


具体过程：
1. 产生一个随机点xrand。

![](./assets/RRTstar图解1.png)

2. 在树上找到与xrand最近的节点xnearest。

![](./assets/RRTstar图解2.png)

3. 连接xrand与xnearest。
![](./assets/RRTstar图解3.png)


4. 以xrand为中心，ri为半径，在树上搜索节点。

![](./assets/RRTstar图解4.png)

5. 找出潜在的父节点集合Xpotential_parent，其目的是要更新xrand，看看有没有比它更好的父节点。
![](./assets/RRTstar图解5.png)


6. 从某一个潜在的父节点xpotential_parent开始考虑。
![](./assets/RRTstar图解6.png)


7. 计算出xparent作为父节点时的代价。
![](./assets/RRTstar图解7.png)


8. 先不进行碰撞检测，而是将xpotential_parent与xchild（也就是xrand）连接起来。
![](./assets/RRTstar图解8.png)


9. 计算出这条路径的代价。

![](./assets/RRTstar图解9.png)

10. 将新的这条路径的代价与原路径的代价作比较，如果新的这条路径的代价更小则进行碰撞检测，如果新的这条路径代价更大则换为下一个潜在的父节点。
![](./assets/RRTstar图解10.png)


11. 碰撞检测失败，该潜在父节点不作为新的父节点。
![](./assets/RRTstar图解11.png)


12. 开始考虑下一个潜在父节点。
![](./assets/RRTstar图解12.png)


13. 将潜在父节点和xchild连接起来

![](./assets/RRTstar图解13.png)

14. 计算出这条路径的代价。

![](./assets/RRTstar图解14.png)

15. 将新的这条路径的代价与原路径的代价作比较，如果新的这条路径的代价更小则进行碰撞检测，如果新的这条路径代价更大则换为下一个潜在的父节点。
![](./assets/RRTstar图解15.png)


16. 碰撞检测通过。
![](./assets/RRTstar图解16.png)


17. 在树中将之前的边删掉。
![](./assets/RRTstar图解17.png)


18. 在树中将新的边添加进去，将xpotential_parent作为xparent。
![](./assets/RRTstar图解18.png)


19. 遍历所有的潜在父节点，得到更新后的树。
![](./assets/RRTstar图解19.png)






*参考*
[RRT算法原理图解](https://blog.csdn.net/weixin_43465857/article/details/96451631?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&utm_relevant_index=2)

[@@来用C++写一个RRT算法求自主规划的最短路径](https://blog.csdn.net/weixin_42048023/article/details/83747232?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&utm_relevant_index=2)

[【规划】RRT*算法图解](https://blog.csdn.net/yuxuan20062007/article/details/88843690?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&utm_relevant_index=1)






## PRM

[路径规划之PRM类算法](https://zhuanlan.zhihu.com/p/470718576)
第一类算法是PRM（Probabilistic Road Map）类算法，此类算法的核心思想是：**构建连通图**，**搜索最佳路径**。

构建连通图：在C空间（Configuration Space）（对应图 2.2中的所有区域）中随机抽样，采集一系列点，并检测它们是否在自由空间（白色区域）中，并使用本地规划器尝试将这些采样点相互连接起来，仅保留与障碍物无交集的连线，结合起始点和目标点，得到一张连通图；搜索最佳路径：使用图搜索算法基于上述连通图搜索无碰撞路径。


PRM是基于**启发式节点增强**策略的一种路径规划方法，很好的解决了在高维空间中构造出有效路径图的困难。

20世纪90年代初期M.H.Overmars等人提出的Probabilistic Roadmap Method。此方法是基于**采样**算法的一种，很好的解决了在**高维空间**中构造出有效路径图的困难。
该算法通过在构形空间中进行**采样**、对采样点进行**碰撞检测**、测试相邻采样点是否能够连接来表示路径图的**连通性**。此方法的一个巨大优点是，其复杂度主要依赖于寻找路径的难度，跟整个规划场景的大小和构形空间的维数关系不大。 然而当规划的路径需要通过**密集的障碍物或者需要经过狭窄的通道时**，PRM方法的效率变的低下。
路线图算法（probabilistic roadmap method，PRM）主要分为**两个阶段**
**离线学习**阶段中随机采样大量的机器人位姿点，为每个节点搜索邻居节点并建立连接，构建出路标地图；
**在线查询**阶段中根据起始点，目标点，路标地图信息，采用启发式搜索算法从路标图搜索出一条可行路径。路线图算法可以有效避免对位姿空间中障碍物进行精确建模，能够有效解决复杂的运动动力学约束下的路径规划问题。


## DWA
动态窗口法(DWA)

[ROS学习笔记-局部路径规划算法对比](https://zhuanlan.zhihu.com/p/438853951)

算法简介： DWA算法全称为dynamic window approach，其原理主要是在速度空间（v,w）中采样多组速度，并模拟出这些速度在一定时间内的运动轨迹，并通过评价函数对这些轨迹进行评价，选取最优轨迹对应的速度驱动机器人运动。

动态窗口法与ROS默认局部路径规划算法TrajectoryPlanner类似，不同之处在于对机器人控制空间的采样：在给定机器人的加速度极限的情况下，TrajectoryPlanner在整个前向模拟周期内从可实现的速度集合中进行采样，而DWA在给定机器人的加速度极限的情况下仅针对一个模拟步骤从可实现的速度集合中进行采样。在实际使用过程中，TrajectoryPlanner和DWA算法效果类似，但是DWA算法更加高效，占用内存更少，所以在这两种算法中间一般直接选择DWA。

DWA算法在ROS中为dwa_local_planner DWA算法分析参考博文DWA算法分析及实现

优点：

计算复杂度低：考虑到速度和加速度的限制，只有安全的轨迹会被考虑，且每次采样的时间较短，因此轨迹空间较小
可以实现避障：可以实时避障，但是避障效果一般
适用与差分和全向车模
缺点：

前瞻性不足：只模拟并评价了下一步，如在机器人前段遇见“C”字形障碍时，不能很好的避障
动态避障效果差： 模拟运动轨迹断，动态避障效果差
非全局最优路径： 每次都选择下一步的最佳路径，而非全局最优路径
不适用于阿克曼模型车模
(DWA实际上是可以用于低速阿克曼模型的，毕竟DWA采样轨迹基于运动学约束，阿克曼模型简化成自行车模型很容易计算出采样轨迹。)


## TEB算法

1 TEB算法概述
关于eletic band（橡皮筋）的定义：连接起始、目标点，并让这个路径可以变形，变形的条件就是将所有约束当做橡皮筋的外力。

关于time eletic band的简述：起始点、目标点状态由用户/全局规划器指定，中间插入N个控制橡皮筋形状的控制点（机器人姿态）；为了显示轨迹的运动学信息，我们在点与点之间定义运动时间Time，即为Timed-Elastic-Band算法。

注意：

机器人的姿态指的是机器人坐标和朝向，称之为configuration;引入Time的概念，保证机器人运动是实时的，在一定时间内完成。
Time Elastic Band算法把路径规划问题描述为一个多目标优化问题，即对最小化轨迹执行时间、与障碍物保持一定距离并遵守运动动力学约束等目标进行优化。因为优化的大多数目标都是局部的，只与机器人的某几个连续的状态有关，所以该优化问题为对稀疏模型的优化。
求解稀疏模型多目标优化问题，可通过构建超图（hyper-graph），使用g2o（通用图优化）框架中关于大规模稀疏矩阵的优化算法来求解。机器人状态和时间间隔作为nodes，目标函数和约束函数作为edges，各nodes由edges连接构成hyper-graph。在该hyper-graph中，每个约束为一条edge，且每条edge允许连接的nodes的数目不受限制。
Time Elastic Band算法通俗的解释：从给定路径中得到一系列带时间信息的离散位姿（pose），通过图优化的方法将这些离散位姿组成满足时间最短、距离最短和远离障碍物等目标的轨迹，同时满足机器人运动动力学的约束。需要注意的是，优化得到的轨迹并不一定满足所有约束，即给定的约束条件实际上都是软约束条件。


**优点：**

适用于各种常见车模：如差分、全向、阿克曼模型
有很强的前瞻性： 对前方一段轨迹进行优化
动态避障效果好： 对动态障碍有较好的避障效果，可直接使用其封装好障碍类Obstacle

**缺点：**

计算复杂度较大：可通过牺牲预测距离来降低复杂度
速度和角度波动较大、控制不稳定： 源码中是通过两状态之间的距离和角度差及时间差来计算该控制周期内的速度和角速度，使得在控制过程中速度和角度波动较大。

非全局最优： 但是优于DWA
2 Time Elastic Band模型
想要弄清TEB算法的原理以及整个流程，首先弄清楚插入的N各控制点是什么？Time是什么？通过TEB算法处理后最终得到什么？

### 详细：[TEB算法](https://blog.csdn.net/weixin_44937328/article/details/120651200)
起始点：start， 目标点：goal，由全局规划器指定

N个控制点：插入N个控制点(机器人的姿态[x、y、theta])，以这一系列姿态点代表该条路径。

时间分辨率：每两个姿态点之间定义一个时间(等时间间隔)

目标函数(约束条件)：每个目标函数只与橡皮筋中的某几个连续状态有关。而非整条band。

TEB算法就是在全局路径中以固定的时间间隔插入N个状态点，让路径变成一条可以形变的橡皮筋，然后再给它施加一个约束。每个约束可以看作橡皮筋的外力，给橡皮筋施加力以后，橡皮筋会形变，这种形变就是它内部的优化算法。通过这个优化变形，就会找到满足各种约束的最终可行路径。

约束条件/目标函数（常见的四种）：

跟随路径+避障
拉回来+推出去
速度/加速度约束
两个状态点之间，直接用差分近似计算
      
      
运动学约束
若干弧段组成的平滑轨迹，(最小转弯半径)
最快路径约束（区别于最短路径）
TEB优化的问题

TEB是一个多目标优化的问题，大多数目标都是局部的，故只与一小部分参数相关。因此它只依赖于几个连续的机器人状态。

优化算法使用的时开源框架g2o : nodes、edges.

g2o优化算法目标 即这些离散的位姿组成的轨迹能够达到时间最短、路径最短、远离障碍物等目标，同时限制速度/加速度，使轨迹满足机器人运动学。

TEB整个工作流程：

全局路径――――>加入约束条件―――――>g2o优化――――――>速度指令
(等时间间隔插入N个状态点，把它变成橡皮筋)
                               (给橡皮筋施加外力)


## 基于人工势场的算法
APF假设车辆在一种虚拟力场下运动：车辆的初始点在一个较高的“山头”上，要到达的目标点在“山脚”下，这就形成了一种势场，车辆在这种势的引导下，避开障碍物，到达目标点。


当然，人工势场法（APF）也有缺点：可能被困在局部最优解。


## 对比


**场景**：
低速场景：APA
大致分为3类：
基于轨迹规划：需额外考虑速度规划，APA为低速场景，该算法复杂一般不用。
基于路径规划：正弦曲线、多项式曲线、圆弧及公切线、贝塞尔曲线、B样条曲线。
基于经验：模糊逻辑等。


3.2 高速场景：超车
超车分为3个阶段：变道，超越和并道。从本质上看，可认为是驾驶员的两次换道和一次超越行为的综合结果。目前基于多项式的方法用的多一些（对标：LKA也是基于3次多项式）。

局部/全局

A*
混合A*
D*
IDA*

RRT
RRT*


Dijkstra等



lattice
EM




# 控制算法简介


# 控制算法

线性二自由度车辆模型是在简化的基础上研究车辆运动的重要模型：

①简化转向系统，直接输入前轮转角；

②简化悬架系统，认为汽车只做平行于地面的平移运动，即X轴平动，Y轴平动和Z轴的转动。俯仰角和侧倾角为0；

③侧向加速度小于0.4g时，认为轮胎侧偏特性为线性；

④驱动力不大，不考虑地面切向力对轮胎侧偏特性的影响；

⑤忽略空气阻力。


- **控制**：
控制车辆的**转向系统以及制动/驱动系统**使得车辆能够以期望的速度沿着期望的路线行驶，即实现对纵向速度的跟随控制和对侧向的路径跟随控制。

- **预瞄** (横向) + (匀加速模型(+饱和处理) 或 均值滤波(纵向),  双层pid 难于调整参数)
- 模拟驾驶员在开车的过程中，通过对道路前方信息的预估，为了使得车辆实际轨迹与理论轨迹的偏差最小从而得到一个最优的方向盘转角输入。
    - **位置误差(前馈) + 航向角误差(反馈)**
    - 问题
    - 解决轨迹突变时， 如进行**换道瞬间** 方向盘转角突变
        - 由于预瞄点的偏差瞬时增加  所以需要通过渐近改变
            - 虽然规划轨迹是过渡的曲线  但是预瞄点较远 预瞄误差较大  故可渐近增加至预定的预瞄时间 和 距离
    - 自适应 
        - 预瞄距离 时间  `dp = d0 + v * ti`
            - 当车速较低时,如果预瞄的距离过大，就会导致车辆前方的信息无法很好的利用；当车速较高时，如果预瞄距离过短，则会丢失部分未来道路的信息，从而使控制效果变差。
        - 权重： err = add(Gi * ei); -> 前馈方向盘转角 delta
            - 不同预瞄点 赋予不同权重，     
            - 不同的转向曲率也会赋予不同的权重。
        + 模型误差和干扰：车辆的航向角反映了跟踪路径的切线方向而对跟踪的影响较大，
            + 添加基于航向角误差的 反馈控制
    - 多点预瞄：
        - 充分利用更多前方道路的信息 防止单点预瞄的抖动 稳定性更好  信息利用更充分
        - 尤其是应对曲率较大 或者变化大 的轨迹跟踪问题时
    - 最终精度 也就是侧向的跟踪精度 能达到 0.2m以内


- **MPC**
    - 预瞄缺点：基于预描理论的控制方法从本质上来说是一种**无约束**的优化控制方法，因为这种优化控制方法较少考虑到车辆**本身与环境**的特性，比如，从而使得它无法保证车辆在任何工况下都具有很好的**适应性**。执行机构的特性、轮胎与地面的附着特性等
    - 比较准确模型
    - 可控(当系统的状态能够完全由系统的输入确定时，则表明系统是可控的) 
    - 可观(系统的可观指的是根据系统的输出，可以确定系统的状态。)
        - 一般而言，由于传感器**精度**等问题，系统的有些状态是**很难**直接准确测量的，此时就需要结合模型对这些状态进行估计。常用的估计方法就是基于状态观测器采用卡尔曼滤波的方法来进行状态的估计。在利用**卡尔曼滤波**进行状态估计的时候，就要求系统满足**可观测**的要求。在模型预测控制器的设计过程中，需要实时获得系统的状态量，所以就需要确保系统状态的可观性
    - 跟踪误差： 路径误差  速度误差    预测步长大于控制步长
    - 目标函数：Q * 预测步长内 ||y - yref ||^2 +    R * 控制步长内（ ||dU||^2 + U ^2)   
        - 即**追踪性能** 和 **控制输入** 与**控制输入增量**的代价
        - 即 min J(x, du), du的序列
    - 约束 加速度限制 转角限制 以及转角增量限制  连续性
    - 为提高求解速度，非线性ipopt;
        - 线性化 离散化 -》转为qp问题
    - 权重系数设计难：   不管是离散采样的规划问题 还是控制问题 
    - 尤其横纵向一起时，耦合度高 。解耦，纵向单独，将规划出的a给侧向，求相应的 delta。      
    多输入 多输出 
    求解：
    - 推导：
        


   

- **LQR**
- 线性二次型调节器 [LQR,iLQR,DDP控制论经典算法](https://blog.csdn.net/weixin_40056577/article/details/104270668)
- 找一组控制量u0,u1,,使状态量x = [横向误差、横向速度误差、航向误差、航向角变化速度误差] 量足够小，即达到系统稳态。又能使 输入的 u=[转角、油门、制动]较小，即以 花费较小的 控制代价达到目的。
    - 定义目标函数 状态权重Q, 最终状态权重Qf，以及控制权重R。 N为达到最终状态的控制序列个数。
    - 求解： 黎卡提方程 迭代



- Stanley
    - 前轮反馈控制
    - 是 一种基于**前轮**的路径跟踪误差 对方向盘转角进行控制的一种算法
    - **基于前轮的横向跟踪误差(**前轴中心到最近路径点的距离)的非线性函数、能实现横向跟踪误差 **指数**收敛于0
    - 包括： 车辆位姿 与 给定路径的相对几何关系 直观的获取 车辆方向盘转角的控制量
        - **横向**误差 e 和 **航向**误差θ_e  δ(t) = δe(t) + δ_θ_e(t)
        - 计算时可 通过单独计算某一项进行

- PP纯跟踪
    - 为使车辆**后轮** 跟踪圆弧轨迹到达轨迹上某预瞄点，通过转角输出进行跟踪，消除横向误差的方法
    - 根据正弦定理以及切线弦定理，
    以及tan(delta) = L/R, 可计算得到 delta = arctan(2 * L * sinalpha /ld)
    定义横向误差为 ey = ld* sin(alpha), 得到 ey -= ld^2* delta(t)/2/L
    - 得知 跟踪效果由 ld决定。 ld为预瞄点到当前欧式距离。取Ld= kv * v + ld0,与速度有关的一个值。




#  问题
一.轨迹优化
1.说明规划算法建模过程。（如何设计代价函数和约束）

2.说明轨迹规划和路径规划区别。

3.说明规划与控制的区别。（曲线）

4.说明DP和QP优化的时候考虑的约束及优化目标。

5.如何考虑障碍物？

6.说明Lattice和Em的基本思 路。

7.Lattice为什么使用五次多项式？多项式次数对于拟合曲线有什么影响？

8.什么是A*、D*、RRT？用途是什么？

9.说明Dijkstra和蚁群算法的特点。

10.搜索算法有哪些，用途是什么？

11.什么是轨迹生成算法？（曲线）

12.hybrid Astar算法流程及应用

二.控制算法
1.规划和控制的关系？如何相互配合影响的？

2.什么是运动控制？控制具体控制了什么，输入输出是什么？如何实现的？表现到车辆状态上又是怎样的？

3.什么是PID、LQR、MPC算法？用途是什么？分别解决了什么问题？

MPC 1）对于机器人而言，是位置和力。 X = X + dx * t + 1/2 (u/m) * t2，进而转换为 X’ = dx + (u/m) * t 。其中 u 指的是外部的作用力，目标是，尽量小的u，使得预测数值和观测数值之间的误差尽量小。这里面的一个问题是，如何确定在某个时间点需要达到的位置，这个位置应该是时间的函数。

约束：航向角 +- 25； 加速度 +- 1

优化项目：

1）期望的航向角以及加速度角度的变化尽量少，也就是油耗低或者用户的体验好；

2）时间越短越好

如何加上避动态障碍物 ？？


图 Udacity 车辆场景下规划出来的航向角



1) MPC 的预测轨迹点，在什么地方考虑了动态的障碍物。

2) 时间段约束在什么地方体现 ？

3) 可行性轨迹实际上是多条的曲线，在这些曲线中获取的最优解曲线。 曲线并且需要平滑处理

lattice : 位置的可行解空间

TEB和DWA都属于MPC family算法，与MPC一样，基于机器人的姿态和速度以及局部环境图的优化问题在特定时间范围内重复求解。在每个控制周期中，只有第一个时间步的控制变量（ 线速度，角速度）被发送到机器人。

最终转换为QP的二次求解器。



4.传统PID、LQR、MPC各自的优缺点有哪些？对于缺点有哪些解决方法？

5.PID超调如何解决，积分饱和如何解决？LQR如何建模，状态量有哪些，控制量有哪些？

6.如何设计MPC？

三.计算几何
1.如何求点在线上的投影？如何求点到直线距离？

2.如何求SL坐标系

3.两条直线的交点（向量）

4.碰撞检测方法

5.曲线（贝塞尔，b样条，正弦曲线，圆弧曲线，螺旋曲线等）

6.五次曲线、回旋线、三次样条曲线、B样条曲线的表示。

四.车辆动力学和运动学模型
1.车辆动力学和运动学模型不同，原因以及使用的情况

代码类
一.C++编程
1.C++函数指针有哪几类？函数指针、lambda、仿函数对象分别是什么？

2.如何利用谓词对给定容器进行自定义排序？

3.传递引用和传递值的区别？传递常引用和传递引用之间的区别？传递右值引用和传递引用之间的区别？

4.函数对象应该通过什么传递？

5.什么是万能引用？用途是什么？

6.什么是完美转发？用途是什么？

7.std::unorded_map和std::map之间的差异是什么？

8.虚函数、虚表的原理？

9.如何在c++中创建线程？如何在线程间同步？

10.互斥锁是什么？用途是什么？条件变量又是什么？为什么要用条件变量？

11.智能指针和指针之间的差异？为什么要用指针的引用计数？

12.智能指针分哪几种？std::unique_ptr，std::shared_ptr，std::weak_ptr各有何用途？

13.悬挂指针会导致什么问题？如何避免？

14.traits是什么？什么时候用traits？

参考答案（部分）
规划与控制岗
一.轨迹优化
1.说明规划算法建模过程。（如何设计代价函数和约束）

【参考回答】

代价函数：主流算法在frenet坐标系下进行规划，代价也表示在frenet坐标系下。

a) 代价函数：

横向路径维度：guidance+避障+光滑

guidance项：相对中心参考线的横向偏移距离

避障项：与障碍物的距离

光滑项：与参考线的heading夹角，曲率（对应轨迹半径、前轮转角大小），曲率变化率（对应前轮转向速率）

纵向维度：

guidance项：巡航速度偏差

舒适性：加速度，加加速度大小

避障：障碍物距离

b)约束：

横向路径：安全范围，保证不碰撞；heading，确保与参考线的夹角不过大；曲率：方向盘最大转角；曲率变化率：转向系统最大转向速率。

纵向：单调递增约束，保证不发生倒车；station上下限约束，保证不发生碰撞；最大车速约束，保证不超过设定目标速度；加速度边界约束；jerk上下限约束。

2.说明轨迹规划和路径规划区别。

【参考回答】

1).路径规划（Path/Motion Planning），是在不考虑临时或者移动的障碍物的前提下，对车辆在空间上的变化的规划；

2).轨迹规划（Trjectory Planning）一般轨迹规划包括横向规划和纵向规划，横向规划主要输出trajectory中的x, y, s，纵向规划主要填充轨迹上各点期望速度ds/dt。一般横纵解耦规划方案先规划横向，再规划纵向。

3.说明规划与控制的区别。（曲线）

【参考回答】

1).规划是基于环境信息给出一条需要被跟踪的轨迹（包括路径及路径上的速度信息），需要保证安全性、可行性、舒适性；

2).控制是对规划出轨迹进行横向、纵向的跟踪，使得车辆实际允许效果尽量贴近规划轨迹，同时也会再次进一步考虑舒适性、安全性等优化目标及约束。一般规划相对低频，控制更加高频。

4.说明DP和QP优化的时候考虑的约束及优化目标。

【参考回答】

此问题仅针对EM Planner架构，横向上DP主要考虑避障、参考线距离、舒适性，QP主要考虑对DP结果跟踪的精度、舒适性。

5.如何考虑障碍物？

【参考回答】

一般地，横向路径规划主要考虑oncoming障碍物以及静态障碍物；纵向针对动态障碍物进一步处理，确保安全。对于oncoming纵向结果会在横向上投影，下一帧基于新的速度规划结果规划路径。

6.说明Lattice和Em的基本思路。

【参考回答】

Lattice是网格化采样。路径规划采样：向前取若干个距离，每个距离采样不同横向距离，从而获得多排采样点，使用多项式连接不同排采样点获得候选路径；纵向规划采样：采样多各前方时间，每个时间采样不同距离形成一列候选距离，沿时间向前使用多项式连接各列候选距离形成候选距离随时间变化的纵向曲线。路径与纵向规划采样合并后得到候选轨迹，根据cost函数选取cost最低的最优轨迹输出；

EM Planner是在Lattice采样基础，针对采样结果再进行一次优化。采样可以更密集，直接使用直线连接，同时使用DP向前搜索提高效率；优化时考虑舒适性，并贴近DP选出的采样结果。

7.Lattice为什么使用五次多项式？多项式次数对于拟合曲线有什么影响？

【参考回答】

五次多项式有6个系数，起点和终点的0阶/1阶/2阶导约束正好是6个，形成满秩矩阵，唯一地确定多项式各个系数。

8.什么是A*、D*、RRT？用途是什么？

【参考回答】

A* D*是基于搜索的路径规划方法，RRT是基于概率采样的路径规划方法。

D* 主要应用于动态环境下的路径优化，也能兼容静态环境，A* 只能用于静态环境下的路径优化。D* 的实现过程中有和Dijkstra、A* 相似的思想，在初始路径规划的过程中，是一个反向Dijkstra算法，在遇障碍重新规划的过程中，可看做是一个启发式算法A*，只是起点是一些不固定的点，h()充当了启发函数的角色。

9.说明Dijkstra和蚁群算法的特点。

【参考回答】

是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。

蚁群算法是用来寻找优化路径的概率型算法，具有分布计算、信息正反馈和启发式搜索的特征，本质上是进化算法中的一种启发式全局优化算法。适用于大规模高复杂度的问题，只能保证结果是较优解，难以保证最优解。

10.搜索算法有哪些，用途是什么？

【参考回答】

Dijkstra、A*、Lattice采样等。A*是Dijkstra的升级版本，效率更高，Hybrid A*在转向的采样空间内进行A*搜索，主要用于非结构化道路场景如APA泊车；Lattice采样更多用于封闭结构化道路的规划。

11.Dijkstra算法demo

【参考回答】

Dijkstra是一种完备但低效的向周围均匀扩张的算法，采用贪心算法思想解决有权图最短路径问题，类似广度有限搜索；

A*引入启发式函数牵引搜索的方向，提升搜索效率，但搜索结果无法保证满足运动学限制，Hybrid A*是在向前搜索时在可行转角范围内采样不同转角，并使用该转角向前移动一定距离获得下一个位置。Hybrid A*搜索出的转角是不连续的，可能导致方向盘来回摆动，一般和需要再进行一次曲线光滑优化。

（参考深蓝课件）

Maintain a priority queue to store all the nodes to be expanded  
The priority queue is initialized with the start state XS 
Assign g(XS  )=0, and g(n)=infinite for all other nodes in the graph 
Loop 
 If the queue is empty, return FALSE; break;  
 Remove the node “n” with the lowest g(n) from the priority queue  
 Mark node “n” as expanded  
 If the node “n” is the goal state, return TRUE; break;  
 For all unexpanded neighbors “m” of node “n”  
 If g(m) = infinite  
 g(m)= g(n) + Cnm  
 Push node “m” into the queue  
 If g(m) > g(n) + Cnm  
 g(m)= g(n) + Cnm  
 end  
End Loop
12.轨迹规划所使用的坐标系有哪些？它们的有什么不同？分别用于什么场景？

【参考回答】

一般有笛卡尔坐标系、Frenet坐标系2种，具有车道参考线的结构化道路一般可以使用Frenet坐标系，降低问题的数学复杂度，降低问题维度，提升求解效率。无参考线低速非结构化道路功能（如APA）一般使用笛卡尔坐标系。






---

## 无人车 和 机器人 相关规划的区别

1.本质 也是轮式机器人
2.区别：
    - 范围
    - 功能 载人
    - 安全性 舒适性等指标要求不一
    - 规划方法
        - 对运动学的约束等
        - 
    - 场景 (也根据使用不同吧  无人车也有特定场景的)
        - 动态大范围场景
        - 静态场景  

技术栈：

1. 运动底座 vs 参考汽车平台

二者都是运动的控制主体，为上层算法提供控制接口进行驱动，提供查询接口进行反馈。运动底座和汽车进行控制时都要满足非完整约束，即不向前移动的情况下，无法单独完成横向位移。相比于运动底座，汽车平台的动力学模型会更加复杂，除了速度不是一个量级 ，惯性因素也会使得控制更加复杂。汽车的横向位移（转弯）靠前轮的朝向与前后轮形成直线的夹角的变化，属于自行车模型。机器人运动控制多采用差分轮运动底座，横向位移靠两个轮子相互反方向旋转，靠不同的旋转速度比，来满足不同曲率的要求，在控制算法的选取中，会有不同。

 

2. 运算单元

运动控制平台采用的是嵌入式异构计算单板， 满足低速简单运动场景的感知、决策、控制算法的计算要求。汽车应对的是高速、绝对可靠安全的场景，运算量不是一个量级，目前多采用工业级PC的方案来满足感知对于运算量的要求。各芯片厂商也纷纷推出自己的芯片方案，后续运算单元平台将是百花争艳的局面。

 

3. 感知单元

运动控制平台和自动驾驶采用的传感器大多重叠，也有几个不同地方， 如深度摄像头可以在运动控制平台的室内场景中使用，深度主要靠结构光技术，抗干扰能力差，目前在室外场景下不可靠。自动驾驶多采用双目摄像头来完成深度识别。运动控制平台采用超声和红外完成被动障碍感知， 自动驾驶采用汽车电子方面非常成熟的毫米波雷达方案。

 

4. 操作系统

两者都使用 ROS操作系统，汽车对于实时性、 带宽、分布式要求会更加严苛。原生的ROS 对于这三方面都无法达到自动驾驶的要求，虽然 ROS 2.0 会在这三个方面有很大的提升，但是仍然处于实验阶段。大部分自动驾驶厂商，包括百度，都是在ROS基础上作深度定制。 

 

5. 上层算法

两者的软件算法分类基本相同，所采用的算法实现有很多相互借鉴的地方， 在后面的连载文章中会详细介绍。

 

6. 仿真

运动控制平台的场景相对简单，在一些相对高配置的PC上基本能满足要求。自动驾驶一般要自动驾驶厂商自己搭建仿真平台， 汽车要仿真的环境非常复杂，计算量消耗很大，一般要采用云技术分布式平台。 

 

7. 地图

运动控制平台的地图创建所描绘的场景比较简单， 一般2D 场景地图即可满足要求，在运算单元上可以完成创建和使用。自动驾驶需要高精地图， 三维点云，精确到厘米级别， 其特点是需要花费巨大成本提前用采集车采集，生成的高精地图要随时更新，消耗大量的存储，一般要放在云端，自动驾驶车通过高速无线网络下载当时位置的高精地图满足实时决策要求。 

 

8. 训练

运动控制平台会对某些物体或人有简单的识别要求，模型可以提前在服务器端训练，训练数据相对不多。汽车有海量的数据要进行训练，如果要满足高可靠性的物体识别任务，要在云端进行训练。

 

9. 运动控制平台的多机协作 vs 车联网

运动控制平台涉及多机协作的要求，如多个AGV小车互联互通共同完成调度任务，是车车通信的一种方式。车联网方案是自动驾驶的一条路径，在百度Apollo框架中并没有提及。包含V2V(车车通信）、V2I( 车路通信）、 V2P（车人通信），完成信息共享后的汽车决策和控制算法。目前通信标准主要是欧美主推的DSRC(专用短程通信）和中国主推的5G标准LTE-V。


一：感知

自动驾驶传感器包括：

1. 车身运动状态传感器：速度传感器，角度传感器，惯性导航，全球定位系统

2. 环境感知传感器： 激光雷达，超声波，摄像头，毫米波雷达，V2X

3. 驾驶员监测传感器：摄像头，生物电传感器

室外智能机器人传感器包括：

1. 车身运动传感器：速度传感器，惯性导航，全球定位系统

2. 环境感知传感器： 超声波，（摄像头，毫米波雷达，激光雷达）后三个还是可选择状态

二：认知

自动驾驶需识别出人，车，动物，轨道线，交通灯，交通标志等

室外机器人只需要识别边界，墙壁还是路或者还是路牙。

可以看出认知方面，室外机器人还是相对简单，现在使用的方法有深度学习，图像识别等。而自动驾驶需要数据融合后再去做深度学习和图像识别这些事情，显然自动驾驶的难度高很多。

三：规划决策和控制

自动驾驶需要路径规划，轨迹规划，然后进行控制，控制分为横向控制和纵向控制。

室外机器人需要路径规划，建图，分区，控制。

自动驾驶虽然还没有实现，但是高级辅助驾驶（ADAS）已经存在，像自适应巡航（ACC）和车道线保持（LKA）已经应用在某些车上。室外割草机器人利用GPS实现路径规划，或者用IMU已经能够实现路径规划，这样可以提高割草效率。

自动驾驶的相关技术总体来说比室外割草机是高出一个维度的。就市面上的技术来说，室外割草机遇到的技术问题都可以解决。但是自动驾驶和割草机都会遇到一个问题，那就是成本的问题。利用贵的精确的设备，大家都可以做出来。但是由于成本的限制，导致了传感器本身的误差会比理想情况大，这给融合和规划带来很大的挑战。





### 感知slam区别
无人驾驶
虽说无人驾驶很火，尤其近几年。但是基于目前实际街道场景、安全、成本、存储、法律法规等，以及更多实际的未能预料的“坑”，估计短时间内会一直维持现状，难以实现真正的上路。

实际上无人驾驶技术整体上已经非常成熟，整个技术环节也都已完善，在高速路段也许可以真正放开双手，但是在城市到路上个人觉得暂时真的需要打个“？”。这里仅从slam方面说下个人思考。

目前行业上无人驾驶采用方式主要分为两大类：以视觉方案为主，如特斯拉；以激光雷达为主的方案，如google无人车。个人非常崇拜马斯克包括他的个人魅力以及他想打造的帝国，只是我作为一个技术人员的片面认为，采用纯视觉方案十分冒进。这里只谈谈应用于室外无人驾驶的激光雷达slam的方案。

目前无论室内外服务类机器人还是无人驾驶车辆所采用的slam技术实际上从应用角度看仅仅是mapping。即仅第一次采用slam技术对新的环境进行探索并进行自动化地将所采集的数据拼接构建出环境map。然而一般人却会误认为robot在实时导航时实时在采用slam，即同时建图与定位。也许家用扫地机可以如此，因为家庭环境小，允许自由探索。其中室外无人驾驶车辆一般采用3d slam创建3d点云地图。而室内移动机器人则创建的为2d的栅格地图。




无人驾驶车辆实际上并没有采用slam技术，而是采用已有的高精度地图（即提前已获取的地图)进行实时定位。说的通俗的点，即会有专门的采集车（可能也为无人驾驶车量本身，只是应用不同）事先对道路环境进行激光数据采集，然后进行一次真正意义上的slam，创建出环境地图，从此不会再使用真正意义上的slam。

思考1: slam即同时建图与定位，但是无人驾驶在真正应用时仅是使用已有的地图进行实时定位，而不会实时更新地图。如果环境发生了改变，无人驾驶车辆如何感知?
希望有专业人给个详细回答。个人认为暂时没有办法，本身无人车已经有许多冗余设计，允许环境发生一定的改变不会导致严重问题。但是仍是持续改进的问题，此现象需要制作高精度地图的团队进行定期更新。或者每辆无人车上传激光点云数据，后台进行定时匹配更新，此工作量以及通信量十分庞大，不知现在采用何方式。



思考2：采用激光进行slam，在室外一般采用多线激光雷达，创建的地图为3D点云地图，人眼观看可看出环境的基本轮廓与形态。但是不能明确指示是什么，哪里可通过，哪里不可通过，再加上法律法规的约束，使无人驾驶无法像人一样遵守一定规则进行运行；因为纯粹的激光点云地图无法提供语义信息，如人行道，车道，红绿灯等。如何获取这些语义信息?
目前深度学习发展的水深火热，在基于视觉和3d点云的语义分割也有一定造诣，我相信在未来完全可以采用自动语义分割进行自动标注，但目前不现实。现阶段仍是个大问题，因为目前采用的手段主要是在slam后的地图上进行人工标注。“my god”，多么庞大的工作量。即使一般目标检测进行训练标注，整个深度学习过程中，标注过程就占了大部分时间。可想而知完成几条街道的标注，是怎样的工作量，更别说一个城镇，一个城市。同时标注的质量严重影响无人驾驶运行的结果；

思考3：如果像像思考2中回答那样，那高精度地图在语义信息获取方面，现在主要依赖人工标注，从可行性上来看只是工作量问题，而非技术难度问题？所以会有许多制作高精度地图的公司，可独立于无人驾驶公司？ 不知道是否专业人回答，个人觉得现阶段的确是这样，不知道理解是否准确。高精度地图是基础，因此完全可独立于无人驾驶技术存在，可共享所有无人驾驶车辆使用。无人驾驶企业与团队也可专心致力于车辆自动驾驶功能的研发。


思考4：大家都知道在室外运行的汽车，其定位可用gps。因为GPS可提供绝对的位置信息（即使有误差），如果高精度地图的与gps绝对位置进行匹配记录，即已知地图中哪个位置对应的经纬度。如此则无人驾驶车辆第一次开机定位时，可直接获取GPS作为初始位置，开始在其附近搜索点云匹配，则可快速实现激光匹配。同时在激光定位实时，gps同样也可防止激光定位位置丢失。但是市面上基于激光雷达的室内移动机器人反而没有此全局定位信息，初始定位和中间若定位丢失如何解决？如此来看，无人驾驶中的定位技术比较室内移动机器人相对来说反而简单？
不知道是否有专业人给出回答呢。

思考5：目前无人驾驶可行驶的路线显然应是高精度地图中标注的车道线（不能像一般机器人一样任意行走无碰撞，悬崖即可），即可行走的路线点为已知的waypoints。从此方面看，在全局路径规划来看相对于难道与市面上常见的移动机器人如客服类、清洁类反而较低？
从一定程度上来看，无人驾驶算是在已知的结构化道路上运行，而常见的小型移动机器人反而在非结构化环境中运行，其创建的slam地图一般为栅格地图（下节在介绍），会简单指示可行走的区域与不可行走的区域，然后采用如Astar算法或全覆盖算法规划全局路径。从技术上应是一致的，因为无人驾驶也需要从某一位置到达目标位置，中间的全局路线已知，但均为独立的段（即某某路，某某桥等），同样需要类似Astar的规划算法选择几段路线构建全局路线。



思考6：当无人驾驶车辆有了地图，有了定位，有了全局导航路线，剩下则是控制车辆沿着全局路线运行，且不能发生碰撞的交通意外，则可到达目的地，即所谓的局部路径规划。由于车辆在道路上行驶需遵守交通规则，一条路可有多条车道线或一条，而车辆必须在此路的车道线内运行。即如同人开车一样，如果所有车道线上完全无障碍，沿着某一车道线跟踪即可。如果车道内有车辆或其他，则按照一定平滑算法切换一条无障碍的车道即可，或者跟随前车，或者停车（依据障碍状态），可以说更像是策略控制。简单概括来说即加速、减速、变道。但是在室内由于没有一定规律，如人行走，物体摆放等，反而局部避障规划需要一定算法支持。
不清楚理解是否准确，是否有人有相同思考。许多公司都在推出无人驾驶车辆，甚至已经上路，有些在高速上，有些在封闭环境中，可实现固定路线的运行，而非真正在城市间任意道路运行。

思考7：车辆运行在道路上实际上不仅仅是加速、减速、变道，当然我认为其99%时间是在做如此功能。但是剩下1%的时间却要完成99%的功能。就像考驾照一样，将车沿着道路行驶最为简单，但实际上大多时间本是如此。但是却要考虑与学习如红绿灯、前方学校、斑马线、隧道、前方行人，前方交通事故、有人插车、前方有动物、前方堵车、会车、侧方停车、倒车等等。就如同列举一样，但每一种可列举的情况可以根据交通规则与经验用程序控制车辆行为。但是如何保证所列举的情况是完整的？就如同交通法中也无法定义所有行为，同时交通法也在实时更新。更何况不同国家交通规则不一样，甚至同一国家不同城市也有一定区别。同时其他车辆也有不按规则行驶，无人驾驶该如何解决剩下这1%?
我也查过许多资料大多数目前采用均是策略控制，总体采用状态机进行控制车辆行为，即不同情况采用不同策略。而遇到的情景设计中未考虑到的话，仅能停车或者人工控制。 目前随着深度学习不同的深入，也有采用自动处理，但是大家都知道深度学习需要大数据的支持，如果人现阶段未能考虑到情景，其数据又应该如何获得。

思考8：经过以上思考，可看出无人驾驶整体框架与室内移动机器人基本相同，某些方面甚至在室内会考虑更多。但是无人驾驶技术为什么仍是移动机器人导航技术的最高峰？
毕竟刚才的思考均为最基础的框架，本质上基本一致。但是无人驾驶车辆往往运行速度更高，其安全性，可靠性，完善性等性能方面才是无人驾驶技术未来发展的方向和重点解决的方向。因此无人驾驶车辆需要有更加完备的感知传感器、数据融合、语义分析、精确决策，在任何一部分都可以继续深入挖掘。只是现阶段大多数无人驾驶公司在基本框架上短时间内都得到了快速发展，但如今都停留在“真正释放双手”这一步，毕竟安全第一。未来还有太多的坑要填。

思考9：目前室内仓储agv和快递分拣机器人已经成功应用，即环境中全部为智能移动机器人，则完全可按照一定规则进行移动，同时可进行统一调度。同理如果道路上均为无人驾驶车辆，且车辆间可相互通信，则所谓许多坑是否可避免？
个人理解从技术角度来说应该可行，但是从实际出发不可能。因为根本就无法让所有汽车同时更换，必然要经历无人车辆和人类驾驶长期共存时期，“坑”必须要先填，才能到达电影《机械公敌》、《机器人总动员》中描述的场景，全部为无人车辆。
―


## 操作系统的区别
[无人驾驶 | 自动驾驶技术和机器人技术的对比](https://blog.csdn.net/qq_15698613/article/details/112390349)
操作系统主要做什么工作？

每个做计算机行业的人对操作系统的概念既熟悉又陌生。程序员的三大浪漫是操作系统、编译系统和图形学。评价一个牛人的标准之一就是：做过一个操作系统内核，能看Linux 内核代码并做贡献。实际中除非工作需要，软件人员一般不会在操作系统上面下功夫， 一个原因是它的确很难，另一个原因是它像水和空气一样，非常重要，但大部分情况下是免费的。

操作系统的价值

我们执行一段程序，其实不仅仅是代码编译好的机器码在执行，而是在操作系统的协助下一起执行，完成某项工作。操作系统会找到你要执行的程序（磁盘管理），将程序码导入内存（内存管理），分配进程，分CPU时间片去调度。 

你的程序若访问其它硬件资源如显示器，操作系统会给你提供接口，把你的请求连接到显示系统进程中去，将请求翻译成显示屏上的像素值，达到显示目标。进程间对相同资源的访问，操作系统会透明地帮你安排好。 

我们可以想象一下，没有操作系统，软件开发者大部分会成为废人，就算是一个高手，也要关注很多细节才能完成一个简单的任务。大部分操作系统都会有存储管理、内存管理、进程管理等一般化的工作。对于不同的需求，也会衍生出不同的有针对性的操作系统。我们的PC工作站，对人机交互体验和进程调用切换要求会更高一些，对于大部分嵌入式设备，CPU资源的占用敏感，实时性则是考虑重点，而不需要考虑人机交互。

开源Linux 给操作系统领域带来的震撼，改变了这个领域的发展格局，在Linux内核的基础上，各个领域的计算机应用可以进行高效地量体裁衣的定制。以Android为例，很多人可能会以为它是一个全新的操作系统，事实上它是建筑在Linux内核基础上，它的应用有自己的特点，要无痛在各种硬件平台架构上无差异的执行，无论是Arm,PowerPC,还是 X86。 

移动设备一般不会使用PC上的存储设备，但Flash，SD卡高效存取是它要着重考虑的。移动设备对能耗非常敏感，对人机交互要求很高，这一系列因素催生了我们所见到的Android的样子。 

为什么自动驾驶需要操作系统？

一个汽车驾驶系统运行的软件包括感知、控制、决策、定位等一系列高计算消耗，逻辑十分复杂，对安全可靠性要求特别高的程序，简单的单片机肯定搞不定，需要建立在一个成熟的几乎五脏俱全的通用操作系统基础上，同时要满足实时性、分布式、可靠性、安全性、通用性等要求。从头搞一个操作系统是非常不明智的做法，所以对于没有风河Vxworks家底儿的玩家，首选是Linux，然后在Linux 基础上使用中间件的形式去扩展。  

汽车行业的人可能会第一时间站出来表达不同意见，因为搞汽车电子的最熟悉的嵌入式系统是类Unix的QNX, 以往的汽车电子行业的嵌入式开发集中在汽车娱乐系统控制， QNX 体积小速度快，非常稳定和可靠，因此它占据了汽车电子近75%的份额。但是简单几个问题就能理解为什么它不可选：要做感知，目前公认的解决方案是使用深度学习网络进行识别，有现成的深度学习框架运行在QNX上吗，它能驱动GPU加速吗？ 

操作系统的选择更要考虑开发的难度、后续的扩展性和解决方案的开放性。Linux对于自动驾驶及机器人运动控制而言，可以说够，也可以说不够。因为机器人和自动驾驶汽车的自主运动，有一个很大的共性：各种传感、驱动以及模块是各自独立运作的，决策、感知等算法是完全独立的模块，各自工作，同时要互相交流，使用一种规格一致、统一的交流语言。每个模块需要别的模块配合，也就是我们常说的分布式协作系统。 

如果把每个模块放入一个个独立的进程中，进程间通信将是一个十分重要的考虑因素。我们知道的Linux操作系统提供的一系列进程间通信的手段：信号量、队列、管道、共享内存、套接字，可以去做，但这需要大量的技术编码工作，而我们的注意力是算法，不是通信。那怎么解决这个问题呢？

选择ROS操作系统

ROS完全封装了模块之间的通信细节，提供了优雅的方式进行各种类型的交互（ 一对一、多对一、多对多、有返回、无返回、同步、异步），像这种通讯框架，会有很多其它现成的东西可以用。

ROS 巨大的价值不仅如此，因为它出身高贵，前身是斯坦福人工智能实验室的机器人项目STAIR，后来由Willow garage 组织维护。它是免费的开源框架，软件架构清晰一流，提供： 

多语言接口支持

广泛的库文件实现以机动性、操作控制、感知为主的机器人功能

大量的工具组合用以配置、启动、自检、调试、可视化、登录、测试、终止分布式计算系统

 ROS为常用的机器人和传感器提供了硬件驱动接口。从软件架构角度讲，它是 一种基于消息传递通信的、分布式多进程框架。ROS很早就被机器人行业使用，有很多知名的机器人开源库， 例如：

基于Quaternion 的坐标转换

3D点云处理驱动

规划方面的MoveIt

OpenRAVE 规划库

控制方面的OROCOS 实时运动控制库

视觉图像处理方面的OpenCV 和PCL开源库

定位算法SLAM等

这些良好的特性吸引了成千上万的机器人爱好者加入贡献，提供了机器人相关的各种算法包，各大硬件传感器厂商，会缺省提供ROS的驱动Wrapper。ROS的支持与发展依托着一个强大的社区。ros.org尤其关注兼容性和支持文档，提供了一套“一站式”的方案使得用户得以搜索并学习来自全球开发者数以千计的ROS程序包。这个生态是无价的，正因为这样，ROS基本是科研单位和机器人相关行业的首选，更准确的说法是选择Ubuntu+ROS。 

如今是技术开放的时代，做技术框架选择时，不能一味硬着头皮重复造轮子。在选择上，除了看技术先进性， 更要看技术的生态环境，参与到一个强大、开放、可扩展的技术生态中，从中索取和贡献是更明智的。选择Linux, 是因为生态，选择ROS，更是因为生态。

 ROS在自动驾驶上有什么缺陷？

ROS在机器人运动控制中完全够用，但是用于自动驾驶工程实践，其实是有很多问题的。

1. 单点失败问题

ROS的框架示意图如下，我们可以看到各个节点之所以可以互相认识，互相通信，是因为它们在启动前，把自己的信息告知一个统一的ROS Master，ROS Master 是一个名字服务器。



这样就会造成一个问题， 这样的架构不是一个纯粹的分布式架构，有单点失败问题，这个单点专指 ROS Master, 其它应用节点的损失是互不影响的。这个问题对于自动驾驶这种要求高可靠性，甚至会为此设计冗余备份机制的场景来说是完全不能接受的。 ROS 节点与节点之间的通信是Socket，即使一对多的情况， 也是分解成 N对Socket， 如果是多对多，读者可以想象。

2. 带宽拥塞

自动驾驶有很多传感器，如图：



它对于带宽资源是十分敏感的，以摄像头传感器为例，因为自动驾驶要高速行驶，采样率要高，至少每秒30帧， 以1080P的像素计算，大概为 180M/S，而且传感器的数据不只一个节点感兴趣，见下图：



这个带宽的占用是很恐怖的， 这还只是一个摄像头，一般汽车配置多个摄像头， 还有64线雷达，数据量可想而知。当这种订阅者众多的时候，在ROS当前机制下带宽资源消耗是巨大的。 

3. 消息不支持向前兼容

ROS 传递的消息不支持向前兼容，也就是说在后面应用中，在已经定义的消息类型中，增加一个字段，这样新节点和老节点之间就这个消息进行沟通就会发生错误，准确的讲是md5校验失败。接口兼容性问题会对历史数据的使用造成很大的影响，尤其是自动驾驶领域，海量的历史数据是宝库，不能用了，或者做大量的处理才可以用都是不可接受的。

4. 安全问题

如果一个ROS node 被挟持，黑客可以通过这个node 将资源耗尽，进而将这个系统搞垮。如果ROS node与node之间的消息被截获或者伪造，那么自动驾驶汽车可能会被黑客控制。

这四个主要问题，原生的ROS 1.0 都是无法解决的，ROS 2.0 虽然解决了部分，但还在测试阶段， 自动驾驶玩家是没有时间和耐心去等待ROS 2.0成熟的。

 如何解决上述问题？

1. 单点失败问题的解决

解决单点失败一般有两个思路， 一个思路如百度自动驾驶Apollo 采用的一种叫RTPS 的服务发现协议，通过节点之间的自动发现，完成纯粹意义上的p2p分布式拓扑结构，见下图：





 





ROS 2.0 其实也是用相同的思路去解决这个问题，它采用工业级别的DDS 中间件，节点之间可以自动发现。

另一个思路是ROS Master 这个关键节点采取备份机制，如果ROS Master 宕机了，备份节点会顶上，可以采用开源的分布式协调框架zookeeper 去完成这个功能，见下图：



2. 带宽拥塞问题的解决

对于进程通讯使用socket 造成带宽的拥塞和CPU 的负担，方案很简单，进程通信采用共享内存机制，还是拿摄像机为例子，见下图：



使用共享内存的好处，相比于套接字，越是多对多，对带宽利用的优化越明显。ROS 2.0 采用的DDS 中间件方案，已经考虑了进程间通信采用共享内存。

3. 接口兼容问题的解决

对于接口兼容问题， 百度自动驾驶Apollo 框架采用的方案是使用谷歌开源的protobuf（中间消息结构，类比XML,JSON，包括消息传递，序列化和反序列化机制）封装成ROS msg，来代替原生的ROS msg， protobuf 提供了良好的消息向前兼容性。这样修改不破坏原生ROS msg机制，而且仍然使用这个机制通信的其它ROS 节点，是一个比较干净的侵入修改方案。

4. 安全问题的解决

安全方面的问题，可以采用LXC(linux container) 这种轻量级虚拟化技术，把每个ROS node放入沙盒，限制每个ROS node 权限。节点与节点的通信消息可以进行加密解密处理，防止中间有人攻击。

 结语

以上，我们讲述了为什么自动驾驶和机器人运动控制都采用ubuntu+ROS 作为操作系统的背景和原因，总结了目前原生 ROS 1.0 在自动驾驶场景使用的问题及参考修改方案。希望通过本文的描述，大家会对机器人和自动驾驶的软件操作系统层面有一个大概的了解。




运动学 和 动力学

运动学说的只有运动,没有力;动力学里是力加运动
①动力学与运动学两者处理的结果不同：运动学主要是处理各种运动；而动力学主要是处理各种使物体运动的力。
②动力学与运动学两者先后顺序不同：物体运动，就必须有动力支持。所以，动力是因，运动是果。有运动一定用力，用力不一定运动。
③动力学与运动学两者研究对象不同：动力学研究即既涉及运动又涉及受力情况的，或者说跟物体质量有关系的问题。常与牛顿第二定律或动能定理、动量定理等式子中含有m的学问。而运动学不涉及这一点。


对于汽车来说：
车辆运动学和动力学模型概述
要控制车辆的运动，首先要对车辆的运动建立数字化模型，模型的建立越准确，对车辆运动的描述越准确，对车辆的跟踪控制的效果就越好。除了真实反映车辆特性外，建立的模型也应该尽可能的简单易用。车辆模型一般分为运动学和动力学模型。

**车辆运动学模型**把车辆完全视为刚体，主要考虑车辆的位姿（位置坐标、航向角）、速度、前轮转角等的关系，不考虑任何力的影响。
**车辆动力学模型**则需要考虑车辆和地面之间的力的影响，包括轮胎侧偏现象。
在建立两种模型时，思路都是通过建立状态空间方程，以便输入控制量得到理想的状态值；并且一般都是建立为基于误差（位置误差、航向误差等）的状态空间方程。


**车辆运动学模型**
车辆运动学模型常采用自行车模型，基于以下假设：
1）不考虑车辆在垂直方向的运动，假设车辆的运动是一个二维平面上的运动。
2）假设车辆左右侧轮胎在任意时刻都拥有相同的转向角度和转速；这样车辆调度左右两个轮胎的运动就可以合并为一个轮胎来描述
3）假设车辆行驶速度缓慢，忽略前后轴载荷的转移。
4）假设车辆和悬架系统都是刚性系统
5）假设车辆的运动和转向是由前轮驱动的

车辆运动受到运动学约束，比如它不能实现瞬时侧向移动，前驱的车辆必须依赖前轮的转向才能实现变道、转向等操作，在弯道上不能速度过快等等。通常我们采用单车模型(Bicycle Model)对车辆运动进行建模。

**状态量**为：x，y，和x轴夹角
**控制量**：车速和方向盘转角。
在参考点处状态量误差的变化量为。


**车辆动力学模型**
车辆动力学模型根据受力方向又分为横向动力学和纵向动力学，一般解耦后进行研究：
纵向上，通过控制轮胎转速实现速度跟踪。
横向上，通过控制前轮转角实现路径跟踪。
二自由度模型：仅包含车辆横摆与侧向两个自由度。
**状态量（不用）** 横向位置、横向位置变化率、横摆角、横摆角速度

根据**系统状态方程**之后就可以分析出在**给定的前轮转角输入**下，车辆的横向位移、横向速度、横摆角速度的响应。
但是横向跟踪控制的目的是为了减少跟踪误差，需要的状态方程是能够分析在给定前轮转角下车辆跟踪偏差的响应。
以**横向位置误差、横向位置误差变化率、横摆角速度、横摆角误差变化率**作为状态量。
车辆横向动力学模型跟踪误差状态空间方差。



QP 
**问题：**
**求解：**
内点 椭球 增广拉格郎日


带约束的二次型优化存在两种情况，一种是等式约束，另一种是不等式约束

1）等式约束二次型优化：

构建拉格朗日函数转换为无约束优化问题：


极值条件为拉格朗日函数偏导为0：



求解上述条件，求得最优解 


2）不等式约束二次型优化：


根据KKT条件求解：


采用内点法或积极集法求解上述方程组，求得最优解



**求解器：**
    线性：qpOASES, hpipm, OSQP, qrqp, 
    非线性：ipopt

---


判断一个矩阵A是否为正定矩阵有两种方法：

1.求出A的所有特征值。若A的特征值均为正数，则A是正定的；若A的特征值均为负数，则A为负定的。

2.计算A的各阶顺序主子式。若A的各阶顺序主子式均大于零，则A是正定的；若A的各阶主子式中，奇数阶主子式为负，偶数阶为正，则A为负定的。

顺序主子式的计算方式： 在n 阶方阵中，选取行号i，再选取与行号相同的列号i，行与列均取i个元素的行列式即为n阶行列式的i阶顺序主子式。

