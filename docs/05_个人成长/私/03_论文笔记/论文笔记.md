



# 论文相关



## 内容
规划+部分决策
-》实现城市工况多种工况的连续规划


## 算法
### 规划
分层采样 的 创新点



采样终止点 自适应 无解时压缩到近距离

对比有/无细采样 的综合比较
- 有/无情况下 本身的性能 以及 经过二次优化后的性能
    - 优化对 点序列优化  还是五次多项式的参数。。。
- 曲线五次多项式的证明？有无必要证 以及 如何证明


- 采样精度
    - 本车道 邻车道 以及 避让超车
    - 细采样

如何避免和相关文档一致啊。。。


采样时的剪枝 

速度规划时 投影的离散度

- 轨迹相似性检测算法的离线验证


危险情况下 可以相似性差  
决策指令更新 可以允许差 否则渐变到换道不现实。。



### 决策








# TODO：

考虑底层执行模块的延时   进而改进  规划起点 的位置确定

1.需要合理更准确的预测 
如旁车道车辆cut-in时 当其处于切入状态时  预测不准 则自车会加速...
2.紧急状况处理
3.由于 Apollo 平台中采用了路径/速度分离的策略，在路径规划时也需要考虑到当前车辆的运动状态而适当的调整车辆的几何形状。比如在做较大的横向运动的时候，低速和高速下，需要不同的几何形状来保证横向运动的舒适性。
4.道路限速  分段限速  从地图拿到  apollo PathOverLap结构体


当前代码问题：

1. 只提取了前方的参考线，未提取后方的参考线  把参数改一下试试吧。 否则换道时  目标车道后方的车辆在st图中 和不予考虑的



防止跳变 
在这种情况下，建议额外补充一个和上一个计算周期相似性的cost


虚拟墙：需要停止的地方会产生。。。




控制模块 的csc稀疏矩阵的表示  在mpc中的calculateKernel中有



costmap  生成不同的规划结果 带有概率。  如是直接制动很是缓慢减速安全通过两种可能都输出


不同距离 不同的离散精度  还是不同的计算间隔

规划其实包括： 行为规划和轨迹规划  行为规划还需要再学习一下  自己确实和别人已经产生很大差距了呀



对不同情况的分类也可根据自车的w值的大小与变化等进行考虑



考虑后车


考虑几个车道  都只是单向？

双向车道如何考虑： 可参考：无人驾驶汽车离散优化的轨迹规划算法


在实车部分 使用卡尔曼滤波 处理原始数据







## @**驾驶员换道执行持续时间研究**
张良，陈诗慧，张伟（汽车安全与节能国家重点实验室，清华大学工业工程系，北京100084）
摘要：换道行为的研究对于交通流分析和驾驶安全具有重要的意义。本研究采用三种方法收集换道时间数据：**实路高空观测、实路车内观测和驾驶模拟器测量**。数据分析表明在**一定速度区间**内，换道时间不受车辆行驶速度的影响，而当在驾驶模拟器中速度区间继续扩大时，速度的影响变得显著，尤其是**低速时换道时间显著延长**。此外，数据比较结果表明**从换道执行开始到该换道被其他驾驶员发现至少存在0.75s延迟**。
关键词：换道行为；换道时间；实际道路观测；驾驶仿真
换道时间约为5s：
- 1.数据获取
    - 俯空拍摄 偏小 因为起始点和终止点的差距  只有较大侧向偏移时才会识别进换道过程
    - 驾驶员识别 实际道路车内观测 
    - 实验台 驾驶模拟器
- 2.与速度关系
    - 10-20m/s 内差距不大  
    - 低速时时间会延长
- 3.其他与驾驶员年龄、驾龄、性别、性格、交通流、车辆速度、车道宽度、驾驶员疲劳程度等有关。
- 4.可参考：换道发现的延迟  对于预测和规划需要加以考虑...




# 实习前总结
**实习**

## 问题

1. 各模块
- 并行化开发 模块化 
    - 提高效率 各司其职
    - 注意模块间协调、尤其是功能和接口定义
    - 上下游关系： 互相依赖
        - 计算结果的前后一致性 和 可执行性

2. 



# 待实践

## osqp的使用

见规划基础部分









### A* 
(同步搜索 ： A*)


步骤：



缺点：A*算法通过比较当前路径栅格的8个邻居的启发式函数值F来逐步确定下一个路径栅格，当存在多个最小值时A*算法不能保证搜索的路径最优。
A*算法；
A*（A-Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法。**估价值与实际值越接近，估价函数取得就越好**。
A*[1] （A-Star)算法是一种静态路网中求解最短路最有效的直接搜索方法。注意是最有效的直接搜索算法。之后涌现了很多预处理算法（ALT，CH，HL等等），在线查询效率是A*算法的数千甚至上万倍。公式表示为： f(n)=g(n)+h(n),其中 f(n) 是从初始点经由节点n到目标点的估价函数，g(n) 是在状态空间中从初始节点到n节点的实际代价，h(n) 是从n到目标节点最佳路径的估计代价。
保证找到最短路径（最优解的）条件，关键在于估价函数f(n)的选取：
**估价值h(n)<= d(n)到目标节点的距离实际值**，这种情况下，搜索的点数多，搜索范围大，效率低。但能得到最优解。  且h(n) 越小，搜索点越多，范围越大。 
并且如果**h(n)=d(n)**，即距离估计h(n)等于最短距离，那么搜索将严格沿着最短路径进行， 此时的搜索效率是最高的。
如果 **估价值>实际值**,搜索的点数少，搜索范围小，效率高，但不能保证得到最优解。


总的来说：
启发式函数在A* 中的作用
启发式函数h(n)告诉A*从任何结点n到目标结点的最小代价评估值。因此选择一个好的启发式函数很重要。

启发式函数在A* 中的作用
启发式函数可以用来控制A*的行为。一种极端情况，如果h(n)是0，则只有g(n)起作用，此时A* 算法演变成Dijkstra算法，就能保证找到最短路径。

如果h(n)总是比从n移动到目标的代价小（或相等），那么A* 保证能找到一条最短路径。h(n)越小，A* 需要扩展的点越多，运行速度越慢。

如果h(n)正好等于从n移动到目标的代价，那么A* 将只遵循最佳路径而不会扩展到其他任何结点，能够运行地很快。尽管这不可能在所有情况下发生，但你仍可以在某些特                殊情况下让h(n)正好等于实际代价值。只要所给的信息完善，A* 将运行得很完美。

如果h(n)比从n移动到目标的代价高，则A* 不能保证找到一条最短路径，但它可以运行得更快。

另一种极端情况，如果h(n)比g(n)大很多，则只有h(n)起作用，同时A* 算法演变成贪婪最佳优先搜索算法（Greedy Best-First-Search）。
所以h(n)的选择成了一个有趣的情况，它取决于我们想要A* 算法中获得什么结果。h(n)合适的时候，我们会非常快速地得到最短路径。如果h(n)估计的代价太低，

我们仍会得到最短路径，但运行速度会减慢。如果估计的代价太高，我们就放弃最短路径，但A* 将运行得更快。

[A*算法性质](https://www.docin.com/p-441624963.html)

### 混合A*

[Hybrid A *启发式函数](https://zhuanlan.zhihu.com/p/344304259)


---




