{"./":{"url":"./","title":"Introduction","keywords":"","body":"学习笔记 1. 内容介绍 数据结构与算法笔记 包括刷题笔记、数据结构与算法学习笔记、以及编程笔记。 智能车PNC笔记 包括规划笔记、控制笔记等。 车辆相关笔记 包括车辆动力学等笔记。 ..... 环境配置 2. 使用 Tips: 右侧导航如不能链接，可缩放浏览器页面至 100% 试试 Tips:本笔记支持全局搜索 部分图片使用图床，如github无法打开，则无法正常显示，使用科学上网工具即可。 本笔记在gitee和github均更新，gitee由于审核较严格，更新频率较低，如查看最新版本，请移步github pages gitee version: https://afengcodes.gitee.io/learning_note/ github version: https://afengcodes.github.io/Learning_Note/ Tips:由于gitbook不支持导出连续两个{,故代码中均用转义格式\\{\\{代替 3. 更新 本书创建于2021-11-04，不定期随缘更新。 持续更新中ing ... 其他事项 如发现错误，欢迎更正提醒，QQ：1357880195，WX：Ttxs1873707 如需更新某部分内容，欢迎催更 如有更好的资源或算法题解，也欢迎提供, thanks 本笔记整理多种算法模板，并尽可能达到使用时，可直接套模板，如有不一致的情况，欢迎联系修改 cmd : npm run serve 待更新列表 莫队、连通分量、平衡树Treap、ac自动机、后缀数组... 更新记录 update 欧拉路径/回路 update 分治 update 动态开点线段树 update 二维偏序 update 分块&莫队基础 update RRT & RRT* update gitbook global-search update SMT-懒标记 update 单调队列优化DP update KM update simulated annealing(SA) update minimum swap & nuts update some dp update debug-mode update some 板子 update some dp update 树形dp and 区间dp update state-compress dp update gitbook_ update cpp and cpu modify bucket update cpp-note and gitbook update mod & hjt-tree update gitbook update encode update computational geometry update greedy & vector update stl && constructor update osqp update gitbook_ update BST & PNC update BST update osqp update kmp与循环节 update gitbook version modify some bugs update gitbook update lca and 差分约束 update linked list and 差分约束 update pnc and dp update gitbook and 单调队列优化dp update lc update decision update pnc update notes update lca update dp & search update dp update spfa update 图论 update 图论 数论模板 背包 update 图论模板 add dp_数字三角形 LIS... add 线程 update 字典树 add 异常，explicit add 4个强制转换cast update std::move, vtable update gitbook update sort algorithm update kmp add basic, add can add acwing basic add sth add \"adas acc...\" add 分治 add mpc add rand() add robotaxi pnc add sort add djset并查集 add paper add BIT change tree update gitignore and untrack node_modules add gitignore add gitbook mode add some title first commit 2021.11.04 Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-11-15 20:41:30 "},"01_数据结构与算法笔记/":{"url":"01_数据结构与算法笔记/","title":"第一部分：数据结构与算法笔记","keywords":"","body":"本部分内容 内容 包括刷题笔记、算法学习笔记 刷题笔记共 1 篇 算法学习笔记共 8 篇，分别为 基本算法 位运算 递推与递归 前缀和与差分 二分 排序 倍增 贪心 快慢指针 分治 高精度 —————— 启发式合并 manacher算法 最小表示法 构造 打表 基本数据结构 栈 队列 链表与邻接表 哈希 字符串 二叉堆 字典树Trie 搜索 BFS Blood Fill 最短路 多源最短路 最小步数模型 双端队列广搜 双向广搜 A* DFS 连通性 搜索顺序 剪枝与优化 迭代加深 双向DFS IDA* 模拟退火 —————— 爬山法 数学知识 —————— 数据结构进阶 并查集 树状数组 线段树 可持久化数据 平衡树 AC自动机 —————— Splay 树套树 分块 块状链表 莫队 树链剖分 动态树 Dancing Links 左偏树 后缀数组 后缀自动机 点分治和点分树 CDQ分治 仙人掌 动态规划 数字三角形 最长上升子序列 背包模型 状态机 状态压缩DP 区间DP 树形DP 数位DP 单调队列优化DP 斜率优化DP —————— 基环树DP 四边形不等式优化 插头DP 图论 树与图的存储 树与图的遍历 单源最短路概述 朴素Dijkstra 堆优化Dijkstra Bellman-Ford算法 spfa 算法 Floyd算法 最小生成树 Prim算法 Kruskal算法 负环 差分约束 最近公共祖先 强连通分量 双连通分量 二分图 欧拉回路和欧拉路径 拓扑排序 —————— 最大流 最小割 费用流 2-SAT 朱刘算法 Prufer编码 计算几何 二维计算几何基础 —————— 凸包 半平面交 最小圆覆盖 三维计算几何基础 三维凸包 旋转卡壳 三角剖分 扫描线 自适应辛普森积分 阅读 以上每一部分可能与实际章节内容不一致，请参照具体对应章节 对于有些存在前置依赖的内容、请自行在全局搜索或在相关章节中进行查找 Language: c++ (main)，python 更新 1.数学知识篇暂不更新... 2.每章——————以下的内容暂不更新... 3.其余部分随缘新增以及进行内容更新 其他 题目来源： 力扣leetcode AcWing 洛谷 Codeforces 其他 工具： Test Case Generator 力扣leetcode工具 a. Leetcode Problems Rating by @zerotrac b. Leetcode Rating Predictor Codeforces工具 a. cpeditor b. cf-tool 资源整理： RingweEH的蒟蒻的收藏列表（持续更新） 开源项目：io-wiki Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-05-08 14:36:26 "},"01_数据结构与算法笔记/00_刷题笔记/刷题笔记.html":{"url":"01_数据结构与算法笔记/00_刷题笔记/刷题笔记.html","title":"1.-1 刷题笔记","keywords":"","body":"刷题笔记 基本 时间复杂度 一般ACM或者笔试题的时间限制是1秒或2秒。 在这种情况下，C++代码中的操作次数控制在 $10^7∼10^8$ 为最佳。即c++一秒的计算次数。 log10^6 = 20; log10^7 =23,; log10^8 = 27; log10^18 = 60，均为long long(64位) 表示范围 更一般地，有log10^n ~= 3*n 下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择： n≤30, 指数级别, dfs+剪枝，状态压缩dpn≤100=> O(n3)，floyd，dp，高斯消元n≤1000 => O(n2)，O(n2logn)O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Fordn≤10000,10^4 => O(n∗√n)，块状链表、分块、莫队n≤100000,10^5 => O(nlogn) => 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分n≤1000000,10^6 => O(n), 以及常数较小的 O(nlogn) 算法 => 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfan≤10000000,,10^7 => O(n)，双指针扫描、kmp、AC自动机、线性筛素数n≤10^9 => O(√n))，判断质数n≤10^18 => O(logn)，最大公约数，快速幂n≤10^1000 => O((logn)2)，高精度加减乘除n≤10^100000 => O(logk×loglogk)，k表示位数O(logk×loglogk)，k表示位数，高精度加减、FFT/NTT Article:由数据范围反推算法复杂度以及算法内容 其中动态规划的计算量 = 状态数量* 状态转移的计算量 空间复杂度 空间限制： 1 Byte = 8 bit 1 KB = 1024 Byte 1 MB = 1024*1024 Byte 1 GB = 1024*1024*1024 Byte 64 MB = 2^26 Byte , 约 2^24个int，即1600 0000个int。但还有其他占用空间，如函数调用等。所以尽量小于该值。 可计算程序利用了多少内存： (sizeof v...) /1024 / 1024 = ** MB 若计算出的数小于计算数，是因为操作系统对没有进行利用的空间进行了优化。 c++ 默认栈空间 4 MB，所以大数组开到全局变量，放到堆空间里。 4GB = 2 ^ 32 Byte 比赛常用技巧及库函数 1、快速读\\快速写 快读 template void in(T &x) { char ch = getchar(); bool flag = 0;x = 0; while(ch '9') flag |= (ch == '-'), ch = getchar(); while(ch = '0') x = (x 快写 template inline void print(T x) { if(x9) print(x/10); putchar(x%10+'0'); } 2、__int128_t 输入输出： inline __int128 read() { int X=0,w=0; char ch=0; while(!isdigit(ch)) {w|=ch=='-';ch=getchar();} while(isdigit(ch)) X=(X9) print(x/10); putchar(x%10+'0'); } 3、火车头 #pragma GCC optimize(2) #pragma GCC optimize(3) #pragma GCC optimize(\"Ofast\") #pragma GCC optimize(\"inline\") #include 读取和输出 流迭代器 读入输出的一些黑科技：流迭代器 int main(){ vector a; int n;cin>>n; copy_n(istream_iterator(cin),n,back_inserter(a)); copy(a.begin(),a.end(),ostream_iterator(cout,\" \")); return 0; } 效率问题 printf 和 scanf ： stdio.h cin cout ：iostream ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); 一.sync_with_stdio 这个函数是一个“是否兼容stdio”的开关，C++为了兼容C，保证程序在使用了std::printf和std::cout的时候不发生混乱，将输出流绑到了一起。 cin，cout之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段语句可以来打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几. 应用 在ACM里，经常出现数据集超大造成 cin 运行超时 /Time Limit Exceeded【TLE】的情况。这时候大部分人（包括原来我也是）认为这是cin的效率不及scanf的错，甚至还上升到C语言和C++语言的执行效率层面的无聊争论。其实像上文所说，这只是C++为了兼容而采取的保守措施。我们可以在IO之前将stdio解除绑定，这样做了之后要注意不要同时混用cout/cin和printf/scanf之类。 二.tie tie是将两个stream绑定的函数，空参数的话返回当前的输出流指针。 在默认的情况下cin绑定的是cout，每次执行 这俩一个输入同步，一个输出同步 sync_with_stdio是输入同步开关 cin.tie是控制输出同步 用哪个关哪个 注意，这两个代码的头文件是 iostream 并且如果用了这两个，就不要用scanf ,getchar,gets,fgets,fscanf了。 好处：将cin cout速度提升至与scanf相差无几。 副作用：不能scanf cin之类的混用了。 cin与scanf cout与printf效率问题 结论:输出时尽量使用cout,输入时尽量使用scanf. cin cout效率没scanf printf高为何用 主要有以下几个原因： 1.流输入输出对于基本类型来说使用很方便，不用手写格式控制字符串。 2.对于标准库的一些class来说，显然重载操作符也比自己写格式控制字符串要方便很多。 3.对于复杂的格式可以进行自定义操作符。 4.可读性更好（这个很多人有不同意见，见仁见智了）。 其实原理上来说流操作的效率比printf/scanf函数族更高，因为是在编译期确定操作数类型和调用的输出函数，不用在运行期解析格式控制字符串带来额外开销。不过标准流对象cin/cout为了普适性，继承体系很复杂，所以在对象的构造等方面会影响效率，因此总体效率比较低。如果根据特定的场景进行优化，效率可以更高一点。 C++中cin,cout是不是效率不如scanf,printf 十分正确，如果你是做io比赛的或者是做acm的，尽量不要用cin，cout，你试试打印99999999就知道，它们之间速度大概相差10几倍 不定长等问题 读入一行的所有整数 (尤其是未知数量时) #include int h[N], n ; string line; getline(cin, line); stringstream ssin(line); while (ssin >> h[n]) n ++ ; 没有给出矩阵的行列数 有些输入可能是： 输入一个矩阵，每行以空格分隔。 3 2 3 1 6 5 7 8 9 #include #include #include #include using namespace std; int main() { vector> arr; string input; while (getline(cin, input)) { if (input.size() > 0) { stringstream stringin(input); int num; vector a; while (stringin >> num) { a.push_back(num); } arr.push_back(a); } } // 使用自测数据按钮时调试用，正式提交时要删掉。 cout 输入数组中带有中括号和逗号 有些输入可能是，输入一个矩阵： [[3,2,3], [1,6,5], [7,8,9]] #include #include #include #include #include using namespace std; int main() { vector> arr; string input; char *tok; while (getline(cin, input)) { if (input.size() > 0) { vector a; tok = strtok((char *)input.c_str(), \" ,[]\"); while (tok != NULL) { a.push_back(stoi(tok)); tok = strtok(NULL, \" ,[]\"); } arr.push_back(a); } } // 使用自测数据按钮时调试用，正式提交时要删掉。 cout 如例题： 数列的定义如下： 数列的第一项为n，以后各项为前一项的平方根，求数列的前m项的和。 输入描述 输入数据有多组，每组占一行，由两个整数n（n #include #include #include #include #include #include using namespace std; const double N = 10010; int main() { int n, m; string input; while(getline(cin, input)){ if(input.size() > 0){ stringstream ss(input); while(ss >> n >> m){ double ans = n; double sq = n; while(-- m > 0){ sq = sqrt(sq); ans += sq; } cout 用途： 解析字符串： istringstream / stringstream都行 istringstream ss(\"Computer\"); char c1 = ss.peek(); // 只读下一个字符 不取出来 char c2 = ss.get(); // 取出下一个字符 ss.unget(); 把最后一个取出的送回去 int num; ss >> num; // 直接按类型读取 不用逐一还原了 精度 有效数字 C++中设置精度 printf(\"%.3lf\\n%d\",t/n,n*2); //%.3lf 表示保留三位小数后输出 #include const double value = 12.3456789; cout C++ 精度输出：cout 卡常 哈希碰撞 引入 对于一些卡常数的题目，如 最长连续子序列等等。 总所周知，set 和 map 由于树的结构，的单次操作是 (O(log n)) 的。 有没有更快的 STL 可以代替它们呢？ 在 c++11 里面，unordered_set 和 unordered_map 就可以做到单次操作 (O(1))（基于哈希）。 但在 Codeforces 的比赛上面，尽量别用 unoredered_set / unoredered_map。 一是因为 unordered_map 本身自带大常数，有时候跑的甚至没有 map 快。 第二个原因也是最重要的原因是，很多 CF 上的大神直接根据 STL 的源代码来造出 hack 数据，导致单次复杂度劣化成 (O(n))。 如果你很勇直接用 unordered_map 那么你就等着 fst 吧。 那有没有防止被卡的方法呢？ 当然有，那就是自己写哈希函数，然后让哈希函数与时间戳有关就行了。（难道还能预判一个时间来构造 hack 数据不成？ 下面给出哈希函数的代码 : struct custom_hash { static uint64_t splitmix64(uint64_t x) { x ^= x > 7; x ^= x 然后再定义 unordered_map 的时候就可以像下面这样定义了 : unordered_map safe_map; 或者知道key的范围，直接开足够的数组。 解决哈希冲突的常用方法分析 unordered_map 哈希函数 / 如何防止 unordered_map 被卡 哈希碰撞 详细 一、什么是哈希碰撞 所谓哈希（hash），就是将不同的输入映射成独一无二的、固定长度的值（又称\"哈希值\"）。它是最常见的软件运算之一。如果不同的输入得到了同一个哈希值，就发生了\"哈希碰撞\"（collision）。 二、哈希碰撞产生原理 举个例子，假设要将某些元素存放在长度length，则其中某一个元素的key值为k，则其哈希值hash的计算公式为： hash = (k)%length 假设length = 16，那么两个不同元素的key值分别为12和28，那么他们所取得的hash值都等于12，这就造成冲突了。 三、解决方法 1.开放地址法 开放地址法有一个公式： Hi = H((key)+di) % m (i = 1,2,3,...,k) (k 其中，m为哈希表的表长，di是产生冲突时的增量序列。 ①线性探查法 当didi取值为1，即为线性探查法，每次冲突后，向后移动一个位置。 基本思想： 将散列表T[0…m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：d，d+l，d+2，…，m-1，0，1，…，d-1即:探查时从地址d开始，首先探查T[d]，然后依次探查T[d+1]，…，直到T[m-1]，此后又循环到T[0]，T[1]，…，直到探查到T[d-1]为止。 探查过程终止于三种情况： (1)若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）； (2)若当前探查的单元中含有key，则查找成功，但对于插入意味着失败； (3)若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。 缺点： 处理溢出需另编程序。 按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表 HT 中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记，否则，将会影响以后的查找。 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。 ②线性补偿探测法 将线性探测的步长从 1 改为 Q ，即将上述算法中的 j ＝ (j ＋ 1) % m 改为： j ＝ (j ＋ Q) % m ，而且要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。 ③随机探测法 将线性探测的步长从常数改为随机数，即令： j ＝ (j ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。基于与线性探测法相同的理由，在线性补偿探测法和随机探测法中，删除一个记录后也要打上删除标记。 2.再哈希法 这种方法是同时构造多个不同的哈希函数： Hi=RH1（key） i=1，2，…，k 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。 3.链地址法（拉链法） 可以理解为数组+链表，即在一个线性数组里的每一个元素存储一个链表的头结点。例如：， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，则进行B.next = A，Entry[0] = B，如果又进来C,index也等于0，那么C.next = B，Entry[0] = C。也就是说数组中存储的是最后插入的元素。 优点： ① 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短； ② 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况； ③ 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； ④ 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 缺点： 指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。 1 常见 小知识点 1 数学 1 取整 向上取整在c++ 中: ceil()表示向上取整,floor()表示向下取整 当然,这很显然对浮点数很好用. 但如果两个int类型的数想要向上取整呢? (只适用于n,m为正数) 我们用(n-1)/m+1 或 (n-1+m)/m1来表示即可，而不是用ceil(n/m) 当然也可以ceil(1.0*a/b); 如 -1/3 = -0.3 ,向上取整 为0 而用(-1 - 1) / 3 + 1 = 0 + 1 = 1,显然不对。(/为向上取整) 若非要答案取0，则用ceil(1.0*(-1)/3) = 0的方式。 2 取模 模运算： 公式 1： (a b) % m = ((a % m) (b % m)) % m 公式 2： (a + b) % m = (a % m + b % m) % m 负数取模 所有要做减法求模的行为要小心结果为负数，我们减法之前先加上 mod，保证结果为正。 查找给定哈希值的子串 对于a可能为正，也可能为负的情况...求a对M的模数？？？ ( a % M + M ) % M int a = -2; int mod = 3; cout [例]如求数组元素中任取数字，满足和为k(k > 0)的倍数的方案中 和的最大值。 其中元素有正有负。 如凑k = 7 ,如选了一个8， 为满足k的倍数。需要取 - 1 ,或者6等. 即-1 和 6都能使其满足k的倍数。 emm 好像不用。则有 -1 % 7 = 6 % 7 是成立的。 为保证上式的算法中实现，则 需要对 -1 先处理，即 （-1 + 7）% 7 为实际贡献量？ 而是要注意在做减法时， 即加上 a[i] % k 后达到 j，可知需要从 j - a[i] % k 转移而来。 而 j - a[i] % k 可能为负值。 如 j = 1, a[i] % k = 3, 则需要从 j - a[i] % k = -2 转移而来 。 而实际上等价于 j =( 1 + k ) - a[i] % k = 8 - 3 = 5 转移。 即需要把 -2 换成5，而不是直接 (j - a[i] % k ) % k = -2。 可通过加一个mod = k = 7的方式换成 5。 即上述所说 做减法求模的行为要小心结果为负数，我们减法之前先加上 mod，保证结果为正。 即 (a - b) % k == 写成 ==> (a - b + k) % k (当0 ((a - b) % k + k) % k.(更准确) #include using namespace std; int T,n; const int N=110,INF=0x3f3f3f3f; typedef long long ll; int a[N],f[N][N]; int main() { int n,k; scanf(\"%d%d\",&n,&k); for(int i=1;i 3 取平均 正数 a>0,有a>>1与a/2等价，向下取整 同理用 a+b>>1 与(a+b)/2 等价 而负数时则不一样负数/2 为上取整 ，>> 1为下取整。 总结： / 2为round(),即向0取整。 >> 1为floor(), 向下取整。 cout > 1) 三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应： （1）floor()的英文含义是地板，所以是向下取整，方便记忆叫它地板函数。会取不大于自变量的最大整数，这样自变量是3.1或3.9是没有区别的，返回都是3；自变量是-2.1或-2.9也是没有区别的，返回都是-3； （2）ceil()的英文含义天花板，所以是向上取整，它就是天花板函数。会取不小于自变量的最大整数，这样自变量是3.1或3.9，返回都是4；自变量是-2.1或-2.9，返回的都是-2； （3）round()的英文含义周围，环绕，这个就是常用的四舍五入函数，因为它会返回离自变量最近的整数，这个返回的整数可能大于也可能小于原来的数，但是一定是离它最近的那个整数，比如12.5返回13，12.4返回12。 还有一种四舍五入的方法 （int）（m +0.5）。 4 取中位数 中位数： len & 1 == 1， 为 中间那个 len & 1 == 0, 为 中间两个平均 计算技巧： 取 第 i = len + 1 >> 1 和 j = len + 2 >> 1 小的两个元素取平均即可。 对于 len & 1 == 1： 1 2 3 4 5 len = 5, i = 3, j = 3　为同一个数，即中间的数。 对于 len & 1 == 0: 1 2 3 4 5 6 len = 6, i = 3, j = 4, 为中间两个数，取平均即可。 （同步 基本算法中：中位数） 见： Hard：寻找两个正序数组的中位数 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 class Solution { public: double findMedianSortedArrays(vector& nums1, vector& nums2) { int m = nums1.size(), n = nums2.size(); int left = m + n + 1 >> 1, right = m + n + 2 >> 1; // + 1, + 2 return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; } int findKth(vector& nums1, int i, vector& nums2, int j, int k){ if(i >= nums1.size()) return nums2[j + k - 1]; if(j >= nums2.size()) return nums1[i + k - 1]; if(k == 1) return min(nums1[i], nums2[j]); int midv1 = (i + k / 2 - 1 2 赋初值 memset和memcpy const int N = 10; int a[10]; memset(a, -1, sizeof a); a (1111 1111 1111 1111 1111 1111 1111 1111) (1111 1111 1111 1111 1111 1111 1111 1111)... 把-1的第八位给a[i]的每一位, a[i] = -1 memset(a, 0x3f, sizeof a) a (0011 1111 0011 1111 0011 1111 0011 1111) (....) a[i] = 0x3f3f3f3f = 10 61109567; 0xffffffff = 42 94967295; INT_MAX = 21 4748 3647; INT_MIN = -21 4748 3648; #include #include #include #include using namespace std; const int N = 10; int a[N], b[N]; int main() { memset(a, -1, sizeof a); memset(b, 0x3f, sizeof b); for(int i = 0; i 常用 memset(h, -1, sizeof h); memset(dist, 0x3f, sizeof dist); memset(f, 0xcf, sizeof f); // f[i] = -808464433 memcpy(back, f, sizeof f); // 备份数组 赋值问题 memset 赋初值为无穷大和无穷小 如果问题中各数据的范围明确，那么无穷大的设定不是问题，在不明确的情况下，很多程序员都取0x7fffffff作为无穷大，因为这是32-bit int的最大值。如果这个无穷大只用于一般的比较（比如求最小值时min变量的初值），那么0x7fffffff确实是一个完美的选择，但是在更多的情况下，0x7fffffff并不是一个好的选择。 很多时候我们并不只是单纯拿无穷大来作比较，而是会运算后再做比较，例如在大部分最短路径算法中都会使用的松弛操作： if (d[u]+w[u][v] 3 进制转换 任意进制转化 #include const int N=1e5+3; int n,m,x,tmp,ansl; char a[N],ans[N]; inline int n_to_ten(){ int x=0; for(int i=0;a[i];++i){ x*=n; if (a[i]>='A' &&a[i] 编写一个程序，可以实现将一个数字由一个进制转换为另一个进制。 这里有 62 个不同数位 {0−9,A−Z,a−z}。 输入格式 第一行输入一个整数，代表接下来的行数。 接下来每一行都包含三个数字，首先是输入进制（十进制表示），然后是输出进制（十进制表示），最后是用输入进制表示的输入数字，数字之间用空格隔开。 输入进制和输出进制都在 2 到 62 的范围之内。 （在十进制下）A=10，B=11，…，Z=35，a=36，b=37，…，z=61 (0−9 仍然表示 0−9)。 输出格式 对于每一组进制转换，程序的输出都由三行构成。 第一行包含两个数字，首先是输入进制（十进制表示），然后是用输入进制表示的输入数字。 第二行包含两个数字，首先是输出进制（十进制表示），然后是用输出进制表示的输入数字。 第三行为空白行。 同一行内数字用空格隔开。 // 10进制中转 作为跳板 // 输入样例： 8 62 2 abcdefghiz 10 16 1234567890123456789012345678901234567890 16 35 3A0C92075C0DBF3B8ACBC5F96CE3F0AD2 35 23 333YMHOUE8JPLT7OX6K9FYCQ8A 23 49 946B9AA02MI37E3D3MMJ4G7BL2F05 49 61 1VbDkSIMJL3JjRgAdlUfcaWj 61 5 dl9MDSWqwHjDnToKcsWE1S 5 10 42104444441001414401221302402201233340311104212022133030 输出样例： 62 abcdefghiz 2 11011100000100010111110010010110011111001001100011010010001 10 1234567890123456789012345678901234567890 16 3A0C92075C0DBF3B8ACBC5F96CE3F0AD2 16 3A0C92075C0DBF3B8ACBC5F96CE3F0AD2 35 333YMHOUE8JPLT7OX6K9FYCQ8A 35 333YMHOUE8JPLT7OX6K9FYCQ8A 23 946B9AA02MI37E3D3MMJ4G7BL2F05 23 946B9AA02MI37E3D3MMJ4G7BL2F05 49 1VbDkSIMJL3JjRgAdlUfcaWj 49 1VbDkSIMJL3JjRgAdlUfcaWj 61 dl9MDSWqwHjDnToKcsWE1S 61 dl9MDSWqwHjDnToKcsWE1S 5 42104444441001414401221302402201233340311104212022133030 5 42104444441001414401221302402201233340311104212022133030 10 1234567890123456789012345678901234567890 常规思路 用十进制作为中转 代码： #include using namespace std; const int maxn = 1100; #define fir(a,b,c) for (int a=b;a=0; i--) t[len-i-1] = str1[i] -(str1[i]=1; i--) { t[i-1] +=t[i]%m*n;//开始计算,首先*n,为n进制,然后转移到m进制 t[i] /= m;//当前数已经处理完了 } A[k++] = t[0] % m;//直接加到答案数组中 t[0] /=m;//当前数已经处理完了 while(len>0&&!t[len-1]) //处理0的情况 len--; } str2[k] =NULL;//第k位,我们不需要,直接抛去,利用NULL这个特殊的字符串结束符,具体可以自行百度. fir(i,0,k-1) str2[k-1-i] = A[i]+(A[i] 常用 16 -> 10 写出一个程序，输入一个十六进制的数值字符串，输出该数值的十进制字符串。 输入样例： 0xA 输出样例： 10 #include using namespace std; int main(){ string a; while (cin>>a){ int flag = 0,sum = 0; if(a[0] == '-') flag++; string b = a.substr(2 + flag); reverse(b.begin(),b.end()); for (int i = 0; i ='0'&&b[i]= 'A' && b[i] 4 常用库函数 C++库常用函数一览 本部分中提到的函数库有： **判断大小写** islower(char) isupper(char) **判断是否是字母** isalpha(char) 可代替 isupper( ch ) || islower( ch ) - 判断字符ch是否为英文字母，若为英文字母，返回非0（小写字母为2，大写字母为1）。若不是字母，返回0。 **判断数字** isdigit(char) // 其他 isalpha; //是否字母 iscntrl; //是否控制符 isdigit; //是否是数字 isgraph; //是否字母、数字或标点 islower; //是否小写 isprint; //是否可打印字符 ispunct; //是否标点 isspace; //是否空格 isupper; //是否大写 isxdigit; //是否十六进制数字 tolower; //转为小写 toupper; //转为大写 clock() strcmp(); strlen(); strcpy(); strcat(); memcpy();//对数字的处理 memset(); hypot(double,double);//计算三角形的斜边长 sqrt(double); sin(); cos(); pow(); // 其他 abs; //绝对值 acos; //反余弦 acosf; //反余弦 acosl; //反余弦 asin; //反正弦 asinf; //反正弦 asinl; //反正弦 atan; //反正切 atan2; //y/x的反正切 atan2f; //y/x的反正切 atan2l; //y/x的反正切 atanf; //反正切 atanl; //反正切 ceil; //上取整 ceilf; //上取整 ceill; //上取整 cos; //余弦 cosf; //余弦 cosh; //双曲余弦 coshf; //双曲余弦 coshl; //双曲余弦 cosl; //余弦 exp; //指数值 expf; //指数值 expl; //指数值 fabs; //绝对值 fabsf; //绝对值 fabsl; //绝对值 floor; //下取整 floorf; //下取整 floorl; //下取整 fmod; //求余 fmodf; //求余 fmodl; //求余 frexp; //返回value=x*2n中x的值,n存贮在eptr中 frexpf; //返回value=x*2n中x的值,n存贮在eptr中 frexpl; //返回value=x*2n中x的值,n存贮在eptr中 ldexp; //返回value*2exp的值 ldexpf; //返回value*2exp的值 ldexpl; //返回value*2exp的值 log; //对数 log10; //对数 log10f; //对数 log10l; //对数 logf; //对数 logl; //对数 modf; //将双精度数value分解成尾数和阶 modff; //将双精度数value分解成尾数和阶 modfl; //将双精度数value分解成尾数和阶 pow; //计算幂 powf; //计算幂 powl; //计算幂 sin; //正弦 sinf; //正弦 sinh; //双曲正弦 sinhf; //双曲正弦 sinhl; //双曲正弦 sinl; //正弦 sqrt; //开方 sqrtf; //开方 sqrtl; //开方 tan; //正切 tanf; //正切 tanh; //双曲正切 tanhf; //双曲正切 tanhl; //双曲正切 tanl; //正切 printf/scanf fopen,freopen,fclose getchar,fgets // greatest common divisor 最大公约数 __gcd // least common multiple 最小公倍数 lcm int c = __gcd(a, b); int lcm = (a * b) / __gcd(a, b); // int gcd(int a, int b) // 欧几里得算法 // { // return b ? gcd(b, a % b) : a; // } dec 置基数为10 相当于\"%d\" hex 置基数为16 相当于\"%X\" oct 置基数为8 相当于\"%o\" setfill( 'c' ) 设填充字符为c setprecision( n ) 设显示小数精度为n位 setw( n ) 设域宽为n个字符 ▲setw(n)用法： 通俗地讲就是预设宽度 这个控制符的意思是保证输出宽度为n。如： cout ★ C++20 ＜numeric＞数值计算全部函数 iota(first, last, start_val); 用起始值的连续增量填充单容器 accumulate（first ，last，n）; 求和，n为初始值； adjacent_difference（first，last，result）; 求相邻元素的差，后减前，result为差的序列在原序列开始的位置 checked_ adjacent_difference(first,last,result); inner_product(first1,first2,last1,last2); 将对应元素相乘并求出累计和 partial_sum（first，last，result）; 求到任意位置的累计和，result为和的序列在原序列开始的位置 字符串 和 数字 转化 atoi---ASCII to integer,将字符串转换成整形，从数字或正负号开始转换，一直到非数字为止 itoa---integer to ASCII--将整形转换成字符串 atof---ascii to float--字符串转换成浮点型 atol---ascii to long---字符串转换成长整形 gcvt---浮点型转换成字符串（四舍五入） strtod---字符串转换成浮点型 strtol---字符串转换成长整形 strtoul--字符串转换成无符号长整形 toascii---将整形转换成合法的ASCII码字符 _ttoi---可以将CString转换成整形 _itot_s---将int转换成char* 详细： stoi（字符串，起始位置，n进制），将 n 进制的字符串转化为十进制 示例： stoi(str, 0, 2); //将字符串 str 从 0 位置开始到末尾的 2 进制转换为十进制 string str1 = \"237\"; int a = atoi(str1.c_str()); cout/include 原型：double atof(const char *nptr); 作用：把字符串转换成浮点数，直至遇到第一个空格。 二、 itoa() 头文件#include/include 原型：char* itoa(int value,char* string,int radix);其中，value是要转换的整数值，string是存储转换后值的字符数组，radix代表进制，radix=10就是十进制，radix=2就是二进制。 作用：将整数转换为字符串。 下面是我在使用这个函数时遇到的一些问题， 1. 第二个参数只能是char*,不能是string； 2. 第二个参数在使用之前必须提前分配存储空间，在C++中就是new一块内存。 三、atoi()与stoi() 头文件: #include/#include 原型：int atoi(const char *nptr); 作用：把字符串转换成整型数。如果第一个非空格字符不存在或者不是数字也不是正负号则返回零，否则开始做类型转换，之后检测到非数字或结束符 \\0 时停止转换，返回整型数。atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界；stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！ 四、c_str() 头文件：include 作用：将string对象，转化为char*对象。它是String类中的一个函数，它返回当前字符串的首字符地址。 手动实现： C语言 atof()的实现 STL函数 STL常见算法总结 STL算法部分主要由头文件,,组成。 STL中算法大致分为四类： 1、非可变序列算法：指不直接修改其所操作的容器内容的算法。 2、可变序列算法：指可以修改它们所操作的容器内容的算法。 3、排序算法：包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。 4、数值算法：对容器内容进行数值计算。 以下对所有算法进行细致分类并标明功能： 1.1 查找算法 判断容器中是否包含某个值 adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。 binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。 count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。 count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。 equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。 find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。 find_end: 在指定范围内查找\"由输入的另外一对iterator标志的第二个序列\"的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的\"另外一对\"的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。 find_first_of: 在指定范围内查找\"由输入的另外一对iterator标志的第二个序列\"中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。 find_if: 使用输入的函数代替等于操作符执行find。 lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。 upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。 search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。 search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。 1.2 排序和通用算法 提供元素排序策略 inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。 merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。 nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。 partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。 partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。 partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。 random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。 reverse: 将指定范围内元素重新反序排序。 reverse_copy: 与reverse类似，不过将结果写入另一个容器。 rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。 rotate_copy: 与rotate类似，不过将结果写入另一个容器。 sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。 stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。 stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。 1.3 删除和替换算法 copy: 复制序列 copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。 iter_swap: 交换两个ForwardIterator的值。 remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。 remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。 remove_if: 删除指定范围内输入操作结果为true的所有元素。 remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。 replace: 将指定范围内所有等于vold的元素都用vnew代替。 replace_copy: 与replace类似，不过将结果写入另一个容器。 replace_if: 将指定范围内所有操作结果为true的元素用新值代替。 replace_copy_if: 与replace_if，不过将结果写入另一个容器。 swap: 交换存储在两个对象中的值。 swap_range: 将指定范围内的元素与另一个序列元素值进行交换。 unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。 unique_copy: 与unique类似，不过把结果输出到另一个容器。 1.4 排列组合算法 提供计算给定集合按一定顺序的所有可能排列组合 next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。 prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。 1.5 算术算法 accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。 partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。 inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。 adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 1.6 生成和异变算法 fill: 将输入值赋给标志范围内的所有元素。 fill_n: 将输入值赋给first到first+n范围内的所有元素。 for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。 generate: 连续调用输入的函数来填充指定的范围。 generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。 transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。 1.7 关系算法 equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。 includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的1.8 集合算法 set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。 set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。 set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。 set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。 1.9 堆算法 make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。 pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被\"弹出\"的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。 push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。 sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。 其他函数 二进制1的个数：__builtin_popcount(int x); — Built-in Function: int __builtin_clz (unsigned int x) 返回前面引导位0 的个数，如果x=0 的话，结果未知； C++ _builtin系列函数 在用到位运算的时候用这些函数会更加快捷 __builtin_ffs(x) 返回x xx的最后一位1 11是从后向前第几位 2.__builtin_clz(x) 返回x xx的二进制下前导的0 00的个数 3.__builtin_ctz(x) 返回x xx的二进制下末尾的0 00的个数 4.__builtin_popcount(x) 返回x xx的二进制下1 11的个数 5.__builtin_parity(x) 返回x xx的二进制下1 11的个数的奇偶性 C++ _builtin系列函数 gcc内置函数 GCC自带的一些builtin内建函数 常用技巧 C++容器倒序取元素 vector v = {1, 2, 3, 4, 5}; cout 给数组中的一段元素赋予一段升序的值 vector v(5); iota(v.begin(), v.end(), 2); 数组的值变成{2, 3, 4, 5, 6} 用emplace代替push、insert，可以直接传构造函数的参数 vector > v; v.emplace_back(3, \"abc\"); 等价于v.push_back(make_pair(3, \"abc\")) iota模板// 实现 template void iota (ForwardIterator first, ForwardIterator last, T val) { while (first!=last) { *first = val; ++first; ++val; } } 例题见例题部分。 #include #include #include // std::iota template vector idxsort(const vector &v) { // 建立下标数组 vector idx(v.size()); iota(idx.begin(), idx.end(),0); // 调用sort函数，匿名函数自动捕获待排序数组 sort(idx.begin(), idx.end(), [&v](int i1, int i2) {return v[i1] a{3,2,1,5,4}; vector idx = idxsort(a); // idx: 2 1 0 4 3 //获取第i小的值 a[idx[i]] // i 从0开始 // 区别于离散化中 find 用于得到 每个原元素的排序位置。 vector alls; int len; int find(int x) { lower_bound(alls.begin(), alls.begin() + len, x) - alls.begin() + 1; } alls = a; sort(alls.begin(), alls.end()); // alls.erase(unique(alls.begin(), alls.end()), alls.end()); len = unique(alls.begin(), alls.end()) - alls.begin(); find(a[i]); alls[k - 1]; // 另外对于非重复数组可以用排序+map记录每个元素应在下标0`(n - 1) // 详情见 循环节 vector all; all = a; sort(all.begin(), all.end()); map mp; for(int i = 0; i 5 随机 随机数 产生0-n的随机数 rand()%(n+1) C++ 随机数生成 标准库（被包含于中）提供两个帮助生成伪随机数的函数： 函数一：int rand(void)； 从srand (seed)中指定的seed开始，返回一个[seed, RAND_MAX（0x7fff）(即 [0- 32767])间的随机整数。 函数二：void srand(unsigned seed)； 参数seed是rand()的种子，用来初始化rand()的起始值。 可以认为rand()在每次被调用的时候，它会查看： 1） 如果用户在此之前调用过srand(seed)，给seed指定了一个值，那么它会自动调用 srand(seed)一次来初始化它的起始值。 2） 如果用户在此之前没有调用过srand(seed)，它会自动调用srand(1)一次。 根据上面的第一点我们可以得出： 1） 如果希望rand（）在每次程序运行时产生的值都不一样，必须给srand(seed)中的seed一个变值，这个变值必须在每次程序运行时都不一样（比如到目前为止流逝的时间）。 2） 否则，如果给seed指定的是一个定值，那么每次程序运行时rand（）产生的值都会一样，虽然这个值会是[seed, RAND_MAX（0x7fff）)之间的一个随机取得的值。 ??seed是0还是1？？ 3） 如果在调用rand()之前没有调用过srand(seed)，效果将和调用了srand(1)再调用rand()一样（1也是一个定值）。 举几个例子，假设我们要取得0～6之间的随机整数（不含6本身）： 例一，不指定seed： for(int i=0;i 每次运行都将输出：5 5 4 4 5 4 0 0 4 2 例二，指定seed为定值1： srand(1); for(int i=0;i 每次运行都将输出：5 5 4 4 5 4 0 0 4 2 跟例子一的结果完全一样。 例三，指定seed为定值6： srand(6); for(int i=0;i 每次运行都将输出：4 1 5 1 4 3 4 4 2 2 随机值也是在[0,6）之间，随得的值跟srand(1)不同，但是每次运行的结果都相同。 例四，指定seed为当前系统流逝了的时间（单位为秒）：time_t time(0)： #include //… srand((unsigned)time(0)); for(int i=0;i 第一次运行时输出：0 1 5 4 5 0 2 3 4 2 第二次：3 2 3 0 3 5 5 2 2 3 总之，每次运行结果将不一样，因为每次启动程序的时刻都不同（间隔须大于1秒？见下）。 关于time_t time(0)： time_t被定义为长整型，它返回从1970年1月1日零时零分零秒到目前为止所经过的时间，单位为秒。比如假设输出： cout 值约为1169174701，约等于37（年）乘365（天）乘24（小时）乘3600（秒）（月日没算）。 另外，关于ran_num = rand() % 6， 将rand()的返回值与6求模是必须的，这样才能确保目的随机数落在[0,6)之间，否则rand()的返回值本身可能是很巨大的。 一个通用的公式是： 要取得[a,b)之间的随机整数，使用（rand() % (b-a)）+ a （结果值将含a不含b）。 在a为0的情况下，简写为rand() % b。 最后，关于伪随机浮点数： 用rand() / double(RAND_MAX)可以取得0～1之间的浮点数（注意，不同于整型时候的公式，是除以，不是求模），举例： double ran_numf=0.0; srand((unsigned)time(0)); for(int i=0;i 运行结果为：0.716636，0.457725，…等10个0～1之间的浮点数，每次结果都不同。 如果想取更大范围的随机浮点数，比如1～10，可以将 rand() /(double)(RAND_MAX) 改为rand() /(double)(RAND_MAX/10) 运行结果为：7.19362，6.45775，…等10个1～10之间的浮点数，每次结果都不同。 至于100，1000的情况，如此类推。 以上不是伪随机浮点数最好的实现方法，不过可以将就着用用… //==典型的随机数实现=================== static unsigned int g_seed = 0; void srand(int seed) { g_seed = seed; } int rand() { g_seed = 214013 * g_seed + 2531011; return g_seed ^ g_seed >> 15 } 随机数产生器 Implement Rand10() Using Rand7() Rand7()genetate 1- 7, to inplement Rand10() using Rand7(); /** * 思路： * * （1）由大的随机数 生成小的随机数是方便的，如 rand10 -> rand7 * 只需要用 rand10 生成等概率的 1 ~ 10 ，然后判断生成的随机数 num ，如果 num [1 ... 63] * if(num [1 ... 21] * if( num [1...49] * 则等概率映射范围调整为 [1...45]， 1 + num % 9 * if(num 具体代码： int rand10() { while(true){ int num = (rand7() - 1) * 7 + rand7(); // [1, 49] if(num 同理，可用于其他由randA() - > randB() 用(randA() - 1) * A + randA()生成数，对B取整后 + 1返回。 继续把剩余的数利用起来形成 (left - 1)& * randA() + rand()继续执行知道不可行或几乎没优化空间了。 测试效率： #include #include #include #include using namespace std; int rand7() { return rand() % 7 + 1; } int rand10() { while(true){ int num = (rand7() - 1) * 7 + rand7(); // [1, 49] if(num 测试中10^6次，大概400+次需要进行while第二轮循环。即大概0.04%的概率。 随机抽样与打乱 水塘抽样 (蓄水池抽样) 蓄水池抽样算法 最近经常能看到面经中出现在大数据流中的随机抽样问题 蓄水池就是装水的池子，当池子满的时候，每倒入一滴水就有一滴水被替换。 即：当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等。 当 k = 1 时 也就是说，我们每次只能读一个数据。 假设数据流含有N个数，我们知道如果要保证所有的数被抽到的概率相等，那么每个数抽到的概率应该为 1/N 那如何保证呢？ 先说方案： 每次只保留一个数，当遇到第 i 个数时，以 1/i的概率保留它，(i-1)/i的概率保留原来的数。 举例说明： 1 - 10 遇到1，概率为1，保留第一个数。 遇到2，概率为1/2，这个时候，1和2各1/2的概率被保留 遇到3，3被保留的概率为1/3，(之前剩下的数假设1被保留)，2/3的概率 1 被保留，(此时1被保留的总概率为 2/3 1/2 = 1/3) 遇到4，4被保留的概率为1/4，(之前剩下的数假设1被保留)，3/4的概率 1 被保留，(此时1被保留的总概率为 3/4 2/3 * 1/2 = 1/4) 以此类推，每个数被保留的概率都是1/N。 证明使用数学归纳法即可 当 k = m 时 也就是说，我们每次能读m个数据。 和上面相同的道理，只不过概率在每次乘以了m而已 洗牌算法 Article:经典洗牌算法 ｜ 附严格证明 shuffle算法的核心在于能等概率的产生所有可能的排列情况。 所有的排列是什么样的呢？其实学过初等数学的一定知道排列组合这样的基本问题。对n个不同元素进行排列，我们可以从第一位开始枚举，选择1～n中的某一个，然后进行第二位的枚举，选择剩下的n-1个中的某一个...直到选取最后一个元素。 这样的排列总数为 n! 。 那shuffle的时候如何保证等可能的选择其中某一种呢？ 第一直觉可能是对这n!排列方式的每一种遍一个号，从n!中随机选取一个编号，找到对应的方案即可。如何编号呢，也很简单，我们可以直接按照字典序排列。 但如果你从排列的方式思考一下从n!中选随机数的方案，另一种符合直觉的方式其实也很容易想到。 n! = n * (n-1)! 这里的n就是你先挑选出第一个元素的种类数；然后(n-1)!就是对其他元素的排列。所以我们要选一种洗牌方案，就可以先等概率的从n个元素中挑选一个作为第一个元素；然后再对剩下的(n-1)个元素作类似的选择。这样就相当于把 n! 分成 n 段，先选择其中一段，里面有 (n-1)! 个元素，我们把这(n-1)!个情况分成 (n-1) 段，再随机选一个，以此类推。 这样的策略是可以做到从 (n-1)! 中随机选数的。 证明： 好吧，我们如何严格证明这样的洗牌算法是等概率的呢？ 其实我们只要看每个位置出现各个元素的概率是不是都是1/n即可。 我们来看第一个位置，由于我们是从n个元素中随机选择一个，每个元素出现的概率显然是1/n。 而对于第二个位置，我们要考虑这个元素没有出现在之前的选择中，然后是从剩下n-1个元素中随机选择一个，所以任意一个元素出现的概率是 ((n-1)/n) (1/(n-1)) = 1/n 。 同样，第三个位置，任意元素出现的概率应该保证前面两个位置都没有选中，那是 (n-1/n)(n-2/n-1)*(1/n-2) = 1/n 。 依次递推，所以你会发现每个位置任意元素出现的概率都是相等的， 1/n 。 这就可以严格的证明我们的算法是正确的。 class Solution { vector backup,output; public: Solution(vector& nums) { backup = nums; output = nums; } vector reset() { output = backup; return output; } vector shuffle() { // 对于 i = n-1 ~ 1, 交换 i ,(0 ~ i) for(int i = output.size()-1;i>=1;i--){ swap(output[i],output[rand()%(i+1)]);} return output; } }; 6 常识 常识： 闰年：if((a%4==0 && a%100!=0) || a%400==0 ) 周几：给出年月日，计算周几：蔡勒公式 // 适用于1582年（中国明朝万历十年）10月15日及以后的情形 // 400年的整数倍（如1600年）的3月1日都是星期三，计算和0年（实际不存在，只是为了避免负数范围足够大）3月1日的距离。 // 为什么选3月1日呢？这样可以避免闰年里是否包含2月29日的判断问题，我们可以将3月1日视为每年的第一天。 // 为什么选400年的整数倍呢？因为此法考虑到100年不闰与400年闰的问题，选取正好400年的整数倍可以让year/4-year/100+year/400直接表示闰年带来的天数。 class Solution { public: string dayOfTheWeek(int day, int month, int year) { month-=2; if(month 7 常用模板 区间合并 常用 区间合并 模板题 AcWing 803. 区间合并 // 将所有存在交集的区间合并 void merge(vector &segs){ vector res; sort(segs.begin(), segs.end()); // 排序啊 按起点 int st = -2e9, ed = -2e9; // 预处理边界 for (auto seg : segs) if (ed 区间插入 插入区间 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1： 输入：intervals = [[1,3],[6,9]], newInterval = [2,5] 输出：[[1,5],[6,9]] 示例 2： 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] 输出：[[1,2],[3,10],[12,16]] 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 示例 3： 输入：intervals = [], newInterval = [5,7] 输出：[[5,7]] 示例 4： 输入：intervals = [[1,5]], newInterval = [2,3] 输出：[[1,5]] 示例 5： 输入：intervals = [[1,5]], newInterval = [2,7] 输出：[[1,7]] 提示： 0 解： 本题中的区间已经按照起始端点升序排列，因此我们直接遍历区间列表，寻找新区间的插入位置即可。具体步骤如下： 首先将新区间左边且相离的区间加入结果集（遍历时，如果当前区间的结束位置小于新区间的开始位置，说明当前区间在新区间的左边且相离）； 接着判断当前区间是否与新区间重叠，重叠的话就进行合并，直到遍历到当前区间在新区间的右边且相离，将最终合并后的新区间加入结果集； 最后将新区间右边且相离的区间加入结果集。 vector> insert(vector>& intervals, vector& newInterval) { vector> res; int i = 0; //[[1,2],[3,5],[6,7],[8,10],[12,16]] new = [4,8] while(i 进阶： 统计区间中的整数数目 见 数据结构进阶 章节的 线段树 部分。 8 其他功能 程序计时 //计算一段程序运行的时间 #include #include using namespace std; int main() { clock_t startTime,endTime; startTime = clock();//计时开始 for (int i = 0; i 计算vector 效率 计算cout 和printf 效率， printf大概一秒输出1w个数，是 cout 的5倍 以及卡时函数，模拟退火等情况下可用 while ((double)clock()/CLOCKS_PER_SEC 9 易错 变量合理使用 // 不要改变之后还要用的n值 int n ; cin>>n; while(n--){ DoSth(); } // 此时 n==-1 啊 for(int i =0;i // 在循环中 1.++i,--i 比i++,i-- 快， 2.注意size_t类型的使用误区 for(int i=0;i=0;--i) { } for(size_t i = N;i>=0;--i) { } //!!!! 有问题！！！ vector追加一份 vector a{1,2,3}; for(auto c:a) a.push_back(c); // wrong 1 永远加不完 a.insert(a.end(),a.begin(),a.end()); // wrong 2 for(int i =0;i 非 需要初始化 全局变量数组默认是0 // 在全局变量中 // 不行，需要const // int N=1e6+10; // 可以 const int N=1e6+10; int a[N]; size_t size_t是sizeof运算符的结果类型。使用size_t变量数组中的模型的大小或指数。size_t传达了语义：您立即知道它代表一个以字节为单位的大小或一个索引，而不仅仅是另一个整数。同样，使用size_t字节表示大小有助于使代码具有可移植性。 该size_t类型用于指定内容的大小，因此很自然地使用它，例如，获取字符串的长度然后处理每个字符：for (size_t i = 0, max = strlen (str); i = 0; i--)由于无符号值的包装行为，这将导致无限循环（尽管我已经看到编译器对此提出警告）。也可以通过以下方式缓解此问题（稍难理解，但至少可以避免包装问题）：for (size_t i = strlen (str); i-- > 0; )通过将减量转换为延续条件的检查后副作用，这将对减量前的值进行连续性检查，但仍在循环内使用减量值（这就是循环从而len .. 1不是从处运行的原因len-1 .. 0）。 但也存在很多意想不到的bug 如滑动窗口最大值中，对循环变量进行数学运算啊，即使得到负值也会被类型转化成size_t,即无符号，使得结果为一个极大的正值。。。 函数的形参啊 别用i，j啊 为了避免重复啊, 也别用st 会和state数组重复 可用src等 短路问题 运算顺序问题 优先级误区 逻辑运算中的短路现象（短路原则是 与（&&） 或（||） 才有。） 对于 a=0;b=1 c=a&&(b=3) //最终c=0; b=1 因为从左至右进行时，若遇到运算符左边的操作数是 0（逻辑假），则停止运算。 a=1;b=1;c=0; d=a||b||(c=b+3); //最终d=1;c=0; 因为从左至右进行时，若遇到运算符左边的操作数是 1（逻辑真），则停止运算。 &&比||优先级高 但并不意味着先执行。即优先级只是决定了表达式的结合次序，而不是运算顺序！ 即对于 a||b&&c ，虽然相当于a||(b&&c) 但是若a为true，则b&&c不会执行 若a为false，而b为false，c也不会执行 因此 int x = 3; int y = 1 || (x = 1) && (x += 1); //此时虽然相当于 int y = 1 || ((x = 1) && (x += 1)); //但由于短路现象，有 x = 3，y =1 迭代器失效 set 类模板中，erase() 方法有 3 种语法格式，分别如下： //删除 set 容器中值为 val 的元素 size_type erase (const value_type& val); //删除 position 迭代器指向的元素 iterator erase (const_iterator position); //删除 [first,last) 区间内的所有元素 iterator erase (const_iterator first, const_iterator last); map 等容器的[]问题 map mp; mp[1] = 2; if(mp[100] == 0) { deal(); } 此时 mp.size() == 2 正确应该用mp.count(100) == 0 出现 问题题目 ：周赛：找出数组中的所有孤独数字 vector> vec(4); 直接写成set st[4]; 传二维数组 Article:c++ -- 二维数组参数传递 需要传第二维的维数.. #include using namespace std; /*传二维数组*/ //第1种方式：传数组,第二维必须标明 /*void display(int arr[][4])*/ void display1(int arr[][4],const int irows) { for (int i=0;i 习题册 错误1 ： set st; st.insert(1); st.insert(2); for(auto& a:st){ if(a==1) st.erase(a); //会报错 } // 不报错写法 for(auto& a:st){ if(a==1) st.erase(a); continue; } // 但是为啥要进行循环呢......时间复杂度直接调高了O(n) // 直接用 st.erase ( deleVal); set的迭代器啊如set st{1,2,3,4,10}; auto it1 = st.upper_bound(4); auto it2 = st.lower_bound(5); return it1-it2; // 错误 常用计算 若定义子字符串 是字符串中一个连续（非空）的字符序列。 则有每个位置的元素在所有子字符串中出现的次数为(i+1)(n-i) 推倒： 若长度为n,则某一子字符串若包含第i个元素，[l,r]需要满足： 0\\le l \\le i i\\le r \\le n-1 因此，共有(i+1)(n-i)个子串。 M-所有子字符串中的元音 class Solution { public: vector a(31,-1);// 报错位置 int fib(int N) { // ... return a[N]; } }; 报错error: expected parameter declarator，是因为编译器无法区分该语句是成员变量声明还是成员函数声明！！！ 可改成vector a=vector(31,-1);// 修改后。其他类型同理。。。 题目思路 常用技巧 排序 倒序 二分 前缀 逆向 逆向补集 逆向思考 终态思考 双指针(从0开始，从n-1开始...) 预处理+枚举 等 关于题目所用方法，根据题目特性选取。对于多解法，掌握基本解法的基础上尝试其他解法，如板子。当然有的题目有数学性质或脑筋急转弯特点，可能效率更快 如在状压DP部分中一道题目，D-数组的最大与和。 本笔记共整理了6种算法。 状态DP (见动态规划状压dp) 三进制 最小费用最大流 (见图论) 估计是每个人最晚的算法 模拟退火 (见搜索部分) 其他方法不会时，可以尝试 贪心 KM (见图论二分图部分) 最快，而且有板子 其中不同的算法，耗时比较： 一个简单的整数问题2 同样整理了三种方法。 树状数组 维护差分数组和另一个推导数组 代码简单，难推导 线段树 + 懒标记 代码复杂，但有板子 分块 例题 终态 统计道路上的碰撞次数 在一条无限长的公路上有 n 辆汽车正在行驶。汽车按从左到右的顺序按从 0 到 n - 1 编号，每辆车都在一个 独特的 位置。 给你一个下标从 0 开始的字符串 directions ，长度为 n 。directions[i] 可以是 'L'、'R' 或 'S' 分别表示第 i 辆车是向 左 、向 右 或者 停留 在当前位置。每辆车移动时 速度相同 。 碰撞次数可以按下述方式计算： 当两辆移动方向 相反 的车相撞时，碰撞次数加 2 。 当一辆移动的车和一辆静止的车相撞时，碰撞次数加 1 。 碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。 返回在这条道路上发生的 碰撞总次数 。 示例 1： 输入：directions = \"RLRSLL\" 输出：5 解释： 将会在道路上发生的碰撞列出如下： -车 0 和车 1 会互相碰撞。由于它们按相反方向移动，碰撞数量变为 0 + 2 = 2 。 -车 2 和车 3 会互相碰撞。由于 3 是静止的，碰撞数量变为 2 + 1 = 3 。 -车 3 和车 4 会互相碰撞。由于 3 是静止的，碰撞数量变为 3 + 1 = 4 。 -车 4 和车 5 会互相碰撞。在车 4 和车 3 碰撞之后，车 4 会待在碰撞位置，接着和车 5 碰撞。碰撞数量变为 4 + 1 = 5 。 因此，将会在道路上发生的碰撞总次数是 5 。 示例 2： 输入：directions = \"LLRR\" 输出：0 解释： 不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 0 。 分析题意： 当两辆移动方向 相反 的车相撞时，碰撞次数加 2 。 --> 两辆车被撞停，答案 + 2。 当一辆移动的车和一辆静止的车相撞时，碰撞次数加 1 。 --> 一辆车被撞停，答案 +1。 显然，左侧的 L 和右侧的R 不会被撞停；而中间的车辆都会最终停止，因此统计中间的、一开始没有停止的车辆数（即不是 S 的车辆数）即可。 class Solution { public: int countCollisions(string s) { int l = 0, r = s.size() - 1; while(l 或者 class Solution { public: int countCollisions(string directions) { int ans = 0, x = 0, y = 0; for (char c : directions) { if (c == 'L') ans += x; else x = 1; } reverse(directions.begin(), directions.end()); for (char c : directions) { if (c == 'R') ans += y; else y = 1; } return ans; } }; 最小差值 I 给你一个整数数组 nums，和一个整数 k 。 在一个操作中，您可以选择 0 解： class Solution { public: int smallestRangeI(vector& nums, int k) { int minNum = *min_element(nums.begin(), nums.end()); int maxNum = *max_element(nums.begin(), nums.end()); return maxNum - minNum [网易T3：二叉树] 构造一个有n个节点的完全二叉树，要求该二叉树满足： 1.所有节点的权值值为1-n的排列。 2.除了根节点外，每个节点的权值和它父亲的权值的乘积为偶数。 输出该构造出的二叉树的层序遍历结果。 回溯 ```c++// 暴搜 ：搜到一个可行解后停止搜索即可 using namespace std; const int N = 200010; int n; int f[N]; int cnt = 0; // i 2i- 1 2i +1// i i / 2 //f[i][0] 表示为偶 //f[i][1] 表示为奇 void dfs(int* f, int cur, int odd, int even){ if(cur == n + 1){ if(odd == 0 && even == 0){ int so = 1, se = 2; for(int i = 1; i } if(cnt == 1) return; if(odd if(cur == 1){ f[cur] = 2; dfs(f, cur + 1, odd, even - 1); f[cur] = 1; dfs(f, cur + 1, odd - 1, even); }else{ if(f[cur/2] == 1){ f[cur] = 2; dfs(f, cur + 1, odd, even - 1); }else { f[cur] = 1; dfs(f, cur + 1, odd - 1, even); f[cur] = 2; dfs(f, cur + 1, odd, even - 1); } } } int main() { cin >> n; int odd = n + 1 >> 1, even = n >> 1; dfs(f, 1, odd, even); return 0; } - 取巧 然而根据完全二叉树性质，以及1-n内，偶数总不多于奇数，所以先把偶数填完，最后一层填奇数就能满足要求。 ```c++ cin >> n; int ji = 1, ou = 2; while(ou HDUOJ 2045染色问题 染色问题(n个格子，3种颜色) 有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法. 解： 递推公式： A1 = 3 A2 = 6 //A(3,2)=6 A3 = 6 //A(3,3)=6 An=2*A(n-2)+A(n-1), n>=4 证明： 考虑第n-1个格子: 如果这个格子和第1个格子颜色不同，那么第n个格子只有1种选择，前n-1个格子的选择就是A(n-1)，此时n个格子的选择是1*A(n-1) 如果这个格子和第1个格子颜色相同，那么第n个格子只有2种选择，前n-2个格子的选择就是A(n-2)，此时n个格子的选择时2A(n-2) 所以有An=2A(n-2)+A(n-1), n>=4 remak: 因为我们是考虑第n-1个格子，该格子和第1个格子的颜色可能相同也可能不同，所以n>=4才可以。不然n=3的话，第n-1=3-1=2个格子和第一个格子的颜色必然不同了，就没有上面这2种情况了，所以要从n>=4开始推导。 long long func(int n) { long long num[51]={0}; num[0]=3; num[1]=6;//A(3,2) num[2]=6;//A(3,3) for(int i=3; i [网易t1] 有两个分别拥有血量a、b的怪兽。有两个技能 1.其中一个怪兽血量减去x 2.两个怪兽血量都减去y 问：最少需要多少次技能。 输入：a,b,x,y 输出： 次数 1.遍历暴力 int a, b, x, y; cin >> a >> b >> x >> y; int mm = max(a, b); int ans = INT_MAX; for(int i = 0; i 2.贪心 if(a 约瑟夫环问题 详情见 基本算法的递归部分。 暴力 vector a; int n, k; cin >> n >> k; for(int i = 1; i > x; int m = a.size(); x = x % m; id = (id + x) % m; printf(\"%d \", a[id]); a.erase(a.begin() + id); } 周赛T2:向数组中追加 K 个整数 给你一个整数数组 nums 和一个整数 k 。请你向 nums 中追加 k 个 未 出现在 nums 中的、互不相同 的 正 整数，并使结果数组的元素和 最小 。 返回追加到 nums 中的 k 个整数之和。 示例 1： 输入：nums = [1,4,25,10,25], k = 2 输出：5 解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 2 和 3 。 nums 最终元素和为 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70 ，这是所有情况中的最小值。 所以追加到数组中的两个整数之和是 2 + 3 = 5 ，所以返回 5 。 示例 2： 输入：nums = [5,6], k = 6 输出：25 解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 1 、2 、3 、4 、7 和 8 。 nums 最终元素和为 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36 ，这是所有情况中的最小值。 所以追加到数组中的两个整数之和是 1 + 2 + 3 + 4 + 7 + 8 = 25 ，所以返回 25 。 解：思维 + 贪心 我们先选择(1 到 k)一共k个数的和作为答案 但(1 到 k) 中的数可能在nums里面存在 那我们就这个重复的数加起来， 让后面多的一个坑即 k + 1 最后利用高斯求和公式把1 ~ k 的数用 O(1)的时间加起来 再减去重复的 主要开销来源于排序 所以复杂度取O(nlogn) 去重 nums里面重复的元素可以剔除，这样并不会影响答案 更新k 因为原k已经变为k+1,如果存在k+1,则k+1仍需要往后推。故用变化后的k值进行计算sum。 class Solution { public: long long minimalKSum(vector& nums, int k) { // 排序为了去重 也方面k后移 sort(nums.begin(), nums.end()); int n = unique(nums.begin(), nums.end()) - nums.begin(); // 所谓的去重只是把多余的数移到了最后面并没有删除 long long d = 0; for(int i = 0; i class Solution: def minimalKSum(self, nums: List[int], k: int) -> int: nums.sort() # 排序 【方便后续判断和去重】 # 贪心地认为追加的k个整数为[1, k]，先直接求和 ans = k*(k+1)//2 # 判断[1, k]与nums中的元素存在重复的情况，并对追加元素的最后一位（即追加的最大元素）做调整 last = k # last记录追加的最后一个元素，暂时为k pre = -1 # 上一个nums中的元素 【去重】 for num in nums: # nums已有序，每次遍历得到当前最小值 if num == pre: # 遇到多个重复的num，只调整一次last即可 continue if num last（num为遍历到的最小值） return ans # 则nums的后续元素均大于追加元素，无需再调整 return ans 原地操作 [旋转矩阵] 旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 旋转 class Solution { //妙啊 public: void rotate(vector>& matrix) { int n = matrix.size(); for(int i=0; i 两次翻转 1.水平翻转 2.主对角线翻转 class Solution { public: void rotate(vector>& matrix) { int n = matrix.size(); // 水平翻转 for (int i = 0; i 螺旋矩阵 1.输出螺旋线 螺旋矩阵 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 class Solution { public: vector spiralOrder(vector>& matrix) { vector ans; if(matrix.empty()) return ans; //若数组为空，直接返回答案 int u = 0; //赋值上下左右边界 int d = matrix.size() - 1; int l = 0; int r = matrix[0].size() - 1; while(true) { for(int i = l; i d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同 for(int i = u; i = l; --i) ans.push_back(matrix[d][i]); //向左 if(-- d = u; --i) ans.push_back(matrix[i][l]); //向上 if(++ l > r) break; //重新设定左边界 } return ans; } }; 2.填充螺旋线 螺旋矩阵 II 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 class Solution { public: vector> generateMatrix(int n) { vector> res(n, vector(n)); int i = 1, left = 0, up = 0, right = n - 1, down = n - 1; while (i = left && i = up && i 3.位置与值映射 乐团站位 某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。 为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，...，9 循环重复排列。例如当 num = 5 时，站位如图所示 请返回位于场地坐标 [Xpos,Ypos] 的成员所持乐器编号。 示例 1： 输入：num = 3, Xpos = 0, Ypos = 2 输出：3 | 1 | 2 | 3 | |---|---|---| |8 | 9 | 4 | |7 | 6 | 5 | 1 0 解： 思路： 1.获取所求点在第几层（此处根据所求点的位置，层数k可能会多算一层） 2.前第0，1...k层的数量和 与 所求点相对第k层左上角元素(第k层的入口元素)的相对路径做+或-运算，求得所求点的绝对路径（从起始点到所求点经过的长度） class Solution { public: int orchestraLayout(int num, int xPos, int yPos) { long long x=xPos,y=yPos,n=num; if (x 最值搭配 最大值、次大...组合搭配问题 记录最大、次大、第三大..流程 int d1,d2,d3; // 先赋予最小的可能值,分别为最大次大和第三大。 if(val >= d1){ d3 = d2; d2 = d1; d1 = val; }else if(val >= d2){ d3 = d2; d2 = val; }else if(val > d3){ d3 = val; } 节点序列的最大得分 给你一个 n 个节点的 无向图 ，节点编号为 0 到 n - 1 。 给你一个下标从 0 开始的整数数组 scores ，其中 scores[i] 是第 i 个节点的分数。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] ，表示节点 ai 和 bi 之间有一条 无向 边。 一个合法的节点序列如果满足以下条件，我们称它是 合法的 ： 序列中每 相邻 节点之间有边相连。 序列中没有节点出现超过一次。 节点序列的分数定义为序列中节点分数之 和 。 请你返回一个长度为 4 的合法节点序列的最大分数。如果不存在这样的序列，请你返回 -1 。 思路： 预处理+枚举中间边 搭配细节 对组合进行遍历搭配，只对符合条件的进行处理。 而不是单独看和x搭配最大的是不是y，不是的话再选次大。 而y搭配的最大是不是x，不是的话再选次大。 两者次大也相同，再选各自更大的第三大。。。 上述比较过于繁琐，直接遍历即可。 class Solution { public: int maximumScore(vector &scores, vector> &edges) { int n = scores.size(); vector>> g(n); for (auto &e : edges) { int x = e[0], y = e[1]; g[x].emplace_back(-scores[y], y); // 存储负值 g[y].emplace_back(-scores[x], x); } for (auto &vs : g) if (vs.size() > 3) { nth_element(vs.begin(), vs.begin() + 3, vs.end()); vs.resize(3); } int ans = -1; for (auto &e : edges) { int x = e[0], y = e[1]; for (auto &[score_a, a] : g[x]) for (auto &[score_b, b] : g[y]) if (a != y && b != x && a != b) ans = max(ans, -score_a + scores[x] + scores[y] - score_b); } return ans; } }; 数学 计算数组乘积中尾随零的数量 Input : a[] = {100, 20, 40, 25, 4} Output : 6 Product is 100 * 20 * 40 * 25 * 4 which is 8000000 and has 6 trailing 0s. Input : a[] = {10, 100, 20, 30, 25, 4, 43, 25, 50, 90, 12, 80} Output : 13 一个简单的解决方案是简单地乘以并计算乘积中的尾随0。此解决方案可能会导致整数溢出。更好的解决方案基于以下事实：零是由2和5的组合形成的。因此，零的数量将取决于可以形成的2和5的对数。 例如：8352317254*11 2^3 * 3^1 * 5^1 * 23^1 * 17^1 * 5^2 * 2^2 * 11^1 在此示例中，有5个2和3个5。因此，我们将只能形成 3对（2 * 5）。因此，乘积中将为3个零。 // CPP program for count total zero in product of array #include using namespace std; // Returns count of zeros in product of array int countZeros(int a[], int n) { int count2 = 0, count5 = 0; for (int i = 0; i 应用： 转角路径的乘积中最多能有几个尾随零 解法： 枚举 乘积尾随零的数量是所有乘数中因子 22 数量之和与因子 55 数量之和中的较小值。 做乘法的过程中，尾随零的数量只会增加不会减少，因此我们应该让尽量多的数参与乘积运算。也就是说最优路径一定是从某个边界出发，拐个弯，再走到另一个边界，不会中途不走了或者不拐弯（这样参与运算的数不是尽量多的）。 因此先用前缀和维护每一行和每一列因子 22 与因子 55 的数量，再枚举拐点计算答案即可。 class Solution { public: int maxTrailingZeros(vector>& grid) { int n = grid.size(), m = grid[0].size(); vector> f2(n + 1), g2(n + 1), f5(n + 1), g5(n + 1); for (int i = 0; i (m + 1); for (int i = 1; i 懒标记 涉及区间修改的可以进行懒标记，如运用在线段树中的懒标记。 设计位集 位集 Bitset 是一种能以紧凑形式存储位的数据结构。 请你实现 Bitset 类。 Bitset(int size) 用 size 个位初始化 Bitset ，所有位都是 0 。 void fix(int idx) 将下标为 idx 的位上的值更新为 1 。如果值已经是 1 ，则不会发生任何改变。 void unfix(int idx) 将下标为 idx 的位上的值更新为 0 。如果值已经是 0 ，则不会发生任何改变。 void flip() 翻转 Bitset 中每一位上的值。换句话说，所有值为 0 的位将会变成 1 ，反之亦然。 boolean all() 检查 Bitset 中 每一位 的值是否都是 1 。如果满足此条件，返回 true ；否则，返回 false 。 boolean one() 检查 Bitset 中 是否 至少一位 的值是 1 。如果满足此条件，返回 true ；否则，返回 false 。 int count() 返回 Bitset 中值为 1 的位的 总数 。 String toString() 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 i 个下标处的字符应该与 Bitset 中的第 i 位一致。 示例： 输入 [\"Bitset\", \"fix\", \"fix\", \"flip\", \"all\", \"unfix\", \"flip\", \"one\", \"unfix\", \"count\", \"toString\"] [[5], [3], [1], [], [], [0], [], [], [0], [], []] 输出 [null, null, null, null, false, null, null, true, null, 2, \"01010\"] 解释 Bitset bs = new Bitset(5); // bitset = \"00000\". bs.fix(3); // 将 idx = 3 处的值更新为 1 ，此时 bitset = \"00010\" 。 bs.fix(1); // 将 idx = 1 处的值更新为 1 ，此时 bitset = \"01010\" 。 bs.flip(); // 翻转每一位上的值，此时 bitset = \"10101\" 。 bs.all(); // 返回 False ，bitset 中的值不全为 1 。 bs.unfix(0); // 将 idx = 0 处的值更新为 0 ，此时 bitset = \"00101\" 。 bs.flip(); // 翻转每一位上的值，此时 bitset = \"11010\" 。 bs.one(); // 返回 True ，至少存在一位的值为 1 。 bs.unfix(0); // 将 idx = 0 处的值更新为 0 ，此时 bitset = \"01010\" 。 bs.count(); // 返回 2 ，当前有 2 位的值为 1 。 bs.toString(); // 返回 \"01010\" ，即 bitset 的当前组成情况。 提示： 1 class Bitset { public: bitset b; int n, c0, c1, t; Bitset(int size) { n = size; c0 = n; } void fix(int idx) { if (!(b[idx] ^ t)) c0--, c1++; b[idx] = 1 ^ t; } void unfix(int idx) { if (b[idx] ^ t) c1--, c0++; b[idx] = 0 ^ t; } void flip() { t ^= 1; swap(c0, c1); } bool all() { return c1 == n; } bool one() { return c1; } int count() { return c1; } string toString() { string s = \"\"; for (int i = 0; i 基础 c++的bitset: bitset的基本用法 c++bitset用法详解（超简单）——蒟蒻函数 一、概念 bitset可以说是一个多位二进制数，每八位占用一个字节，因为支持基本的位运算，所以可用于状态压缩，n位bitset执行一次位运算的时间复杂度可视为n/32. 二、基本操作 1.定义： bitset s; 表示一个n位的二进制数，<>中填写位数； 也可用一个整数或 01串赋值 string进行初始化。 2.位运算操作符： ~s: 返回对s每一位取反后的结果； &，|，^：返回对两个位数相同的bitset执行按位与、或、异或运算的结果； >:返回把一个bitset左移，右移若干位的结果.（补零）； ==，！=：比较两个位数相同的bitset代表的二进制数是否相等； 3.[ ]操作符： s[k] :表示s的第k位，即可取值也可赋值，编号从0开始； 4.count: s.count() 返回二进制串中有多少个1； 5.any/none 若s所有位都为0，则s.any()返回false，s.none()返回true； 若s至少有一位为1，则s.any()返回true，s.none()返回false； 6.set/rest/flip s.set()把s所有位变为1； s.set(k,v)把s的第k位改为v,即s[k]=v； s.reset()把s的所有位变为0. s.reset(k)把s的第k位改为0,即s[k]=0； s.flip()把s所有位取反.即s=~s； s.flip(k)把s的第k位取反，即s[k]^=1； 具体使用： 1.定义 bitseta1;//长度为4，默认以0填充 bitseta2;//长度为8，将12以二进制保存，前面用0补充 string s = \"100101\"; bitseta3(s);//长度为10，前面用０补充 //实验检测，char在普通环境不能直接赋值给bitset //要开c++11，针不戳 char s2[] = \"10101\"; bitseta4(s2);//长度为13，前面用０补充 //所以这玩意noip上不能用…… coutbitset1(12);//12的二进制为1100（长度为４），但bitset1的size=2，只取后面部分，即00 string s=\"100101\"; bitset bitset2(s);//s的size=6，而bitset的size=4，只取前面部分，即1001 //char s2[]=\"11101\"; //bitset bitset3(s2);//与bitset2同理，只取前面部分，即1110 cout 2.位运算操作符： bitset foo (string(\"1001\"));//这种赋值方式就可以直接用，没有限制 bitset bar (string(\"0011\")); cout >=1) >1) 3.单一元素访问和修改 bitseta1(\"1011\");//这个赋值方法只能在c++11里用，noip八行 //可以用上面位运算时的方法 bitseta1(string(\"1011\")); cout 4.其他函数 bitsetfoo(string(\"10011011\")); cout 二叉搜索树染色见线段树。更简单方法是逆向思考。 排序 [二维偏序] 统计包含每个点的矩形数目 给你一个二维整数数组 rectangles ，其中 rectangles[i] = [li, hi] 表示第 i 个矩形长为 li 高为 hi 。给你一个二维整数数组 points ，其中 points[j] = [xj, yj] 是坐标为 (xj, yj) 的一个点。 第 i 个矩形的 左下角 在 (0, 0) 处，右上角 在 (li, hi) 。 请你返回一个整数数组 count ，长度为 points.length，其中 count[j]是 包含 第 j 个点的矩形数目。 如果 0 解： 对矩形区域纵坐标降序、对查询点纵坐标降序 利用idxsort技巧保存每个查询的原始位置。 #include // std::iota template vector idxsort(const vector &v) { vector idx(v.size()); iota(idx.begin(), idx.end(),1); sort(idx.begin(), idx.end(), [&v](int i1, int i2) {return v[i1] code: class Solution { public: vector countRectangles(vector> &rectangles, vector> &points) { sort(rectangles.begin(), rectangles.end(), [](auto &a, auto &b) { return a[1] > b[1]; }); int n = points.size(); vector ids(n); iota(ids.begin(), ids.end(), 0); sort(ids.begin(), ids.end(), [&](int i, int j) { return points[i][1] > points[j][1]; }); vector ans(n), xs; int i = 0; for (int id : ids) { int start = i; while (i = points[id][1]) xs.push_back(rectangles[i++][0]); if (start class Solution: def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]: rectangles.sort(key=lambda r: -r[1]) n = len(points) ans = [0] * n i, xs = 0, [] for (x, y), id in sorted(zip(points, range(n)), key=lambda x: -x[0][1]): start = i while i = y: xs.append(rectangles[i][0]) i += 1 if start 直接桶排思想 按行统计 + 二分查找 class Solution { public: vector countRectangles(vector> &rectangles, vector> &points) { vector xs[101]; for (auto &r: rectangles) xs[r[1]].push_back(r[0]); for (auto &x: xs) sort(x.begin(), x.end()); int n = points.size(); vector ans(n); for (int i = 0; i class Solution: def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]: max_y = max(y for _, y in rectangles) xs = [[] for _ in range(max_y + 1)] for x, y in rectangles: xs[y].append(x) for x in xs: x.sort() return [sum(len(x) - bisect_left(x, px) for x in xs[py:]) for px, py in points] 二维偏序问题+树状数组 经典 二维偏序问题，可以用树状数组、分治等方法解决 class Solution { typedef pair PII; typedef pair PIII; const int INF = 1e9; int n; vector t; void add(int x) { for (; x countRectangles(vector>& rectangles, vector>& points) { vector vec; // PIII.second 可作为 两类的标志 和 查询的索引 for (auto &rec : rectangles) { vec.push_back(PIII(PII(rec[0], rec[1]), INF)); n = max(n, rec[1]); } for (int i = 0; i (n + 1); sort(vec.begin(), vec.end()); vector ans(points.size()); for (int i = (int) vec.size() - 1; i >= 0; i--) if (vec[i].second == INF) add(vec[i].first.second); // 已存的都是比当前查询x大的, 只需要计算有 多少y比当前大于等于的。 else ans[vec[i].second] = ask(n) - ask(vec[i].first.second - 1); return ans; } }; [面试题]用最少的比较次数找出一个数组中的最大值和次大值 题目描述 如题，且无重复元素 思路 用分治法，把数组分成2组，2组内分别用两两比较淘汰的方法找出各自的最大值（一共n-1次比较）， 最后出来的2个最大值比较，较大的那个是最大值，第二大的值在较小的那个和所有跟最大值比较过的元素（一共log_2 n -1个）之间产生。只需用较小的那个 和 log_2 n -1个与最大值比较过的元素分别比较一次 (这里又需要log_2 n-1 次比较) 就行了。所以最终的比较次数为（logn+n-2） stl常用 vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue, greater> q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset s; ~, &, |, ^ >>, 给出一个长度为n的01串，请找两个不同的区间[s1,e1],[s2,e2]，满足区间内的0和1的数量相同。求区间长度的最长值。 01串长度为n，3 输入 11011 输出 4 思路：把0 换成-1 求前缀和 因为有0，直接做前缀的话 。对于前缀数组中两个 换成-1后， 一个01字符串，求出现0、1出现次数相等的最长子串 题目描述： 已知一个长度为N的字符串，只由0和1组成， 求一个最长的子串，要求该子串出和1出现的次数相等。 要求算法时间复杂度尽可能的低。 比如： 1000010111000001，加粗的部分有4个0、4个1 解： 一种巧妙的解法：定义一个数据B[N]， B[i]表示从A[0...i]中 num_of_0 - num_of_1，0的个数与1的个数的差 那么如果A[i] ~ A[j]是符合条件的子串，一定有 B[i] == B[j]，因为中间的部分0、1个数相等，相减等于0。 只需要扫一遍A[N]就能把B[N]构造出来了。 这样问题就转换成了求 距离最远的一对数，使得B[i] == B[j]，因为B[i]的范围一定是[-N,N]，-N到N的范围都存起来，这样每扫到B[i]，查数就行了。 其实代码真的非常简单，一个循环就搞定了，这就是算法和思考的乐趣:) int A[N],B[N]; int num[2*N + 1]; int count[2] = {0,0}, maxlen = 0, currlen = 0; memset(C, 2*N, -1); for(int i = 0; i maxlen) maxlen = currlen; } 常考知识点 如果要求一个线性表既能较快地查找,又能适应动态变化的要求,可以采用(A )查找方法。 A. 分块 B. 顺序 C. 二分 D. 散列 板子 mbcore 或core 保持同步更新 待更新 #define SZ(x) ((int)((x).size())) int floor(int a, int b){ return (a - 1) / b + 1; // (a + b - 1) / b; } 下面已更新 typedef long long LL; typedef unsigned long long ULL; typedef double D; #define fi first #define se second #define ins insert #define pb push_back #define mpr make_pair #define ALL(v) (v).begin(), (v).end() #define SORT(v) sort(ALL(v)) #define SORTR(v) SORT(v), reverse(ALL(v)) #define LB(v, x) lower_bound(ALL(v), x) - (v).begin() #define UB(v, x) upper_bound(ALL(v), x) - (v).begin() #define MST(v, x) memset((v), x, sizeof (v)) using PII = pair; using PIII = pair; #define lowbit(x) ((x)&(-(x))) template void chkMax(T& x, T y) { if (y > x) x = y; } template void chkMin(T& x, T y) { if (y VI; // eg. VI dp(n + 1); typedef std::vector> VII; // eg. VII dp(m + 1, VI(n + 1)); #define fir(i, a, b) for (int i = a;i = (int)b;i --) void __print(int x) { cout void __print(const pair& x) { cout void __print(const T& x) { int f = 0; cout void printn(const T& x, int l, int r) { for (int i = l; i void printnn(const T& x, int l, int r) { for (int i = l; i void _print(T t, V... v) { __print(t); if (sizeof...(v)) cout ostream& operator & a) { out ostream& operator & a) { out = mod) x -= mod; } const double eps = 1e-6; int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; const int N = 100010, M = N * 2; 简洁版 mbacm #include #include #include #include #include #include using namespace std; const int N = 100010; int main() { return 0; } 标准版 #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include // #include using namespace std; typedef long long LL; typedef unsigned long long ULL; typedef double D; #define fi first #define se second #define ins insert #define pb push_back #define all(v) (v).begin(), (v).end() #define mpr make_pair using PII = pair; using PIII = pair; #define fir(i,a,b) for (int i=a;i void chkMax(T& x, T y) { if (y > x) x = y; } template void chkMin(T& x, T y) { if (y 调试版 // #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include using namespace std; typedef long long LL; typedef unsigned long long ULL; typedef double D; #define fi first #define se second #define ins insert #define pb push_back #define all(v) (v).begin(), (v).end() #define mpr make_pair using PII = pair; using PIII = pair; #define lowbit(x) ((x)&(-(x))) template void chkMax(T& x, T y) { if (y > x) x = y; } template void chkMin(T& x, T y) { if (y vi; typedef std::vector> vii; #define fir(i, a, b) for (int i = a;i = b;i --) #define read(x) scanf(\"%d\", &x) #define read2(x, y) scanf(\"%d %d\", &x, &y) #define read3(x, y, z) scanf(\"%d %d %d\", &x, &y, &z) #define read4(x, y, z, w) scanf(\"%d %d %d %d\", &x, &y, &z, &w) #define readvn(x, n) vi x(n + 1); fir(i, 1, n) scanf(\"%d\", &x[i]) #define readn(x, a, b) fir(i, a, b) scanf(\"%d\", &x[i]) #define readnn(x, a, b, aa, bb) fir(i, a, b) fir(j, aa, bb) scanf(\"%d\", &x[i][j]) void __print(int x) { cout void __print(const pair& x) { cout void __print(const T& x) { int f = 0; cout void printn(const T& x, int l, int r) { for (int i = l; i void _print(T t, V... v) { __print(t); if (sizeof...(v)) cout ostream& operator & a) { out ostream& operator & a) { out 输入输出常用 // 输入 和 循环 typedef std::vector vi; typedef std::vector> vii; #define fir(i, a, b) for (int i = a;i = b;i --) #define read(x) scanf(\"%d\", &x) #define read2(x, y) scanf(\"%d %d\", &x, &y) #define read3(x, y, z) scanf(\"%d %d %d\", &x, &y, &z) #define read4(x, y, z, w) scanf(\"%d %d %d %d\", &x, &y, &z, &w) #define readvn(x, n) vi x(n + 1); fir(i, 1, n) scanf(\"%d\", &x[i]) #define readn(x, a, b) fir(i, a, b) scanf(\"%d\", &x[i]) #define readnn(x, a, b, aa, bb) fir(i, a, b) fir(j, aa, bb) scanf(\"%d\", &x[i][j]) // debug 精简版 void __print(int x) { cout void __print(const pair& x) { cout void __print(const T& x) { int f = 0; cout void printn(const T& x, int l, int r) { for (int i = l; i void _print(T t, V... v) { __print(t); if (sizeof...(v)) cout void __print(const pair& x) { cout void __print(const T& x) { int f = 0; cout void printn(const T& x, int l, int r) { for (int i = l; i void _print(T t, V... v) { __print(t); if (sizeof...(v)) cout ostream& operator & a) { out ostream& operator & a) { out 附录 wa的一声哭了、听取wa声一片、ac，ak、做个ac梦... AC Accepted 通过 WA Wrong Answer 答案错误 TLE Time Limit Exceed 超时 OLE Output Limit Exceed 超过输出限制 MLE Memory Limit Exceed 超内存 RE Runtime Error 运行时错误 PE Presentation Error 格式错误 CE Compile Error 无法编译 具体来说： 信息学竞赛中AC、WA、RE、CE、TLE、MLE、PE、OLE： ‌AC Accepted 答案正确/通过 ‌WA Wrong Answer 答案错误 RE Runtime Error 运行时错误 这表明你的程序在运行过程中因为出锅而崩溃了，通常可能是访问非法内存等问题，出现这个提示但你还能过样例的话，大概率是数组没开够，仔细检查一下。 CE Complie Error 编译错误 这表明你的程序没有通过编译。如果在本地编译可以通过的话，检查一下提交语言是不是选对了或是有没有引用一些不该引用的东西 ‌TLE Time Limit Exceed 超出时间限制/超时 这表明你的程序运行所用的时间超过了测试点的规定时间。出现这个提示时一般表明你的算法的时间复杂度不够优秀，需要优化；但也有可能程序深入死循环 ‌MLE Memory Limit Exceed 超出内存限制 这表明你的程序所调用的内存大小超出了测试点的内存限制，一般表明你的算法的空间复杂度不是很优秀，比如像NOIP铺地毯中什么百万级二维数组的失智做法什么的，好好优化一下~ ‌PE Presentation Error 格式错误 表示你的程序出现了多余的空格或者是换行，好好看看输出格式 ‌OLE Output Limit Exceed 输出超出限制/输出超限 表示你的程序出现了 大 量 的输出，一般还是程序在输出过程中深陷死循环，好好检查一下代码逻辑~ Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-11-20 15:09:47 "},"01_数据结构与算法笔记/01_学习笔记/00_基本算法.html":{"url":"01_数据结构与算法笔记/01_学习笔记/00_基本算法.html","title":"1.0 基本算法","keywords":"","body":"1 位运算 1.1 基本使用 操作 运算 取出整数 n 在二进制表示下的第 k 位格1 (n >> k) & 1 取出整数 n 在二进制表示下的第 0 ~ k-1 位 (后 k 位)格3 n & ((1 把整数 n 在二进制表示下的第 k 位取反 n ^ (1 对整数 n 在二进制表示下的第 k 位赋值 1 n I (1 对整数 n 在二进制表示下的第 k 位赋值 0 n & (~(1 1.2 应用 位运算一般有三种作用： 高效地进行某些运算，代替其它低效的方式。 表示集合（常用于 状压 DP 与子集枚举） 题目本来就要求进行位运算。 二进制子集枚举 int s = k; do { s = (s - 1) & k; } while(s != k); while(..)中 -1（int) 的二进制表示111...111，-1 & mask = mask,则此时结束。 比如k = 10101的二进制子集有: 10101 10100 10001 10000 00101 00100 00001 00000 或者for // 遍历 u 的非空子集 for (int s = k; s; s = (s - 1) & k) { // s 是 u 的一个非空子集 } 时间复杂度：O(2^popcount(u)) 而遍历一个集合所有子集的子集，时间复杂度为 O(3n) （每个元素只有三中状态） 计算二进制中1的个数 int x, res = 0 ; while(x) x-=lowbit(x),res++; 或者 int x, res = 0 ; while(x) x-= x&(-x),res++; 其中-x = ~x + 1 (注意：~x将所有位取反 后 + 1， 类似于负数的存储。 而 i ^ (1 是将i的第j位取反) 或者使用__builtin_popcount(int x) 注意区分以上两种问题 二进制子集枚举 是 其中1的排列组合，组合种类数 为 m = 2 ^ n, n 为二进制中 1 的个数 计算二进制中 1 的个数，用x -= lowbit(x) 算法可实现一步去掉一个最低位的1 (其中lowbit(x) = x & - x, 用来 求最后一个1及后面的0组成的数) 需要注意的是，用位运算代替其它运算方式（即第一种应用）在很多时候并不能带来太大的优化，反而会使代码变得复杂，使用时需要斟酌。（但像“乘 2 的非负整数次幂n > m;”就最好使用位运算，因为此时使用位运算可以优化复杂度。） 判断： 是不是2的非负整数次幂 二进制表示中只有一位 1 bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; } 是不是4的非负整数次幂 异或 成对变换 ⊕ 即 ^ n 为奇数时，n⊕1=n−1 n 为偶数时，n⊕1=n+1 因此，“0与1”、“2与3”、“4与5”、... 关于 ⊕ 是成对变换的 常用于 图论 中，无向图 用 链式前向星 存图时，找 反向边 找缺失数 找出现一次的数 性质： x \\oplus x = 0 和 x \\oplus 0 = x E-LC-丢失的数字 // 从给定一个包含 [0, n] 中 n 个数的数组 nums // 找出 [0, n] 这个范围内没有出现在数组中的那个数。 // 1. 排序后位置对应 // 2. 哈希 // 要求 时间O(n),空间O(1) // 3. 求和 int missingNumber(vector& nums) { int n = nums.size(); long sum = n*(n+1)/2; for(auto a:nums){ sum-=a; } return sum; } // 3. 异或 int missingNumber(vector& nums) { int res = 0; int n = nums.size(); for (int i = 0; i E-LC-只出现一次的数字 // 给定一个非空整数数组，除了某个元素只出现一次以外 // 其余每个元素均出现两次。找出那个只出现了一次的元素。 // demo // 输入: [4,1,2,1,2] // 输出: 4 int singleNumber(vector& nums) { int res=0; for(const int& n:nums) res^=n; return res; } M-LC只出现一次的数字 II 重要思想： 所有的数都看成0/1串，计算每一位上0/1的个数 困难级解法 官方解答-含数字电路法 // 给你一个整数数组 nums ，除某个元素仅出现 一次 外， // 其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。 // demo // 输入：nums = [0,1,0,1,0,1,99] // 输出：99 // 1. 按位计算 O(nlgC)，C为元素数据长度即位数32 int singleNumber(vector& nums) { int ans = 0; for (int i = 0; i > i) & 1); } if (total % 3) { ans |= (1 & nums) { //这一题看榜一大佬的，然后自己写了一遍，推荐大家去看榜一 //首先，我们要把所有的数据都看成0/1串，既然要求我们剔除重复三次者,我们想：重复三次的数字，其每一位都会重复三次，如果能够将每一位都看成一个新整数，那么将每一位都加起来之后，通过%3就可以去除重复三次的数字，这也是这种题目的本质。 之后如果要剔除所有重复n次的数据，只需要mod n 即可。 //但是，我们如果把每一位(只有一个bit)看成能累加的整数时，需要的额外空间就很多了 //但是转念一想，我们只是要求去mod3，那么每一位只需要两个bit就够用了 //所以榜一大佬用了两个整数 two 和one，two和one的相同位组合在一起可以在每一位都表示0 1 2 3.... //比如 //two:0 1 1 0 //one:0 0 1 0 //含义就是00 10 11 00 //即第一位出现的次数是3的整数倍，第二位出现的次数模三余二...... //那么就很简单了，研究一下位操作 ^是异或 ~是取反 &是且,与0异或不变，与1异或相当于取反，与1 & 不变， //one 如何变化？ //n表示本轮遇到的数据 //if two = 0则 one等于0 or 1 无论是哪个，如果遇到了n=1，则one要变化，否则不变 //if two = 1则 one只可能为0， 10 表示 2 ，在加1就是3的整数倍，需要mod3 之后two = 0 one = 0 此时one还是0， 相当于此时one 一定不变 //所以one等于0 or 1 无论是哪个，如果遇到了n=1，则one要变化，否则不变 即 one = one ^ n // two==0时应不改变上式，否则结果应回归one则 one ^ n &~two // if one = 0 则 two可以为0或者 1，若n=0，two 不变，若n=1则two 变0 // if one = 1 则 two为0，n=0时肯定不变，n=1时要变，但这里的one是变化之后的one, // 所以n=0时遇到的one和现在是反着的，n=1时two等于，这里榜一大佬画出状态图，发现交换one 和two的位置之后，情况是等价的，所以算式与one的同构 int ones = 0, twos = 0; for(int num : nums){ ones = ones ^ num & ~twos; twos = twos ^ num & ~ones; } return ones; } M-LC只出现一次的数字 III 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。 要求：线性时间复杂度。你能否仅使用常数空间复杂度 // 1.哈希 // 2.异或 O(n) O(1) // 2.1.假设数组 nums 中只出现一次的元素分别是x1,x2。如果把 nums 中的所有元素全部异或起来，得到结果 x，那么一定有：x= x1^x2 // 2.2 如何还原回x1和x2。必定存在至少一位不同 取不同的最低位，即x中最低位的1所在的位 // 2.3 如此 可把数组元素分为两类 且x1和x2分别处于一个类中。在各自类中异或，即可找到x1和x2原始值 vector singleNumber(vector& nums) { int xorsum = 0; for (int num: nums) { xorsum ^= num; } // 防止溢出 //INT_MIN = -2147483648,存储为1000 0000 0000 0000,即0x8000 0000 只有一个符号位。 // 此时INT_MIN的-xorsum = 2147483648不能用int表示了 // 所以需要判断 或者用long 存储xorsum int lsb = (xorsum == INT_MIN ? xorsum : xorsum & (-xorsum)); int type1 = 0, type2 = 0; for (int num: nums) { if (num & lsb) { type1 ^= num; } else { type2 ^= num; } } return {type1, type2}; } 快速幂 快速幂 计算x^n mod \\ m // 非递归实现 typedef long long LL; const int p = *; LL binpow(LL a, LL b, LL p) { LL res = 1; while (b > 0) { if (b & 1) res = res * a % p ; a = a * a % p; b >>= 1; } return res; } 矩阵快速幂 Fibonacci性质 斐波那契数 斐波那契数列： 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给定 n ，请计算 F(n) 。 解： 1.递归 2.动态规划 + 滚动数组 class Solution { public: int fib(int n) { int MOD = 1000000007; if (n 2.公式 int fib(int n) { double sqrt5 = sqrt(5); double fibN = pow((1 + sqrt5) / 2, n) - pow((1 - sqrt5) / 2, n); return round(fibN / sqrt5); } 3.矩阵快速幂 class Solution { static const int mod=1e9+7; public: int fib(int n) { if (n > q\\{\\{1,1},{1,0}}; vector> res = qPow(q,n-1); return res[0][0]; } vector> qPow(vector>& a,int n){ vector> ret=\\{\\{1,0},{0,1}}; // 单位矩阵 相当与 1 while(n>0){ if(n&1){ ret=multiply(ret,a); // 相当于 ret * a } n>>=1; a = multiply(a,a); // 相当于 a * a } return ret; } vector> multiply(vector>&a,vector>& b){ vector> res\\{\\{0,0},{0,0}}; for(int i=0;i 拓展： 快速幂 为 用乘法实现幂， 而大数乘法也可以用 加法(O(log(n))) 实现 乘法（O(1)),复杂度提高了，但可避免溢出等 a b = a + a + a + ... + a 分乘 a + 2 a + 4 a + 对于 b = （11010)_2 a b = 02^0 a + 1 2^1a + 02^2a + 12^3a + 12^4a = 1 2^1a + 12^3a + 12^4a 如求 a 乘 b 对 p 取模的值。 a * b mod p 1≤a,b,p≤10^18 typedef long long LL; LL qadd(LL a, LL b, LL p) { LL res = 0; // 注意和 快速幂 区别 while (b) { if (b & 1) res = (res + a) % p; // + a = (a + a) % p; // + b >>= 1; } return res; } 最短哈密顿路径 解： int f[1 > j & 1) for (int k = 0; k > k & 1) f[i][j] = min(f[i][j], f[i ^ 1 起床困难综合症 参考： 彩铅dalao：位运算 2 递推与递归 递归与递推区别： 相对于递归算法,递推算法免除了数据进出栈的过程，也就是说,不需要函数不断的向边界值靠拢,而直接从边界出发,直到求出函数值。 概念 递推 递推算法是一种用若干步可重复运算来描述复杂问题的方法。递推是序列计算中的一种常用算法。通常是通过计算机前面的一些项来得出序列中的指定象的值。 数学推导 发现规律 重复简单运算 递归 从已知问题的结果出发，用迭代表达式逐步推算出问题的开始的条件，即顺推法的逆过程，称为递归。 定义 在一个函数的定义中又直接或间接地调用本身。 递归思想： 把规模大的、较难解决的问题变成规模较小的、易解决的同一问题。规模较小的问题又变成规模更小的问题，并且小到一定程度可以直接得出它的解，从而得到原来问题的解。 优点： 符合人的思维方式，递归程序结构清晰，可读性，容易理解 缺点： 通过调用函数实现，当递归层数过多时，程序的效率低。例如求Fibonacii数列的第N (N比较大时) 项 应用场合： 1、数据的定义形式是递归的，例如求Fibonacii数列的第n项 。 2、数据之间的逻辑关系（即数据结构）是递归的，如树、图等的定义和操作。 3、某些问题虽然没有明显的递归关系或结构，但问题的解法是不断重复执行一组操作，只是问题规模由大化小，直至某个原操作（基本操作）就结束。例如：汉诺塔问题。 递归设计的要素： 1、在函数中必须有直接或间接调用自身的语句； 2、在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口（或递归边界）。 编写递归算法时，首先要对问题的以下三个方面进行分析： 1.决定问题规模的参数。需要用递归算法解决的问题，其规模通常都是比较大的，在问题中决定规模大小（或问题复杂程度）的量有哪些？把它们找出来。 2.问题的边界条件及边界值。在什么情况下可以直接得出问题的解？这就是问题的边界条件及边界值。 3.解决问题的通式。把规模大的、较难解决的问题变成规模较小、易解决的同一问题，需要通过哪些步骤或公式来实现？这是解决递归问题的难点。把这些步骤或公式确定下来。 总结 递 推 小 结： 递推是从已知条件开始； 递推必须有明确的通用公式； 递推必须是有限次运算。 递 归 小 结： 递归：未知的推到已知的，再由此返回。 基本思想：将复杂的操作分解为若干重复的简单操作。 递归 M-对称二叉树 给定一个二叉树，检查它是否是镜像对称的。ia 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ // 方法1： 递归 class Solution { public: bool check(TreeNode *p, TreeNode *q) { if (!p && !q) return true; if (!p || !q) return false; return p->val == q->val && check(p->left, q->right) && check(p->right, q->left); } bool isSymmetric(TreeNode* root) { return check(root, root); } }; // 方法2：BFS bfs + 层序遍历 用size维护上一层多上个元素 把这些的全部子节点按顺序获取，若为空需要进行占位，然后每一层遍历后 判断即可。 常见问题 汉诺塔问题 三塔到n塔问题 汉诺塔问题，条件如下： 1、这里有 A、B、C 和 D 四座塔。 2、这里有 n 个圆盘，n 的数量是恒定的。 3、每个圆盘的尺寸都不相同。 4、所有的圆盘在开始时都堆叠在塔 A 上，且圆盘尺寸从塔顶到塔底逐渐增大。 5、我们需要将所有的圆盘都从塔 A 转移到塔 D 上。 6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。 请你求出将所有圆盘从塔 A 移动到塔 D，所需的最小移动次数是多少。 解：先会三塔，再搞四塔。 三柱两盘的情况（刨去初时状态，共移动了3次） 三柱三盘的情况（刨去初时状态，共移动了7次） 综上，我们可以看到，对于n盘3塔问题，移动的最小步数就是，把前n-1个盘子从A柱移到B柱，然后把第n个盘子移到C柱，最后再把前n-1个盘子移动到C柱。可以得出递推式d[n]=d[n−1]∗2+1。 但是本题没有呢么友善，题目要求我们求四塔情况下最小的移动步数，难受死我了，呢就继续画图看看？？ 四塔3盘（除去初始状态，共移动5次） 四塔4盘（除去初始状态，共盘他9次） 综上，可得先把i个盘子在四塔的模式下，移动到一根柱子上（不可以是D柱），然后把n-i个盘子，盘到D柱上。考虑到i可能存在最小值。可得递推式f[i]=min1≤i＜n(2∗f[i]+d[n−i]),f[1]=1 。 更一般的：i盘j柱的最小步数：先把上面的k个移动到某根不是j的柱子上，再把剩下的移动到j，最后把之前的k个移动到j。有递推式： f[i][j] = min(f[k][j] * 2 + f[i - k][j - 1]),则知可以进行状态压缩。 #include #include #include using namespace std; int main() { int n=12; int g[20]; // 3 塔 g[0]=0,g[1]=1; for(int i=2;i 扔鸡蛋实验 dmy面试：经典算法面试题：100层楼扔2个鸡蛋 有一栋100层的楼，和2个坚硬的鸡蛋，从楼上扔下鸡蛋，鸡蛋会在大于某一层刚好开始碎，那最少几次能测出鸡蛋能承受的最大楼层呢？ 如果从第50层扔下鸡蛋没碎，第51层扔下碎了，那鸡蛋能承受的最大楼层就是50。 注意：你手上只有2个鸡蛋，如果扔下碎了，就没法再使用了。 1.若题目只是给足够鸡蛋，问至少需要多少次 或 多少个？ 多少次可以用二分或倍增。多少个... 2.针对该题 ...详情见上述文章。 3 推广：N层楼，M个蛋 为描述方便，设f[i][j]表示i层楼，j个鸡蛋最小要测试的次数。 从第k层扔下 碎，f[i][j]=f[k-1][j-1]+1 不碎，f[i][j]=f[i-k][j]+1 则f[i][j]=min(max(f[k-1][j-1],f[i-k][j])+1),1 约瑟夫问题 引入： 约瑟夫环问题是一个很经典的问题：一个圈共有N个人（N为不确定的数字），第一个人的编号为0或者1（两个都可以，看你的程序如何编写），假设这边我将第一个人的编号设置为1号，那么第二个人的编号就为2号，第三个人的编号就为3号，第N个人的编号就为N号，现在提供一个数字M，第一个人开始从1报数，第二个人报的数就是2，依次类推，报到M这个数字的人出局，紧接着从出局的这个人的下一个人重新开始从1报数，和上面过程类似，报到M的人出局，直到N个人全部出局，请问，这个出局的顺序是什么？ 举一个简单的例子：假设现在N的值为10，代表有10个人，M的值为3，代表报数报到3的人出局，那么出局的顺序就为：3 6 9 2 7 1 8 5 10 4 分析： 如上图所示，圈内矩形格子中的数字代表每个人的编号，从1开始编号到10。圈外半椭圆中的数字代表10个人的出局顺序。 注意：已经出局的人无需报数，报数的都是未出局的人。 从第一个人开始报数，报到3的人出局，因此，第一个出局的人为3号，3号出局之后，要从出局的这个人（3号）的下一个未出局的人（4号）重新开始从1开始报数，所以4号从1开始继续报数，那么，第二个出局的人就是6号，6号出局之后，要从出局的这个人（6号）的下一个未出局的人（7号）重新开始从1开始报数，所以7号从1开始继续报数，那么，第三个出局的人就是9号，9号出局之后，要从出局的这个人（9号）的下一个未出局的人（10号）重新开始从1开始报数，所以10号从1开始继续报数，那么第四个出局的人就是2号（10号报1，1号报2，2号报3，2号出局），2号出局之后，要从出局的这个人（2号）的下一个未出局的人（4号，这边3号已经出局了，不能报数，所以直接跳到4号）重新开始从1开始报数，那么第五个出局的人就是7号，7号出局之后，要从出局的这个人（7号）的下一个未出局的人（8号）重新开始从1开始报数，那么第六个出局的人就是1号，1号出局之后，要从出局的这个人的下一个未出局的人（4号）重新开始从1开始报数，那么第七个出局的人就是8号，8号出局之后，要从出局的这个人（8号）的下一个未出局的人（10号）重新开始从1 开始报数，那么第八个出局的人就是5号，5号出局之后，要从出局的这个人（5号）的下一个未出局的人（10号）重新开始从1开始报数，那么第九个出局的就是10号，10号出局之后，要从出局的这个人（10号）的下一个未出局的人（4号）重新开始从1开始报数，此时，N个人从只剩下4号还未出局，4号自己从1开始报数，自己数到3，那么它也出局了，4号是第十个出局的人。 求解方式： ⭕ 数组方式 ⭕ 循环链表方式 ⭕ 递归方式 约瑟夫环递推公式： f(1) = 0; //表示最后一轮的胜出者当前编号是0 f(x) = (f(x - 1) + m) % x , 1 f(x) = (f(x - 1) + a[(n - x) % m]) % x, 1 圆圈中最后剩下的数字 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1： 输入: n = 5, m = 3 输出: 3 示例 2： 输入: n = 10, m = 17 输出: 2 递归 ```c++class Solution { int f(int n, int m) { if (n == 1) { return 0; } int x = f(n - 1, m); return (m + x) % n; } public: int lastRemaining(int n, int m) { return f(n, m); } }; - 数学+迭代 ```c++ class Solution { public: int lastRemaining(int n, int m) { int f = 0; // 最后一轮剩下2个人，所以从2开始反推 for (int i = 2; i != n + 1; ++i) { f = (m + f) % i; } return f; } }; 招聘 某公司招聘，有 n 个人入围，HR在黑板上依次写下 m 个正整数 A1,A2,…Am，然后这 n 个人围成一个圈，并按照顺时针顺序为他们编号 0,1,2,…n−1。 录取规则是： 第一轮从 0 号的人开始，取用黑板上的第 1 个数字，也就是 A1。 黑板上的数字按次序循环使用，即如果某轮用了第 k 个，如果 k #include using namespace std; const int N = 1e3 + 10; int a[N]; /* 约瑟夫环递推公式： f(1) = 0; //表示最后一轮的胜出者当前编号是0 f(x) = (f(x - 1) + m) % x , 1 f(x) = (f(x - 1) + a[(n - x) % m]) % x, 1 > T; while(T --){ int n, m; cin >> n >> m; for(int i = 0; i 3 前缀和与差分 要理解前缀和 与 差分的互逆操作 ，否则很难理解由差分数组还原出原数组，尤其是二维。 注意：for $a[i],i=0:n-1$ ， $S[i]$计算时要不要包括$a[i]$ 前缀和 一维： 假设有一个数组：a1，a2，a3，a4，a5，…，an（注意，下标从1开始） 前缀和 Si = a1 + a2 + a3 + … + ai （即前i个数的和） 显然的，前缀和满足 Si = Si-1 + ai ，特殊的，我们可以定义S0 = 0，这样，任何区间[l, r]，我们都可以用 Sr - Sl-1 这样的公式来计算，而不需要对边界进行特殊处理（当l = 1时，求[l, r]的所有数的和，其实就是求 Sr）。 前缀和的最大作用，就是用来求任意一段区间的所有数的和。比如，要求区间[l, r]的全部元素的和。若没有前缀和数组，则我们需要遍历原数组，时间复杂度为O(n)。若有前缀和数组，我们只需要计算 Sr - Sl-1，时间复杂度为O(1)。 因为 Sr = a1 + a2 + a3 + … + al-1 + al + … + ar 而 Sl-1 = a1 + a2 + a3 + … + al-1 S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] Si 表示前i个(包括第i个元素)的和。不管ai的i从0开始还是从1. 如果ai的i从0开始则, for(int i = 0; i 如果ai的i从1开始则, for(int i = 1; i 二维： 假设有如下的矩阵 a11 ，a12，a13，a14，…，a1n a21，a22，a23，a24，…， a2n … … am1，am2，am3，am4，…，amn 前缀和 Sij 表示点 aij 及其左上角区域的所有数的和。 经过简单推导（面积计算），可以得到 Sij = Si-1,j + Si,j-1 + aij - Si-1,j-1 若要计算左上角边界点为[x1, y1]，右下角点为[x2, y2]，这2个点之间部分的子矩阵的和（也是求任意一段区间内所有数的和），经过简单推导，能够得到下面的公式 S = Sx2,y2 - Sx1-1,y2 - Sx2,y1-1 + Sx1-1,y1-1（由于矩阵中是离散的点，所以计算时边界需要减掉1） 即 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 综合 // 由a求S S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + a[i][j] // 由S求区间和 sum[(x1,y1),(x2,y2)] = S[x2][y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1][y1 - 1] 注意体会与差分的关系 差分 差分，是前缀和的逆运算 技巧： 最后数组从i=1开始存 求取差分时，可以利用原数组直接求。 // a为原数组 ，b为差分 // 对于 一维 void insert(int b[],int l,int r,int c) { b[l]+=c; b[r+1]-=c; } // 使用 // 批量处理区间[l,r] insert(b,l,r,c); // c为增量 // 对于单个元素 insert(b,i,i,a[i]); // // 对于 二维 void insert(int b[][N],int x1,int y1,int x2,int y2,int c) { b[x1][y1]+=c; b[x2+1][y1]-=c; b[x1][y2+1]-=c; b[x2+1][y2+1]+=c; } // 使用 // 批量处理区间[(x1,y1)...(x2,y2)] insert(b,x1,y1,x2,y2,c); // c为增量 // 对于单个元素 insert(b,i,j,i,j,a[i][j]); // 一维差分 假设有一个数组，a1，a2，a3，a4，a5，…，an 针对这个数组，构造出另一个数组，b1，b2，b3，b4，b5，…，bn 使得a数组是b数组的前缀和，即使得 ai = b1 + b2 + … + bi 此时，称b数组为a数组的差分 如何构造b数组呢： b1 = a1 - 0，b2 = a2 - a1，b3 = a3 - a2，…，bn = an - an-1 实际可以不用如此来构造，在输入数组a时，可以先假想数组a和数组b的全部元素都是0。然后每次进行一次插入操作（指的是对数组a的[l, r]区间的每个数加上常数C），比如 对a数组区间[1,1]，加（插入）常数a1；对区间[2,2]，加常数a2，…，这样在输入数组a的同时，就能够快速构造出其差分数组b 差分的作用： 若要对a数组中[l, r]区间内的全部元素都加上一个常数C，若直接操作a数组的话，时间复杂度是O(n)。而如果操作其差分数组b，则时间复杂度是O(1)。这是因为，数组a是数组b的前缀和数组，只要对 bl 这个元素加C，则a数组从l位置之后的全部数都会被加上C，但r位置之后的所有数也都加了C，所以我们通过对 br+1 这个数减去C，来保持a数组中r位置以后的数的值不变。 于是，对a数组的[l, r]区间内的所有数都加上一个常数C，就可以转变为对 bl 加C，对br+1 减 C。 二维差分 即差分矩阵 Article:差分矩阵 对于矩阵a，存在如下一个矩阵b b11 ，b12，b13，b14，…，b1n b21，b22，b23，b24，…， b2n … 给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c … bm1，bm2，bm3，bm4，…，bmn 使得aij = 矩阵b中[i, j]位置的左上角的所有数的和 称矩阵b为矩阵a的差分矩阵。 同样的，如果期望对矩阵a中左上角为[x1, y1]，右下角为[x2, y2]的区域内的全部元素，都加一个常数C，则可以转化为对其差分矩阵b的操作。 先对b中[x1, y1]位置上的元素加C，这样以来，a中[x1, y1]这个点的右下角区域内的所有数都加上了C，但是这样就对[x2, y2]之后的区域也都加了C。我们对[x2, y2]之外的区域需要保持值不变，所以需要进行减法。对bx2+1,y1 减掉C，这样下图红色区域都被减了C，再对bx1,y2+1减掉C，这样下图蓝色区域都被减了C，而红色区域和蓝色区域有重叠，重叠的区域被减了2次C，所以要再加回一个C，即对bx2+1,y2+1 加上一个C。这样，就完成了对[x1, y1]，[x2, y2]区域内的所有数（下图绿色区域），都加上常数C。 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c D-用邮票贴满网格图 给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。 给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ： 覆盖所有 空 格子。 不覆盖任何 被占据 的格子。 我们可以放入任意数目的邮票。 邮票可以相互有 重叠 部分。 邮票不允许 旋转 。 邮票必须完全在矩阵 内 。 如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。 示例 1： | × | 1| 1| 1| |:---|--:|:--:|--| |× | 1 2 |1 2 |1 2 | | ×| 1 2| 1 2| 1 2| | × |1 2 |1 2 |1 2 | | × |2 | 2|2 | 输入：grid = [ [1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0] ], stampHeight = 4, stampWidth = 3 输出：true 解释：我们放入两个有重叠部分的邮票（图中标号为 1 和 2），它们能覆盖所有与空格子。 示例 2： | × | | | | |:---|--:|:--:|--| | | × | | | | | |× | | | | | |× | 输入：grid = [ [1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1] ], stampHeight = 2, stampWidth = 2 输出：false 解释：没办法放入邮票覆盖所有的空格子，且邮票不超出网格图以外。 class Solution { public: int get(int x1, int y1, int x2, int y2, vector> &s){ return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; // 二维区间和 模板！！ } void insert(int x1, int y1, int x2, int y2, vector> &b) // 二维差分 模板！！ { b[x1][y1] += 1; b[x2 + 1][y1] -= 1; b[x1][y2 + 1] -= 1; b[x2 + 1][y2 + 1] += 1; } bool possibleToStamp(vector>& grid, int r, int c) { int n = grid.size(); int m = grid[0].size(); bool ok = true; for(int i = 0; i n || c > m) return false; vector > s(n + 10, vector(m + 10)); vector > d(n + 10, vector(m + 10)); vector > a(n + 10, vector(m + 10)); for(int i = 0; i n) continue; if(j + c - 1 > m) continue; if(get(i, j, i + r - 1, j + c - 1, s) != 0) continue; insert(i, j, i + r - 1, j + c - 1, d); // 并不真正的加上去 ，否则影响继续判断啊 } } for (int i = 1; i ac最佳牛围栏 农夫约翰的农场由 N 块田地组成，每块地里都有一定数量的牛，其数量不会少于 1 头，也不会超过 2000 头。 约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。 围起区域内至少需要包含 F 块地，其中 F 会在输入中给出。 在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。 输入格式 第一行输入整数 N 和 F，数据间用空格隔开。 接下来 N 行，每行输入一个整数，第 i+1 行输入的整数代表第 i 片区域内包含的牛的数目。 输出格式 输出一个整数，表示平均值的最大值乘以 1000 再 向下取整 之后得到的结果。 1.最值问题转化为二分判定问题 注意当二分端点为double类型时，注意精度问题 2.不定长部分序列和优化 O(n^2)-> O(n) 思路： 实数二分+前缀和+双指针 // check: 判断一个正数数组中是否存在一个长度大于m的连续子序列和的平均值大于等于avg bool check(double avg) { for (int i = 1; i = 0) return true; } return false; } D-向下取整数对和 -给你一个整数数组 nums ，请你返回所有下标对 0 函数 floor() 返回输入数字的整数部分。 示例 ： 输入：nums = [2,5,9] 输出：10 解释： floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0 floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1 floor(5 / 2) = 2 floor(9 / 2) = 4 floor(9 / 5) = 1 我们计算每一个数对商向下取整的结果并求和得到 10 。 class Solution { public: int sumOfFlooredPairs(vector& nums) { vector arr(200010, 0); vector sum(200010, 0); int maxV = 0; long long ret = 0; for(auto it: nums){ maxV = max(maxV, it); arr[it] ++; } for(int i = 1; i 0){ for(long long j = 1; j * i 增减序列 给定一个长度为 n 的数列 a1,a2,…,an，每次可以选择一个区间 [l,r]，使下标在这个区间内的数都加一或者都减一。 求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。 输入格式 第一行输入正整数 n。 接下来 n 行，每行输入一个整数，第 i+1 行的整数代表 ai。 输出格式 第一行输出最少操作次数。 第二行输出最终能得到多少种结果。 数据范围 0 解：贪心+差分 一维差分 区间修改，联想到用差分数组来维护，最终目标是使差分数组 除首元素外全为 0 每次修改一个区间，对于维护的差分数组变化情况分类：(1 1.修改 [l,r] ：b[l] -- , b[r + 1] ++ 或 b[l] ++ , b[r + 1] -- 2.修改 [1,r] ：b[1] -- , b[r + 1] ++ 或 b[1] ++ , b[r + 1] -- 3.修改 [l,n] ：b[l] -- 或 b[l] ++ 4.修改 [1,n] ：b[1] -- 或 b[1] ++ （多余操作） 观察易得: 操作 4 是多余操作（不影响除首元素外元素值，相当于浪费一次操作，必然不是最优解） 操作 2 和操作 3 一次只能改变 1 个元素的值，操作 1 一次可以改变 2 个元素的值 操作 2 会改变首元素的值 为了让操作次数尽可能少，应尽可能使用操作 1 因此不妨设 b2,...,bn 中正数总和为 p， b2,...,bn 中负数总和为 q 然后让正负数配对，尽量执行操作 1，执行次数为 min(p,q) 剩余 |p−q| 个要么全是正数，要么全是负数，调用操作 2 或操作 3 都可，执行次数为 |p−q| 次，即共操作min(p,q)+abs(p-q) = max(p,q)次 由于每次调用操作 2 时会改变一次首元素的值，因此首元素的可能值就有 |p−q|+1 种可能 因此最终答案为：max(p,q) 和 | p - q| + 1 #include using namespace std; #define ll long long #define N 110000 ll n,m,i,j,p,q,a[N]; int main() { scanf(\"%lld\",&n); for (i=1;i0)//不要输入 if (c) 因为c是指不为0就好了,如果c为-1,那么最后的布尔值也为1,if(c)的意思是,只要c不为0,那么条件的布尔值都为1 p+=c; else q-=c; } ll ans1=max(p,q),ans2=abs(p-q)+1; cout 最高的牛 有 N 头牛站成一行，被编队为 1、2、3…N，每头牛的身高都为整数。 当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。 现在，我们只知道其中最高的牛是第 P 头，它的身高是 H ，剩余牛的身高未知。 但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。 求每头牛的身高的最大可能值是多少。 输入格式 第一行输入整数 N,P,H,M，数据用空格隔开。 接下来 M 行，每行输出两个整数 A 和 B ，代表牛 A 和牛 B 可以相互看见，数据用空格隔开。 输出格式 一共输出 N 行数据，每行输出一个整数。 第 i 行输出的整数代表第 i 头牛可能的最大身高。 数据范围 1≤N≤10000, 1≤H≤1000000, 1≤A,B≤10000, 0≤M≤10000 输入样例： 9 3 5 5 1 3 5 3 4 3 3 7 9 8 输出样例： 5 4 5 3 4 4 5 5 5 注意： 此题中给出的关系对可能存在重复 解： 我们希望每对牛之间可以相互看见，并且每头牛的高度最高 一开始不妨假设所有牛的高度都是给出的最高牛的高度 要使第 A 头牛与第 B 头牛可以互相看见，那么只需让区间 [A+1,B−1] 的牛高度减少 1 即可 可以直接用差分序列来维护原序列，则每次修改操作为：b[x + 1] -- , b[y] ++ 差分+区间处理小操作 这道题目一个核心要点，就是如何处理这些特殊的关系，也就是两头牛互相看见。 其实题目中已经告诉我们如何处理，因为我们发现，题目中要求牛的身高最高，那么既然如此，我们完全可以将每一组关系(A,B)，看作[A+1,B−1] 这组牛身高只比A,B这两头牛矮1. 各位可以画一个图，来更好的理解这道题目。 因此我们可以可以利用区间处理小操作，也就是前缀和加差分。设一个数组D，D[i]为比最高牛矮多少，则D[P]=0，那么对于一组关系，我们可以这样操作,D[A+1]–,D[B]++;然后从左到右前缀和，就可以求出矮多少。具体可以看代码实现。 本题数据内部可能重复，要判重，还有[l,r]不一定l const int N = 10010; // 不加常量const 不能用height[N] int height[N]; int main(){ int n,p,h,m; cin >> n>>p>>h>>m; height[1]=h; // height[p]=h; 最高为h 可给第一头牛 作为基准，使所有的牛此时的高度都为h？？？！！！此时Height还是不高度 是差值 set> st; for (int i = 0,a,b; i > a>>b; if(a>b) swap(a,b); if(!st.count({a,b})){ // 避免重复的ab对 导致重复的--或++ st.insert({a,b}); height[a+1]--,height[b]++; } } for(int i=1;i 花期内花的数目 给你一个下标从 0 开始的二维整数数组 flowers ，其中 flowers[i] = [starti, endi] 表示第 i 朵花的 花期 从 starti 到 endi （都 包含）。同时给你一个下标从 0 开始大小为 n 的整数数组 persons ，persons[i] 是第 i 个人来看花的时间。 请你返回一个大小为 n 的整数数组 answer ，其中 answer[i]是第 i 个人到达时在花期内花的 数目 。 提示： 1 104 flowers[i].length == 2 1 104 1 解： 排序？？ 经典问题之求一个点被几个区间覆盖。把 flowers[i] 分成两个点：(flowers[i][0], -INF) 表示花期的开始，(flowers[i][1], INF) 表示花期的结束。每个询问也看成一个点 (persons[i], i)。 把所有点排序，维护变量 now，遇到花期开始则 now++，花期结束则 now--，询问则答案就是当前的 now 值。复杂度 \\mathcal{O}(n\\log n)O(nlogn)。 class Solution { typedef pair PII; const int INF = 1e9; public: vector fullBloomFlowers(vector>& flowers, vector& persons) { vector vec; for (auto &f : flowers) vec.push_back(PII(f[0], -INF)), vec.push_back(PII(f[1], INF)); for (int i = 0; i ans(persons.size()); int now = 0; for (PII p : vec) { if (p.second == -INF) now++; else if (p.second == INF) now--; else ans[p.second] = now; } return ans; } }; 哈希+差分 用变化量表示一段区间上的更新，即在时间点starti 变化量增加了 1，在时间点 endi +1 变化量减少了 1（类比导数的概念）。 遍历flowers，统计这些区间端点产生的变化量，记录在有序集合diff 中。 然后从小到大遍历diff，累加变化量（类比积分的概念）。第 i 个人到达时，花的数目即为不超过 personi 时间点的变化量的累加值。 为了快速计算每个人的答案，我们需要将 person 从小到大排序，这样可以在遍历 person 的同时从小到大遍历 diff。 class Solution { public: vector fullBloomFlowers(vector> &flowers, vector &persons) { map diff; for (auto &f : flowers) { ++diff[f[0]]; --diff[f[1] + 1]; } int n = persons.size(); vector id(n); iota(id.begin(), id.end(), 0); sort(id.begin(), id.end(), [&](int i, int j) { return persons[i] ans(n); auto it = diff.begin(); int sum = 0; for (int i : id) { while (it != diff.end() && it->first second; // 累加变化量 ans[i] = sum; } return ans; } }; class Solution: def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]: diff = defaultdict(int) for st, ed in flowers: diff[st] += 1 diff[ed + 1] -= 1 times = sorted(diff.keys()) n = len(persons) ans = [0] * n i = sum = 0 for p, id in sorted(zip(persons, range(n))): while i 离散化+差分 class Solution { vector alls; int len; int find(int x) { return lower_bound(alls.begin(), alls.begin() + len, x) - alls.begin() + 1; } int b[200010]; void insert(int b[], int l, int r, int c) { b[l] += c; b[r + 1] -= c; } public: vector fullBloomFlowers(vector>& fl, vector& p) { memset(b, 0, sizeof b); int n = fl.size(), m = p.size(); for(int i = 0; i ans; for(int i = 0; i 1930. 长度为 3 的不同回文子序列 给你一个字符串 s ，返回 s 中 长度为 3 的不同回文子序列 的个数。 即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。 回文 是正着读和反着读一样的字符串。 子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。 例如，\"ace\" 是 \"abcde\" 的一个子序列。 示例 1： 输入：s = \"aabca\" 输出：3 解释：长度为 3 的 3 个回文子序列分别是： \"aba\" (\"aabca\" 的子序列) \"aaa\" (\"aabca\" 的子序列) \"aca\" (\"aabca\" 的子序列) 示例 2： 输入：s = \"adc\" 输出：0 解释：\"adc\" 不存在长度为 3 的回文子序列。 示例 3： 输入：s = \"bbcbaba\" 输出：4 解释：长度为 3 的 4 个回文子序列分别是： \"bbb\" (\"bbcbaba\" 的子序列) \"bcb\" (\"bbcbaba\" 的子序列) \"bab\" (\"bbcbaba\" 的子序列) \"aba\" (\"bbcbaba\" 的子序列) 提示： 3 代码很优雅! class Solution { public: int countPalindromicSubsequence(string s) { int n = s.size(); int res = 0; // 前缀/后缀字符状态数组 vector pre(n), suf(n); for (int i = 0; i = 0; --i) { // 后缀 s[i+1..n-1] 包含的字符种类 suf[i] = (i != n - 1 ? suf[i+1] : 0) | (1 ans(26); for (int i = 1; i 精炼版： class Solution { public: int countPalindromicSubsequence(string s) { int n = s.size(), res = 0; int pre[n + 2], suf[n + 2]; MST(pre, 0), MST(suf, 0); fir(i, 1, n) pre[i] = pre[i - 1] | (1 4 二分 4.1 二分法基础 整数域 模板题 AcWing 789. 数的范围 整数二分 求最小值用 r = mid 更新，同时mid = l + r >> 1 求最大值用 l = mid 更新, 同时mid = l + r + 1 >> 1 // 取 l= mid; 时需要在计算mid时l+r+1 >>1 版本一： 前提check单调？？ 右边是check返回为正的区间，最终的结果为右边区间的最左端的值。 即右边比较大的值都满足，找最小的那个值用r = mid更新 bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： while(l>1; if(check(mid)) r = mid; else l = mid + 1; } return l; 版本二： 左边是check返回为正的区间，最终的结果为左边区间的最右端的值。 即左边比较小的值都满足，找最大的那个值用l = mid更新，同时mid = (l + r + r) >> 1; // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： while(l>1; if(check(mid)) l = mid; else r = mid-1; } return l; 注意： mid的值为(l+r+1)>>1 ,必须加一。 因为如果不加一，可能有一种情况，当r = l + 1时，而check（l）刚好为真，之后取中值为mid = l + r >>1,为下取整，mid还为l，之后就会有死循环。 实数域 模板题 AcWing 790. 数的三次方根 区别于整数二分的while(l =r 退出 实数二分的while(r > l + eps),即r-l 同时注意l, r, mid的数据类型不再是int 因为为浮点二分，不再对r或l的值更新进行加一减一的操作 ```c++ 版本一： bool check(double x) {/ ... /} // 检查x是否满足某种性质 const double eps = 1e-6; while(r-l>=1e-8) { double mid = (l+r)/2; if(check(mid)) r = mid; else l = mid; } return l; 版本二： 让二分有限固定次数 for(int i=1;i ### 牛顿法 - 1.编写一个函数，取三次根的功能。(实数二分(迭代)，牛顿迭代) - 1.二分 注意精度 while(r - l > 1e-8){ l / r = mid;// 用mid更新即可，mid 也要是double类型} - 2.牛顿法原理 - [牛顿迭代法求立方根](https://blog.csdn.net/u012028275/article/details/113822412) ![](./assets/牛顿法求立次根1.png) ![](./assets/牛顿法求立次根2.png) ![](./assets/牛顿法求立次根3.png) ```c++ double Cbrt(double c) { double err = 1e-8; //设立精度 double t = c; while (fabs(c - t*t*t) > err) t = (2 * t + c / t / t) /3;//三次方的递推公式 return t; } 同理，更简单的用牛顿法求平方根 - ![](./assets/牛顿法求平方根.png) ```c++ double Sqrt(double c) //square root { double err = 1e-8; //设立精度 double t = c; while (fabs(c - t * t) > err) t = (t + c / t) / 2;//三次方的递推公式 return t; } ``` - 3.退火法 见搜索部分中的**退火**。 2.牛顿法的收敛性 牛顿迭代法收敛性的一点讨论 最优化方法复习笔记（三）牛顿法及其收敛性分析 牛顿法和梯度下降法： 都是基于当前迭代点的梯度信息进行搜索方向的选择的，只不过梯队下降法是在梯度的反方向上进行线搜得到下一个迭代点，而牛顿法则是通过Hessian矩阵在梯度上进行线性变换得到搜索方向（甚至步长都不需要确定）。所以牛顿法对函数在迭代点处的信息利用更加充分，直观来看，相比于梯度下降法，函数足够正则的情况下牛顿法迭代得更加准确，收敛速率也会更快。 比如还是拿正定二次型作为例子，无论使用哪种方式确定步长的梯度下降法，只要Hessian矩阵的条件数比较大，那么梯度下降法的迭代序列会依赖于迭代初值的选取，有的迭代初值会使得迭代序列抖动地靠近最优点，有的则只需要一步就迭代到了最优点。 今天在使用牛顿迭代法求方程的数值解时，发现其一会儿收敛，一会儿不收敛，于是认证研究了下牛顿迭代法的收敛条件。 牛顿迭代法的收敛性分为局部收敛性与全局收敛性。 局部收敛性：若α是f(x)=0的一个单根, f(α)=0,f’(α)≠0,ϕ’(α)=0, ϕ’’(α)=f’’(α)/f’(α), 则在根α附近Newton 法是局部收敛的, 并且是二阶收敛的。这个附近指的是充分接近。要多接近呢？似乎没有进一步的证明。 这就决定了牛顿迭代法的初值选取非常重要，只有在解的附近选初值才具有局部收敛性。可是证明去找解的附近呢？一种方法是先用二分法找一个大概的解，再用牛顿法求解。 然而，对于某些函数，初值离解很远也能收敛，这就要谈到全局收敛性了。 全局收敛性： 设f(x)在有根区间[a, b]上二阶导数存在，且满足 (1) f(a)f(b) (2) f’(x)≠0, x∈[a, b]; (3) f’’(x)不变号, x∈[a, b]; (4) 初值x0 ∈[a, b]且使f’’(x0) *f(x0)>0; 则Newton迭代法收敛于f(x)=0在[a, b]内的惟一根。 其中，条件（2）和（3）要求函数在区间内为凸或凹函数，条件（4）又规定了初值接近解的方向，算是比较苛刻的条件。以f(x)=lnx为例，若选择初值x0为4，则第一次迭代后的值x1为-1.505，超过了定义域，就不收敛了。 4.2 最值问题转化为二分判定问题 分割数组的最大值 区别于不要求连续分配，见搜索的模拟退火部分(也可用二分+回溯或二分+dp)1723. 完成所有工作的最短时间 给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m 个非空的连续子数组。 设计一个算法使得这 m 个子数组各自和的最大值最小。 示例 1： 输入：nums = [7,2,5,10,8], m = 2 输出：18 解释： 一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 示例 2： 输入：nums = [1,2,3,4,5], m = 2 输出：9 示例 3： 输入：nums = [1,4,4], m = 3 输出：4 dp O(n^2 * m) class Solution { public: int splitArray(vector& nums, int m) { int n = nums.size(); vector> f(n + 1, vector(m + 1, LLONG_MAX)); vector sub(n + 1, 0); for (int i = 0; i 二分+贪心 O(n*log(sum - maxn)) 「使……最大值尽可能小」是二分搜索题目常见的问法。 本题中，我们注意到：当我们选定一个值 x，我们可以线性地验证是否存在一种分割方案，满足其最大分割子数组和不超过 x。策略如下： 贪心地模拟分割的过程，从前到后遍历数组，用 sum 表示当前分割子数组的和，cnt 表示已经分割出的子数组的数量（包括当前子数组），那么每当 sum 加上当前值超过了 x，我们就把当前取的值作为新的一段分割子数组的开头，并将 cnt 加 1。遍历结束后验证是否 cnt 不超过 m。 这样我们可以用二分查找来解决。二分的上界为数组 nums 中所有元素的和，下界为数组 nums 中所有元素的最大值。通过二分查找，我们可以得到最小的最大分割子数组和，这样就可以得到最终的答案了。 class Solution { public: int splitArray(vector& nums, int m) { long l = nums[0], h = 0;//int类型在这里不合适，因为h可能会超过int类型能表示的最大值 for (auto i : nums) { h += i; l = l > i ? l : i; } while (lmid) { temp = i; ++cnt; } } if(cnt>m) l = mid + 1; else h = mid; } return l; } }; 二分求序列最大平均值 给定一个长度为n的序列a，定义ai为第i个元素的价值。现在需要找出序列中最有价值的“段落”。段落的定义是长度在[S，T]之间的连续序列。最有价值段落是指平均值最大的段落。 段落的平均值等于段落总价值除以段落长度。 首先二分答案，即：二分最大平均值。 我们将a全部减去mid，问题转化为判断是否存在一个长度在s~t范围内的区间它的和为正，如果有说明还有更大的平均值。用前缀和和单调队列维护。 然后用单调队列求出sum[i]-min（sum[i-t]~sum[i-s]），然后判断是否大于0即可。 代码见模板，以下有问题 #include using namespace std; typedef long long ll; ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); #define debug(x) cout??\"# \"??x??endl const ll N=100005; const ll base=137; const ll mod=2147483647; const ll INF=1??30; ll n,m,a[N],s,t; double sum[N],ans; bool check(double mid) { for(int i=1;i??n;??i) sum[i]=sum[i-1]+(double)a[i]-mid; ll head=1,tail=0,q[N]; for(int i=s;i??n;??i)??区间的长度最少为s所以求前缀和，至少从s开始 { while(head??tail??sum[q[tail]]??sum[i-s])??如果??说明队列里出现了降序 tail??;??把最前面的丢掉直到队列保持升序为止 q[??tail]=i-s; ??while(!q.empty()??q.front.index 2021 GDCPC广东省大学生程序设计竞赛- T1/wr笔试 给定x,y,k，求i取1-x，j取1-y时，i*j的第k大，范围x,y,k 均[1, 10^6] 即：给你三个数n,m,k 然后会根据n,m生成数列 1×1,1×2,······,1×m 2×1,2×2,······,2×m ··· n×1,n×2,······,n×m 问你将这些数字中第k大的数字是多少 解： 优先队列 设置一个pair类型的堆 每次就插入从 1 × m 到 n × m 的元素依次插入值与左边下标进入堆中 然后算第k大的时候就每次找堆顶元素 把堆顶元素减去一个下标再放入堆中（这样就代表了 n * (m - 1) 的元素进入了堆中 然后反复操作找第k大即可 时间复杂度是 nlogn+klogn #include using namespace std; typedef long long ll; priority_queue> q; int main() { ll n, m, k; cin >> n >> m >> k; for(int i = 1; i temp; while(-- k){ temp = q.top(); q.pop(); temp.first -= temp.second; q.push(temp); } cout 二分 把思路转化成求第k小的数字 把答案设为ans 建一个1到n的for循环(下标为i） 如果 ans / i >= m就说明肯定它前面至少是有m个数字的 小于的时候ans / i就是它前面数字的答案了 那么直接check的时候算ans += min(ans / i, m) 然后二分就好了 #include using namespace std; #define ll long long ll n, m, k; bool check(ll x) { ll res = 0; for (int i=1;i= k; } int main() { cin >> n >> m >> k; k = n * m - k + 1; ll l = 1, r = n * m; while(l > 1; if (check(mid)) r = mid; else l = mid + 1; } cout 4.3 一类二分查找问题 旋转数组 [例] 寻找旋转排序数组中的最小值 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 class Solution { public: int findMin(vector& nums) { int left=0; int right=nums.size()-1; while(left [例] 寻找旋转排序数组中的最小值 II 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4] 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 你必须尽可能减少整个过程的操作步骤。 class Solution { public: int findMin(vector& nums) { if(nums.size()==1) return nums[0]; int l=0,r=nums.size()-1; while(l [例] 搜索旋转排序数组 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 解法1 class Solution { public: int search(vector& nums, int target) { int n = (int)nums.size(); if (!n) { return -1; } if (n == 1) { return nums[0] == target ? 0 : -1; } int l = 0, r = n - 1; while (l 解法2： class Solution { public: int search(vector& nums, int target) { int lo = 0, hi = nums.size() - 1; while (lo target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid])) lo = mid + 1; else hi = mid; } return lo == hi && nums[lo] == target ? lo : -1; } }; [例] 搜索旋转排序数组 II 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。 在传递给函数之前，nums 在预先未知的某个下标 k（0 class Solution { public: bool search(vector &nums, int target) { int n = nums.size(); if (n == 0) { return false; } if (n == 1) { return nums[0] == target; } int l = 0, r = n - 1; while (l [例] 面试题 10.03. 搜索旋转数组 搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。 示例1: 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5 输出: 8（元素5在该数组中的索引） 示例2: 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11 输出：-1 （没有找到） class Solution { public: int search(vector& arr, int target) { int left = 0; int right = arr.size() - 1; while(left 0 && arr[mid] == arr[mid - 1]){ mid--; } if(arr[0] == target) return 0; return mid; } //arr[mid] == arr[left] 则缩短数组左边界 while(left mid && arr[mid] == arr[right]){ right--; } //左边有序 if(arr[mid] >= arr[left]){ //目标在左边部分 if(target = arr[left]){ right = mid - 1; }else{ left = mid + 1; } }else{//右边有序 //目标在右边部分 if(target > arr[mid] && target 4.4 二分优化 LIS问题的优化版本见动态规划LIS部分 4.5 三分法 三分法求单峰函数的极值 以单峰函数 为例，我们在函数的定义域 上人为地取两个点 和 ，其中 ，把函数分成三段: 如果 ，则 和 要么同时处于极大值点左侧，要么分别位于极大值点两侧，无论是哪种情况，都可 以确定极大值点在 右侧，可令 。 5 排序 5.1 基本排序 十大经典排序算法（动图演示） c++排序算法整理 十种常见排序算法可以分为两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 包括插入排序、希尔排序、选择排序、堆排序、冒泡排序、快速排序和归并排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。包括计数排序、桶排序和基数排序 或有图： 记忆： 比较类：交(交换：冒泡、快速)插(插入：简单插入、希尔)选(选择:简单选择、堆)归(归并：两路和多路) 非比较类：计(计数)基(基数)桶 排序算法名称 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 插入排序 O(n2) O(n2) O(n) O(1) 稳定 希尔排序 O(n1.3) O(n2) O(n) O(1) 不稳定 选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 冒泡排序 O(n2) O(n2) O(n2) O(1) 稳定 快速排序 O(nlog2n) O(n2) O(nlog2n) O(nlog2n) 不稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 计数排序 O(n+k) O(n+k) O(n+k) O(n+k) 稳定 桶排序 O(n+k) O(n2) O(n) O(n+k) 稳定 基数排序 O(n×k) O(n×k) O(n×k) O(n+k) 稳定 0、稳定性分析 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 冒 插 归 （ 统 计 基） 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在b 的后面。 总结： 排序算法的稳定性 稳定：冒泡(相等时不交换即可稳定)、插入、归并(左组和右组相同时 先拷贝左边的元素)、一切以桶排序为思想的排序。 不稳定：选择(如6663,第一轮交换就把第一个6放到了第二和第三个6的后面)、堆排序（只维持大根堆的有序,如依次添加5、4、4、6入堆，6入堆的时候会把第一个4交换下来即交换到第二个4的后面)、快速排序(如6663，选4做为哨兵。则会把前面的6和3交换，则6的顺序变化了) stl中sort用的快速排序？？ stable_sort用归并？？ 用途 基础类型的数据稳定性讨论意义不大，而如果排序对象有多个属性时，按某一个属性排序时另一个属性。 比如买东西，看满意度，相同的情况下要求价格低。才能买到物美价廉。 不存在nlogn,空间O(1)，且稳定的排序 部分简述： 冒泡 稳定 for(i = n; i > 1; i--){ for(int j=1; j //通过n-1轮的循环，每次循环通过交换相邻元素实现把[1,i]上最大值交换到乱序的最后一个位置a[i] if(a[j] } } 选择 不稳定 从0-n-1中最小的放到0 从1-n-1中最小的放到1... for (int i = 1;i // 同样n-1轮循环，i作为默认索引 找到最小的 才做一次交换 交换到前面 int w = i, Min = a[i]; for (int j = i;j a[j]) w = j, Min = a[j]; //寻找🔎最小数和它的位置，不断更新 swap(a[i], a[w]); //最后进行交换 } 插入 稳定 对于未排序数据的头，在已排序序列中从后向前扫描，找到相应位置插入。 每次循环扩大前面有序区间的长度 [1,i],i从1-n 新加入的元素 比 [1,i]的最后元素大或等于，则不变 比最后元素小，则往前交换 已知数据表A中每个元素距其最终位置不远，为节省时间，应采用的算法是 插入排序。 A．堆排序B．直接捅入排序C．快速排序D．直接选择排序 希尔排序 是插入排序改进版。优先比较距离远的元素。 归并 稳定 通过将序列层层分段。将有序的较短子序列进行合并。逐级得到完全有序的序列。 需要备份数组 单个元素返回 mid 递归左[l, mid] [mid + 1, r] 左指针i = l, 右指针j = mid + 1,备份数组k = 0 while(i // 扫尾 // 物归原主 [l, r] 快速 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 单个元素返回 左指针 i = l - 1, 右指针 j = r + 1, 哨兵base x = q[r + l >> 1] while(i x); // 找小于等于x的 if(i 递归(此时有i = j + 1或i == j) 选择j作为边界： l, j ， [j + r, r] (全>=x) 复杂度分析： 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 1、冒泡排序 （Bubble Sort） 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列,一次比较两个相邻元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述(例如：升序) 1.比较相邻的元素。如果第一个比第二个大，就交换它们两个； 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 3.针对所有的元素重复以上的步骤，除了最后一个； 4.重复步骤1~3，直到排序完成。 总共要循环n−1次 有一种冒泡排序的优化，叫鸡尾酒排序 点击最上面的链接c++排序算法整理2查看~ 参考代码： #include using namespace std; const int MAXN = 1e8 + 10; int a[MAXN], n; int main(){ scanf(\"%d\", &n); for (int i = 1;i 1; i--) // 第一个循环先把最大的放最后，共N-1轮循环 ，i作为最后一组比较的两个元素中的后者 for(int j = 1;j a[j + 1]) swap(a[j], a[j + 1]); // 交换两个数 for (int i = 1;i 2、选择排序 （Selection Sort） 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 参考代码： #include using namespace std; const int MAXN = 1e8 + 10; int a[MAXN], n; int main(){ scanf(\"%d\", &n); for (int i = 1;i a[j]) w = j, Min = a[j]; //寻找🔎最小数和它的位置，不断更新 swap(a[i], a[w]); //最后进行交换 } for (int i = 1;i 3、插入排序 （Insertion Sort） 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 参考代码： #include using namespace std; const int MAXN = 1e8 + 10; int a[MAXN], n; int main(){ scanf(\"%d\", &n); for (int i = 1;i a[x + 1] && x > 0) swap(a[x], a[x + 1]), x--; } for (int i = 1;i 4、希尔排序 （Shell Sort）？？？ 1959年ShellShell发明，第一个突破O(n2)的排序算法（听起来挺厉害的。。。），是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 算法描述 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1,t2,t3,...tkt1,t2,t3,...tk，其中ti>tj,tk=1ti>tj,tk=1； 按增量序列个数kk，对序列进行kk趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为mm的子序列，分别对各子表进行直接插入排序。仅增量因子为11时，整个序列作为一个表来处理，表长度即为整个序列的长度。 参考代码： #include using namespace std; const int MAXN = 1e8 + 10; int n, a[MAXN]; int main(){ scanf(\"%d\", &n); for (int i = 0;i 0; step /= 2) for (int i = 0;i = 0 && temp 5、归并排序 （Merge Sort） 归并排序是建立在归并操作上的一种有效的排序算法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 参考代码： #include using namespace std; const int MAXN = 1e8 + 10; int n, a[MAXN], T[MAXN]; void Mergesort(int l, int r) { if (l == r) return; //区间内只有一个数，返回 int mid = l + r >> 1; //相当于(l + r) / 2 Mergesort(l, mid); //递归左半部分 Mergesort(mid + 1, r); //递归右半部分 int i = l, j = mid + 1, k = l; while (i 6、快速排序 （Quick Sort） 对冒泡排序算法的一种改进。 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 参考代码： #include using namespace std; const int MAXN = 1e8 + 10; int n, a[MAXN]; void quickSort(int l, int r) { // [超时啊 ](https://www.acwing.com/problem/content/description/787/) if (l >= r) return; int i = l, j = r, base = a[l]; //base取最左边的数为基准数 while(i = base && i 7、堆排序 （Heap Sort） 堆排序（Heap-sort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 参考代码： #include using namespace std; int n; const int N = 1e8 + 10; int h[N], size; void down(int u) { int t = u; // t记录最小值 if (2 * u = 1; i--) down(i); //初始化堆 while (n--) { printf(\"%d \", h[1]); h[1] = h[size]; size--; down(1); } return 0; } 参考代码2（优先队列）： #include using namespace std; const int MAXN = 1e8 + 10; int n; priority_queue, greater >q; //小根堆 int main() { scanf(\"%d\", &n); int x; for (int i = 1;i 8、计数排序 （Counting Sort） 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 参考代码 #include using namespace std; const int MAXN = 1e8 + 10; long long n, cnt[MAXN]; int main() { scanf(\"%lld\", &n); int x = 0, Max = -0x3f3f3f, Min = 0x3f3f3f; //初始化最大值和最小值 for (int i = 1; i 9、桶排序 （Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 参考代码： #include using namespace std; const int MAXN = 1e8 + 10; int n, Min = MAXN, Max = 0, sum[MAXN]; bool f[45]; vector bucket[45];//定义桶，这里定义40个桶 void insertsort(int s) { for (int i = 0;i = 1; j--) if(bucket[s][j - 1] > bucket[s][j]) swap(bucket[s][j], bucket[s][j - 1]);//这里是从小到大排序 for (int i = 0;i 桶思想 存在重复元素 III 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) class Solution { public: int getID(int x, long w) { // 类似于对负数 下取整 return x & nums, int k, int t) { unordered_map mp; int n = nums.size(); for (int i = 0; i = k) { mp.erase(getID(nums[i - k], t + 1ll)); } } return false; } }; 10、基数排序 （Radix Sort）？？？ 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 参考代码： #include using namespace std; int maxbit(int data[], int n) { int d = 1, p = 10; //d保存最大的位数 for (int i = 0;i = p) p *= 10, d++; return d; } void radixsort(int data[], int n) { //基数排序 int d = maxbit(data, n); int tmp[n]; int cnt[15], i, j, k, radix = 1; for (i = 1;i = 0; j--) { k = (data[j] / radix) % 10; tmp[cnt[k] - 1] = data[j]; cnt[k]--; } for (j = 0;j 快排和归并属于分治算法，分治算法都有三步： 分成子问题 递归处理子问题 子问题合并 两者注意 递归的位置 快排在末尾，归并排序在前面 提前返回 5.2 快速排序 模板题AcWing 785. 快速排序 快速排序法（详解）(lomuto版本) 对冒泡排序算法的一种改进。 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 快速排序之所以比较快，是因为与冒泡排序相比，每次的交换时跳跃式的，每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(n^2)，它的平均时间复杂度为O(nlog2 n)。 hoare 版本 相对简单，但不标准，即哨兵一次排序后 未能归位到正确位置 思路： 找到分界点x，取q[L],q[R],或q[L+R>>1] 左边所有数Left =x 递归排序Left，递归排序Right quick_sort(int q[], int l, int r) q是待排序数组，l是待排序区间的左边界，r是右边界 Article:详细解析：快速排序算法的证明与边界分析 基本思路 选取一个基准值x 可以取左边界的值q[l]，或右边界的值q[r]，或者中间位置的值q[l + r >> 1] ⭐️根据基准值，调整区间，使得左半边区间的值全都≤x，右半边区间的值全都≥x 采用双指针，左指针i从左边界l开始，往右扫描，右指针j从右边界r开始，往左扫描。 当满足条件q[i] 当满足条件q[j] > x时，j左移；直到不满足条件时，j停下；交换q[i]和q[j]； 将i右移一位，j左移一位。 重复上面的操作，直到i和j相遇。此时左半区间的数都满足≤x，且左半区间的最后一个数的下标为j，右半区间的数都满足≥x，且右半区间的第一个数的下标为i。i和j之间的关系为：i = j + 1或i = j 对左右两边的区间，做递归操作 递归操作[l, j]，[j + 1, r]区间，或者[l, i - 1]，[i, r]区间即可 void quick_sort(int q[], int l, int r) { if(l >= r) return; // 递归退出条件, 不要写成 l == r, 可能会出现 l > r 的情况，可以尝试用例[1,2] //注意 r和j的选取 以及哨兵。由于以j为边界分治，此处为 l+r>>1，否则需要用l+r+1>>1 int x = q[l + r >> 1], i = l - 1, j = r + 1; // 这里 i 置为 l - 1, j 置为 r + 1, 是因为下面更新i, j 时采用了do while循环, while(i x);// 不能写为 >= x , 因为 j 可能会越界, 原因同上 if(i 流程： >输入 10 3 1 2 4 5 7 6 9 8 0 输出 1 l 0 r 9 x :5 i :5 j :4 3 1 2 4 0 7 6 9 8 5 2 l 0 r 4 x :2 i :2 j :2 0 1 2 4 3 7 6 9 8 5 3 l 0 r 2 x :1 i :1 j :1 0 1 2 4 3 7 6 9 8 5 4 l 0 r 1 x :0 i :0 j :0 0 1 2 4 3 7 6 9 8 5 5 l 3 r 4 x :4 i :4 j :3 0 1 2 3 4 7 6 9 8 5 6 l 5 r 9 x :9 i :9 j :8 0 1 2 3 4 7 6 5 8 9 7 l 5 r 8 x :6 i :6 j :6 0 1 2 3 4 5 6 7 8 9 8 l 5 r 6 x :5 i :5 j :5 0 1 2 3 4 5 6 7 8 9 9 l 7 r 8 x :7 i :7 j :7 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 注意要点 当区间划分结束后，左指针i和右指针j的相对位置，只有2种情况 i = j + 1 i = j（此时i和j指向的元素，恰好等于基准值x） 若用j来作为区间的分界，则[l, j] 都是≤x，[j + 1, r]都是≥x 若用i来作为区间的分界，则[l, i - 1]都是≤x，[i, r]都是≥x 当取i作为分界的话，基准值x不能取到左边界q[l]，否则会出现死循环，比如用例[1,2]。此时基准值可以取q[r]，或者q[l + r + 1 >> 1]，注意取中间位置的数时，要加个1，避免l + r >> 1的结果为l 当取j作为分界的话，基准值x不能取到右边界q[r]，否则会出现死循环。此时基准值可以取q[l]，或者q[l + r >> 1] 注意：本代码为hoare版本的快排算法。只实现了 划分结束时[l,j]中的元素都不大于[j+1,r]中的元素。 而lomuto算法要求每轮排序后轴点处于最终位置。 具体来说： // 对于如下元素的排序 6 7 2 5 6 7 8 //其中 int i = l - 1, j = r + 1, x = q[l + r >> 1]; 1 x :5 i :2 j :1 5 2 7 6 6 7 8 2 x :5 i :1 j :0 2 5 7 6 6 7 8 3 x :6 i :3 j :3 2 5 6 6 7 7 8 4 x :6 i :3 j :2 2 5 6 6 7 7 8 5 x :7 i :5 j :4 2 5 6 6 7 7 8 6 x :7 i :5 j :5 2 5 6 6 7 7 8 思想总结 选一个值x 以该值为分界点，将数组分为左右两部分，左边的全都≤x，右边的全都≥x 对左右两部分进行递归操作 lomuto 版本 void quick_sort(int a[], int l, int r) { // [超时啊](https://www.acwing.com/problem/content/description/787/) if (l >= r) return; int i = l, j = r, base = a[l]; //base取最左边的数为基准数 while(i = base && i 问：直接写出快速排序一趟后的结果 25 50 70 21 4 18 100 43 7 12 以25为基准，比25小的有：21 4 18 7 12 比25大的有：50 70 100 43 一趟快速排序之后，比25小的一定被放在左边，比25大的一定被放在右边，比25大的有5个数，则25必然在第6位， 25 50 70 21 4 18 100 43 7 12 将25放在第6位。在第6位前边，比25小数的位置不变，在第6位后边，比25大的数位置不变，即： 21 4 25 100 43 由于哨兵i是从左往右的，哨兵j是从右往左的，则： 对原数组从右往左遍历比25小的数，将其按照从左往右的顺序存放，即： 12 7 18 21 4 25 100 43 对原数组从左往右遍历比25大的数，将其按照从右向左的顺序存放，即： 12 7 18 21 4 25 100 43 70 50 螺母螺帽问题 【螺钉和螺母问题】【算法分析与设计】假设我们有n个直径各不相同的螺钉以及n个相应的螺母... 假设我们有n个直径各不相同的螺钉以及n个相应的螺母。我们一次只能比较一对螺钉和螺母，来判断螺母是大于螺钉、小与螺钉还是正好适合螺钉。然而我们不能拿两个螺母做比较，也不能拿两个螺钉做比较。 我们的问题是要找到每一对匹配的螺钉和螺母。为该问题设计一个算法，它的平均效率必须属于Θ(n log n)。 假设我们一开始随便选一枚螺钉A，假设就取区间最左侧那一枚（一开始区间是[0, n-1]）。然后在螺母的对应区间（[0, n-1]）首先找到与螺钉A对应的螺母a。然后把螺母a与区间最左侧的螺母调换位置。然后根据螺钉A，在区间内，对螺母a进行划分。注意，这里是根据 螺钉A ， 而不是根据调换了位置的螺母a！！！不然就违背题意了。螺母一次划分后。同理以 螺母a 来划分 螺钉，注意此时的区间还是 [0, n-1]。 上面是一次划分的算法。我们需要多次划分，每次划分都要缩小区间。详见代码。 #include #include #include using namespace std; const int N = 9; void print(int ld[], int lm[]) { printf(\"ld：\"); for (int i = 0; i = key && i TopK问题： 利用大根堆维护最小的k个数，适用于数据流形式。(默认堆 或 手动建堆) 用大根堆，只需要维护大小为k的堆即可。 小根堆，需要全部入堆，并输出前k个(手动建的堆，要把堆顶弹出后再down(1)!!!) 如果数据所有已知，利用快速排序法 利用快速选择算法，是快速排序的一种变形。 最小的k个数 第k个数 用快速选择可达o(n) const int N = 100010; int q[N]; int quick_sort(int q[], int l, int r, int k) // 此处k为区间[l,r]内第k小 { if (l >= r) return q[l]; int i = l - 1, j = r + 1, x = q[l + r >> 1]; while (i x); if (i = k) return quick_sort(q, l, j, k); else return quick_sort(q, j + 1, r, k - (j - l + 1)); } int main() { int n, k; scanf(\"%d%d\", &n, &k); for (int i = 0; i 5.3 归并排序 模板题 AcWing 787. 归并排序 思路： [L,R] => [L,mid],[mid+1,r] , mid = l+r>>1; 递归排序[L,mid],[mid+1,r] 归并 将左右两个有序序列合并成一个有序序列 Article:详细解析：归并排序的证明与边界分析 「归并排序」与「逆序对」是息息相关的。归并排序体现了 “分而治之” 的算法思想，具体为： 分： 不断将数组从中点位置划分开（即二分法），将整个数组的排序问题转化为子数组的排序问题； 治： 划分到子数组长度为 1 时，开始向上合并，不断将 较短排序数组 合并为 较长排序数组，直至合并至原数组时完成排序； 注意：在合并的每一过程中 与冒泡排序的对比。 int temp[N]; void merge_sort(int q[], int l, int r) { if (l >= r) return; int mid = l + r >> 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i 流程： >输入 8 7 3 2 6 0 1 5 4 >输出 // l 0 r 1 3 7 2 6 0 1 5 4 l 2 r 3 3 7 2 6 0 1 5 4 l 0 r 3 2 3 6 7 0 1 5 4 l 4 r 5 2 3 6 7 0 1 5 4 l 6 r 7 2 3 6 7 0 1 4 5 l 4 r 7 2 3 6 7 0 1 4 5 l 0 r 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 D-超快速排序 逆序对问题 求解： D-数组中的逆序对 归并排序，清晰图解 // 方法一： 归并排序 int temp[N]; int res; void merge_sort(int q[], int l, int r) { if (l >= r) return; int mid = l + r >> 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i alls; int len; int find(int x) { return lower_bound(alls.begin(), alls.begin() + len, x) - alls.begin() + 1; } public: int reversePairs(vector& nums) { alls = nums; sort(alls.begin(), alls.end()); len = unique(alls.begin(), alls.end()) - alls.begin(); n = len; int ans = 0; for(int i = nums.size() - 1; i >= 0; -- i){ ans += ask(find(nums[i]) - 1); //把自己去掉 add(find(nums[i]), 1); } return ans; // find(a[i]); // alls[k - 1]; } }; 拓展： 不只要求>，如果要求大于 nums[i] > nums[j] * 2 的对数呢。 翻转对 给定一个数组 nums ，如果 i 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。 你需要返回给定数组中的重要翻转对的数量。 示例 1: 输入: [1,3,2,3,1] 输出: 2 示例 2: 输入: [2,4,3,5,1] 输出: 3 注意: 给定数组的长度不会超过50000。 输入数组中的所有数字都在32位整数的表示范围内。 解： 1.注意longlong 2.把nums[i] 和 nums[i] * 2 离散化 3.树状数组存储 nums[i] 即可。 const int N = 50010 * 2; class Solution { int t[N]; // 1-n int n; int lowbit(int x){return x & -x;} void add(int x,int k) { for( ; x alls; int len; int find(long long x) { return lower_bound(alls.begin(), alls.begin() + len, x) - alls.begin() + 1; } public: int reversePairs(vector& nums) { len = nums.size(); // 不要int len 啊 屏蔽了 类内的len.... 调用find时，len =0 .... alls.resize(len * 2); for(auto i = 0; i = 0; -- i){ // ？ 不行 // ans += ask(find((long long)nums[i] - 1)); // add(find((long long)nums[i] * 2), 1); // } for(int i = 0; i 逆序对->八数码问题 1.逆序。一般认为从左向右序列的数字增大认为是正序的，那么从左到右序列的序列数字出现减小就认为是逆序的。一个“逆序”的数学定义是这样的，如果存在正整数 i, j 使得 1 ≤ i A[j]，则 这个有序对称为 A 的一个逆序，又称作一个逆序对。 2.逆序数。整个序列中的逆序对的个数叫做序列的逆序数。 3.逆序列。逆序列是表示序列逆序属性的一个序列，其定义是这样的，逆序列中的某一项aj表示原序列中的第二成分（右边成分）为j的逆序对的个数。逆序列中的j需要从小到大正序排列，这样子组成的序列就叫作逆序列。显然，逆序列各项之和也是序列的逆序数。 数量求解 归并 求解见上 左边大时累加 树状数组 求解见上 注意倒序入树 八数码问题 有解 逆序对 的数量为偶数 每次交换时逆序对数量不变 奇数码问题 奇数码问题 - 解答 首先，对于一个矩阵，我们先来考虑左右移动对逆序对的贡献。 我们计算逆序对的时候不会算空格，所以左右移动不会对逆序对产生影响。 我们再来讨论一下上下移动对逆序对的贡献。 由于上下移动是一回事，所以我以向上移动来举例子。 x … x X x … x x … x x … x 变成 x … x x … x x … x X x … x 那么，逆序对就会有影响，影响的是我用粗体标注的东西。 x … x X x … x x … x X x … x 因为一行的是奇数个格子，所以，我用黑体标注的数字的个数一定是偶数。 假设这些数字中有 x 比 X 大，y 个比 X 小，那么对逆序对的影响就是 x−y。 因为 X 走了后，这串数字中比 X 小的逆序对全部没了，所以会损失 y 个；因为 X 来了后，这串数字中比 X 大的逆序对新增加了，所以会增加 x 个。 又由于 x+y 是偶数，所以 x 和 y 的奇偶性相同，所以 x−y 为偶数。 综上所述，上下左右移动对逆序对的奇偶性没有影响。 求解 bfs 使用state -> target 的 最小步数模型 A* 八数码 预处理距离 作为启发函数 A* #include #include #include #include #include #define x first #define y second using namespace std; typedef pair PIS; int f(string m)//估计函数 { int dt=0; for(int i=0;i d;//存储距离 priority_queue, greater> heap;//小根堆,将元素的估计终点距离从小到大排序 unordered_map> last;//存储一个元素由哪种状态,经过哪种操作得来,跟前面几题一样 heap.push({f(start),start});//加入起点 d[start]=0;//起点到起点的距离为0 //要将操作数组与坐标变化数组一一对应 char oper[]=\"udlr\"; int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1}; while(heap.size()) { auto t=heap.top();//队头 heap.pop();//弹出 string state=t.y;//记录 if(t.y==end) break;//终点出列的话就退出 int x,y;//查找x的横纵坐标 for(int i=0;i=3||b=3) continue;//越界就跳过 swap(state[a*3+b],state[x*3+y]);//交换下标位置 if(!d.count(state)||d[state]>d[init]+1)//如果没有被记录或者小于记录值 { d[state]=d[init]+1;//更新距离 heap.push({f(state)+d[state],state});//加入堆中 last[state]={init,oper[i]};//标记由哪种状态转移而来,并且记录执行的操作 } state=init;//因为要扩展到四个方向,所以要还原 } } string ans; //跟前面几题原来相同 while(end!=start) { ans+=last[end].y; end=last[end].x; } reverse(ans.begin(),ans.end());//将其反转 return ans; } int main() { string start,x,c; while(cin>>c)//这样输入可以忽视空格 { start+=c; if(c!=\"x\") x+=c; } int res=0;//统计逆序对的数量 for(int i=0;ix[j]) res++; if(res%2) printf(\"unsolvable\\n\");//如果逆序对为奇数,就不可能抵达终点 else cout 最少交换次数 转化成有序数组 转成有序数组的最少交换次数 问题描述： 1.通过交换相邻元素的操作把一个给定序列交换成有序，最少需要交换的次数是多少？ 2.通过交换任意两个元素的操作把一个给定序列交换成有序，最少需要交换的次数是多少？ 3.给定数组 A 和 B ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。？？？状态机dp还需要思考一下。？？？ 解析： Q1:**相邻 ：逆序对问题，用归并排序 或者 树状数组** 求解 逆序对数量 即冒泡排序交换次数 可以先将最大数交换到最后，由于是相邻两个数交换，需要交换的次数为最大数后面的数的个数（可以看做是最大数的逆序数），然后，交换过后，去除最大数，再考虑当前最大数也需要其逆序数次交换。则每个数都需要交换其逆序数次操作，则总最少交换次数为序列总体的逆序数。 代码见上。 思考：含有相同元素时，相邻交换所需要最少的操作次数。 拓展：对于不是数字的数组如何计算，因为没有大小关系，怎么计算逆序对呢？ 见题目： 邻位交换的最小次数 给你一个表示大整数的字符串 num ，和一个整数 k 。 如果某个整数是 num 中各位数字的一个 排列 且它的 值大于 num ，则称这个整数为 妙数 。可能存在很多妙数，但是只需要关注 值最小 的那些。 例如，num = \"5489355142\" ： 第 1 个最小妙数是 \"5489355214\" 第 2 个最小妙数是 \"5489355241\" 第 3 个最小妙数是 \"5489355412\" 第 4 个最小妙数是 \"5489355421\" 返回要得到第 k 个 最小妙数 需要对 num 执行的 相邻位数字交换的最小次数 。 测试用例是按存在第 k 个最小妙数而生成的。 示例 1： 输入：num = \"5489355142\", k = 4 输出：2 解释：第 4 个最小妙数是 \"5489355421\" ，要想得到这个数字： -交换下标 7 和下标 8 对应的位：\"5489355142\" -> \"5489355412\" -交换下标 8 和下标 9 对应的位：\"5489355412\" -> \"5489355421\" 示例 2： 输入：num = \"11112\", k = 4 输出：4 解释：第 4 个最小妙数是 \"21111\" ，要想得到这个数字： -交换下标 3 和下标 4 对应的位：\"11112\" -> \"11121\" -交换下标 2 和下标 3 对应的位：\"11121\" -> \"11211\" -交换下标 1 和下标 2 对应的位：\"11211\" -> \"12111\" -交换下标 0 和下标 1 对应的位：\"12111\" -> \"21111\" 示例 3： 输入：num = \"00123\", k = 1 输出：1 解释：第 1 个最小妙数是 \"00132\" ，要想得到这个数字： -交换下标 3 和下标 4 对应的位：\"00123\" -> \"00132\" 提示： 2 解： 1.排列 next_permutation 2.求交换次数 1.贪心 2.映射+逆序对(树状数组(或归并)) 具体代码： 贪心 class Solution { public: int getMinSwaps(string num, int k) { string num_k = num; for (int i = 0; i = i; --k) { ++ans; swap(num[k], num[k + 1]); } break; } } } } return ans; } }; 映射+逆序对计算 求出排列后求取交换次数时，进行 映射，之后处理逆序对，用归并或者树状数组均可。 const int N = 1010; class Solution { int n; int t[N]; // 1-n int lowbit(int x){return x & -x;} void add(int x,int k) { for( ; x n = num.size(); // 第 k 个妙数 string per = num; for (int i = 0;i map[11]; // 每种数字i映射到i+1,即1 - 10 for (int i = 0;i arr(n); for (int i = 0;i = 0; -- i){ ans += ask(arr[i] - 1); // 计算后面(先存的)比自己小的，- 1是不包括自己 add(arr[i], 1); } return ans; } }; 附：next_permutation()使用 #include bool next_permutation( iterator start, iterator end); 对应有prev_permutation() // 使用 // 当当前序列不存在下一个排列时，函数返回false，否则返回true int num[3]={1,2,3}; do { cout acb // 原理 // next_permutation函数的原理如下： // 在当前序列中，从尾端向前寻找两个相邻元素，前一个记为*i，后一个记为*t，并且满足*i bool next_permutation(Iterator first,Iterator last) { if(first == last) return false; Iterator i = first; ++i; if(i == last) return false; i = last; --i; while(1) { Iterator t = i; --i; if(*i Q2:**任意 ：循环节问题。 置换环**问题 对比和 选择排序交换次数的比较 对于一个n长的互异序列， 通过任意交换实现有序的话，最优的交换次数是=n - n被分解成单循环的个数。 其中循环节的求法是，先将数组排序，然后根据之前的坐标和排序之后的坐标，构建成一个有向图，然后在这个图上找到环。 int getMinSwaps(vector &A) { // 排序 vector B(A); sort(B.begin(), B.end()); map m; int len = (int)A.size(); for (int i = 0; i flag(len, false); // 找出循环节的个数 for (int i = 0; i Q3:第三题：给定数组 A 和 B ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。 @@示例: 输入: A = [1,3,5,4], B = [1,2,3,7] 输出: 1 解释: 交换 A[3] 和 B[3] 后，两个数组如下: A = [1, 3, 5, 7] ， B = [1, 2, 3, 4] 两个数组均为严格递增的。 注意: A, B 两个数组的长度总是相等的，且长度的范围为 [1, 1000]。 A[i], B[i] 均为 [0, 2000]区间内的整数。 解： 依照定义，确实可以通过dfs来逐个交换并且判断。但是时间复杂度是几何上升的。 一般经验是这种可以解决的问题都少不了dp。 但是dp需要一个定义，我们又怎样来定义呢？ 所以这里实际上需要两个数组或者说是一组二元变量。 用swap数组中的swap[i]表示第i个元素如果要交换来使得AB成为递增序列那么需要多少次的代价。 用keep数组的keep[i]表示第i个元素不交换使得两个数组依然有序需要多少代价。 举个例子，我们再推导转移方程。 针对A=[1,3,5,7] B=[1,2,3,4] swap[0]=1,keep[0]=0表示第0个元素为了使其保持有序，交换确实可以，但付出了1次的代价，不交换也可以，0次代价。 这只是初始化，真正的大头在后面。 swap[1]=2,keep[1]=0,这个也很显然，因为只看前两个元素的话，已经是满足条件了。那么如果我非要交换来使得顺序成立，那就需要2次，但是不交换依然可以，0次。 swap[2]=3,keep[2]=0,道理同上一段的推导。 但是swap[3]=1,keep[3]=3，这又是什么道理呢？观察AB的末尾，容易看出其实只要交换了7和4就满足了条件了，那么swap就是1。但是如果我不想交换这个元素，那么就需要把前三个都交换一次，就是3. 经过上述的推导，我们发现keep[i],swap[i]总是与keep[i-1],swap[i-1]存在着某种联系。 首先有两种情况： 一、第i个元素是满足增序的，也就是A[i]>A[i-1],B[i]>B[i-1]因为只要保持就可以了，所以keep[i]=keep[i-1]，但是如果要交换，那就比swap[i-1]还多了个第i个元素的代价，也就是swap[i]=swap[i-1]+1. 二、A[i]>B[i-1] 而且B[i]>A[i-1]这种情况满足了“是不是我可以通过交换使得满足条件”，值得一提的是这两个条件应该同时判断，因为谁也不知道那种情况下会有更小的代价。但是如果交换就会是keep[i-1]+1的代价（因为实际上就是翻转了第i个再加上让前i-1个保持的代价），同理keep[i]此时等于swap[i-1]因为不翻转这个，但要翻转前i个。 代码： //dp1[i]表示在不交换A[i]和B[i]的情况下，使得A的前i + 1个元素和B的前i + 1个元素严格递增的最小交换次数； //dp2[i]表示在交换A[i]和B[i]的情况下，使得A的前i + 1个元素和B的前i + 1个元素严格递增的最小交换次数。 class Solution { public: int minSwap(vector& A, vector& B) { int length = A.size(); vector dp1(length, INT_MAX); vector dp2(length, INT_MAX); dp1[0] = 0; dp2[0] = 1; for(int i=1; iA[i-1]&&B[i]>B[i-1]){ dp1[i] = dp1[i-1]; dp2[i] = dp2[i-1]+1; //需要交换 因此+1 } if(B[i]>A[i-1]&&A[i]>B[i-1]){ dp1[i] = min(dp1[i], dp2[i-1]); dp2[i] = min(dp2[i], dp1[i-1]+1); //如果dp1[i - 1] + 1 转化成回文串 相邻交换得到回文串的最小次数。 见贪心部分 得到回文串的最少操作次数 多路归并 合并K个升序链表 分治归并 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1->4->5, 1->3->4, 2->6 ] 将它们合并到一个有序链表中得到。 1->1->2->3->4->4->5->6 示例 2： 输入：lists = [] 输出：[] 示例 3： 输入：lists = [[]] 输出：[] 提示： k == lists.length 0 解： 注意两个函数： merge 将大规模的多个序列分半处理 mergeTwoLists 负责将两个序列合并 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* HEAD = new ListNode(0); ListNode* cur = HEAD; while(list1 || list2){ if(list1 && list2){ if(list1->val val){ cur->next = new ListNode(list1->val); list1 = list1->next; }else{ cur->next = new ListNode(list2->val); list2 = list2->next; } }else if(list1){ cur->next = new ListNode(list1->val); list1 = list1->next; }else{ cur->next = new ListNode(list2->val); list2 = list2->next; } cur = cur->next; } return HEAD->next; } ListNode* merge(vector &lists, int l, int r) { if (l == r) return lists[l]; if (l > r) return nullptr; int mid = (l + r) >> 1; return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r)); } ListNode* mergeKLists(vector& lists) { return merge(lists, 0, lists.size() - 1); } }; 5.4 其他问题 5.4.1 排序、去重与离散化 AcWing 802. 区间和 sort(a, a + cnt); cnt = unique(a, a + cnt) - a; // cnt为去重后的序列长度 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l > 1; if (alls[mid] >= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } // 找到离散化后 第k小的数对应原数字 // 或者?/ // vector 版本 // 全局 vector alls; // 存储排序(未去重)的值 int len; int find(int x){ // 查找数组t中某个元素的映射值 注意未对alls去重 lower_bound(alls.begin(), alls.begin() + len, x) - alls.begin() + 1; } // 不对原数组a vector操作 alls = a; sort(alls.begin(), alls.end()); // 将所有值排序 // alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 len = unique(alls.begin(), alls.end()) - alls.begin(); // 种类数 // for(int & n : t){ // 赋予序值 1- len // n = lower_bound(alls.begin(), alls.end(), n) - alls.begin() + 1; // } // 数组版 int b[N]; int len; int find(int x){ lower_bound(b + 1, b + 1 + len, x) - b; // } int a[N]; // 从1开始 长度为n b = a; // 用 for 备份 sort(b + 1, b + 1 + n); len = unique(b + 1, b + 1 + n - b; // 获取原数组顺序 find(a[i]) // 获取第k小的原值 b[k] // k >= 1 其中，unique函数的实现 vector::iterator unique(vector& a) { int j = 0; // 用来保存不同的数 for(int i=0;i 例题 https://blog.csdn.net/weixin_39145990/article/details/80155678 火柴排队_离散化+归并排序 ac电影 5.4.2 中位数 1. 中位数性质 这类问题本质求 ∑|ai - val|的最小值 其中，val有时要求从给定值中选，如ac货仓选址。则最优解为中间的一个(奇数个)或两个中间(包括其本身，对于偶数个)。 有时不是从给定值选，但原理是一样的。如M-士兵。 需要对所谓的ai进行识别。根据具体问题分析ai是由什么组成。 对于糖果传递问题，是Si = ∑Ai , Ai = ai - average; 对于M-士兵中的x方向，ai是(xi - i) 找到ai后 排序 找中位数 mid，再累加即可。 ans = ∑ abs(ai - mid) ac货仓选址 排序+中位数 中位数有非常优秀的性质，比如说在这道题目中，每一个点到中位数的距离，都是满足全局的最优性，而不是局部最优性。 具体的来说，我们设在仓库左边的所有点，到仓库的距离之和为p,右边的距离之和则为q，那么我们就必须让p+q的值尽量小。 当仓库向左移动的话，p会减少x，但是q会增加n-x，所以说当为仓库中位数的时候,p+q最小。 \\sum_{i=0}^{n-1}|a_i-a_{\\frac n2}| 。同时有∑i=0 n−1|ai−an/2|=∑i=0 n−1 ai−ai/2 同时注意中位数：数组个数为奇数和偶数情况，根据需要是否进行讨论。 奇偶讨论 对于本题的要求： 奇数： 索引从 0 0 1 2 3 4 n = 5, 取 mid = a[(n - 1) >> 1] 即可 索引从 1 1 2 3 4 5 n = 5, 取 mid = a[(n + 1) >> 1] 即可 偶数 索引从 0 0 1 2 3 4 5 n = 6, 取 mid = a[(n - 1) >> 1] 即可，选 中间两个元素平均也行，不影响结果 索引从 1 1 2 3 4 5 6 n = 6, 取 mid = a[n >> 1] 即可，选 中间两个平均也行 即(a[n >> 1] + a[n >> 1 + 1]) / 2, 或者取 mid = a[(n + 1) >> 1]亦可 总结 索引从0开始，中位数直接取 mid = a[(n - 1) >> 1] 索引从1开始，中位数直接取 mid = a[(n + 1) >> 1] 更一般的中位数： 奇数为中间一个，偶数为中间两个均值。 中位数： len & 1 == 1， 为 中间那个 len & 1 == 0, 为 中间两个平均 计算技巧： 取 第 i = len + 1 >> 1 和 j = len + 2 >> 1 小的两个元素取平均即可。 对于 len & 1 == 1： 1 2 3 4 5 len = 5, i = 3, j = 3　为同一个数，即中间的数。 对于 len & 1 == 0: 1 2 3 4 5 6 len = 6, i = 3, j = 4, 为中间两个数，取平均即可。 （同步 刷题笔记中 ： 中位数） 证明： #include #include #include #include using namespace std; #define fir(i,a,b) for (int i=a;i>n; fir(i,1,n){ cin>>g[i-1]; } sort(g,g+n); int res=0; fir(i,0,n-1){ res+=abs(g[i]-g[(n-1)/2]); } cout 拓展：如果求∑(xi - x)^2 最小的x，则为平均数。（求导） 拓展： 安排邮筒 给你一个房屋数组houses 和一个整数 k ，其中 houses[i] 是第 i 栋房子在一条街上的位置，现需要在这条街上安排 k 个邮筒。 请你返回每栋房子与离它最近的邮筒之间的距离的 最小 总和。 答案保证在 32 位有符号整数范围以内。 示例 1： 输入：houses = [1,4,8,10,20], k = 3 输出：5 解释：将邮筒分别安放在位置 3， 9 和 20 处。 每个房子到最近邮筒的距离和为 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 。 示例 2： 输入：houses = [2,3,5,12,18], k = 2 输出：9 解释：将邮筒分别安放在位置 3 和 14 处。 每个房子到最近邮筒距离和为 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9 。 示例 3： 输入：houses = [7,4,6,1], k = 1 输出：8 示例 4： 输入：houses = [3,6,14,10], k = 4 输出：0 提示： n == houses.length 1 const int N = 105; int f[N][N], dis[N][N];//f[i][j] 表示前i个房子送到前j个邮箱的最小值 class Solution { public: int minDistance(vector& h, int k) { int n = h.size(); sort(h.begin(), h.end()); memset(f, 0x3f, sizeof(f));//属性为最小值，故需要初始化为inf for(int i = n-2; i >= 0; --i)//这部分计算及证明参考官解 { for(int j = i+1; j 2. 多维和环状中位数 同时，有一特殊性质解答 M-糖果传递 有 n 个小朋友坐成一圈，每人有 a[i] 个糖果。 每人只能给左右两人传递糖果。 每人每次传递一个糖果代价为 1。 求使所有人获得均等糖果的最小代价。 1.求解非环状时如何计算 2.环状时如何断开，以及为何能断开 3.断开后如何将朴素的枚举 优化为 中位数的 货仓选址 问题 问题分析 ：糖果传递分析 首先，最终每个小朋友的糖果数量可以计算出来，等于糖果总数除以n，用ave表示。 假设标号为i的小朋友开始有Ai颗糖果，Xi表示第i个小朋友给了第i-1个小朋友Xi颗糖果，如果Xi X2=ave-A1+X1 = X1-C1(假设C1=A1-ave，下面类似） 对于第2个小朋友，A2-X2+X3=ave -> X3=ave-A2+X2=2ave-A1-A2+X1=X1-C2 即C2=A1+A2-2ave=A2+C1-ave以此类推 对于第3个小朋友，A3-X3+X4=ave -> X4=ave-A3+X3=3ave-A1-A2-A3+X1=X1-C3 我们的Ci的通式为Ci=Ai+C[i-1]-ave!!!!!!! …… 对于第n个小朋友，An-Xn+X1=ave。 我们希望Xi的绝对值之和尽量小，即|X1| + |X1-C1| + |X1-C2| + ……+ |X1-Cn-1|要尽量小。注意到|X1-Ci|的几何意义是数轴上的点X1到Ci的距离，所以问题变成了：给定数轴上的n个点，找出一个到他们的距离之和尽量小的点，而这个点就是这些数中的中位数，证明略。 问题证明：糖果传递证明【环形纸牌均分问题】 注意： A[i]不是表示第i个人需要传递的数量，S[i]才是。最后答案是对S[i]的累加 考虑 “纸牌均分问题” 如何延伸到 “环形纸牌均分问题” ？ 环形区间的问题，第一想到的就是 破环成链 了 经过思考发现，一定存在一个最优解方案，环上有相邻的两个人之间没有发生交换 这部分证明如下： 如果环上相邻两人全部发生交换，则会出现两种情形：（正数传递为有向边的正向方向） 1.出现一个环 这种方案肯定不是最优解，因为给出去的纸牌经过一圈收回来了，显然浪费了操作次数 我们在这个环上断开交易数量最小的一条交换边，并使其他边减少该边的交换数量，必然不会使方案变差 2.出现一个点到达另一个点有两条路径 我们可以断开起点两条出边中 val = cnt × w 最小的那一套边，并该边权值累加到另一条路径的每一条边上，其结果不会变差（其中 cnt 是起点到终点路径上经过的点数，w 是这条边的权重） 一个朴素的做法是直接枚举断点的位置，然后做一遍线性纸牌均分，但是时间复杂度为 O(n2)不可取，需要推导 // 代码 1： 不修改原数组 int ans=0; int sum[n]; int ave = sum/n; sum[0]=a[0]-ave; // 可有可无 求前缀和是在其基础上，最后要减掉 fir(i,1,n-1){ sum[i]=sum[i-1]+a[i]-ave; } sort(sum,sum+n); int mid = n>>1; fir(i,0,n-1){ ans +=abs(sum[i]-sum[mid]); } // 代码 2： 修改原数组 int ans=0; int ave = sum/n; a[0]=a[0]-ave; // 可有可无 求前缀和是在其基础上，最后要减掉; fir(i,1,n-1){ a[i]=a[i-1]+a[i]-ave; } sort(a,a+n); int mid = n>>1; fir(i,0,n-1){ ans +=abs(a[i]-a[mid]); // 勿忘abs啊 } 1.二维的环状糖果传递问题 M-七夕祭 二维有解 每个维度单独用环状糖果分发 M-士兵 如果某个士兵最后到达的位置已知,那么它具体怎么走是不会影响答案的. 为方便考虑,不妨让它们先走到同一个平行于x轴的直线y=k上.k取什么值时这一步的花费最小?其实就是”货仓选址”问题,将y坐标排序,取中位数即可. 那x轴上如何考虑?将x坐标排序.然后有一个性质:最优情况下,排序后士兵间的相对顺序和最后走到最终位置的相对顺序不会改变. 设最左边的士兵走到x1=ax1=a处,那么由题意,第2个走到x2=a+1x2=a+1处,第i个走到xi=a+i−1xi=a+i−1处. 那么,第i个士兵要走|xi−(a+i−1)|=|xi−(i−1)−a|单位距离. 将xi−(i−1)看成一个整体,问题就又转化为”货仓选址”问题了,对xi−(i−1)排序,取中位数即可. 时间复杂度O(nlogn) 2.联想到一个移动石子(微软-T2) 法1 bfs 使用state -> target 的 最小步数模型 法2 二维糖果分发模型(非环状) 待验证是否可解(应该没问题) 3. 动态中位数 动态中位数 同见D-滑动窗口中位数 1.方法一：对顶堆 在线维护 1.两个二叉堆：一个小根堆，一个大根堆。 2.大根堆维护较小的1 -M/2部分的数，小根堆维护较大的M/2+1-M部分的数 3.每次读入一个数值x后，若x比中位数小，则插入大根堆，否则插入小根堆，插入之后检查并维护以上性质即可。 4.一旦不满足，就把数目多的堆顶元素拿出给另一个堆。 如此若总数为奇数，序列中位数就是小根堆堆顶(小根堆存较大的数，而且大小多一个)。否则为两个堆顶的平均值。 数据存储形式： 大根堆 小根堆 ---------> int n,M; priority_queue down; //down为大根堆 存小的数 priority_queue,greater> up //up为小根堆 greater // 方式1 效率比方式2低一些... // for(int i=0;i>n; // up.push(n); // 可先默认往小根堆里放 // if(down.size()&&down.top()>up.top()) // 先检查一下down的size! // { // int a=up.top(),b=down.top(); // up.pop(),down.pop(); // up.push(b),down.push(a); // } // if(up.size()>down.size()+1) // 防止出现小根堆6个数，大根堆只有4个 // { // down.push(up.top()); // up.pop(); // } // } // 方式2 新元素插入之前先比较从而确定插入到哪一个中 for(int i=0;i>value; if (up.empty() || value > up.top()) up.push(value); else down.push(value); //如果有偶数个数,上面和下面一样多,如果有奇数个数,则上面比下面多一个 if (up.size() > down.size() + 1) down.push(up.top()), up.pop(); //上面比下面多两个 if (down.size() > up.size()) up.push(down.top()), down.pop(); //下面多了挤一个放上面 cout 更简洁： 数据流中的中位数 class MedianFinder { priority_queue down; priority_queue, greater<>> upper; public: /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { down.push(num), upper.push(down.top()), down.pop(); if(down.size() + 1 对顶堆拓展 第i小 不仅能维护中位数，根据设置了两个堆的大小，还可以维护任意小 周赛D：序列顺序查询 同黑盒子 2.方法二：链表+hash 离线 题意：读入一串数列，当i为奇数时输出它的中位数。 动态中位数（链表离线算法） 将所有的数列都读入后排序，最后一个中位数显而易见。 然后链表连一发 再按照输入的顺序 从后往前 两个两个删除。 1.当删除的两个数分别大于和小于当前的中位数 直接记录。 2.当删除的两个数都大于等于当前的中位数 记录last。 3.当删除的两个数都小于等于当前的中位数 记录next。 邻值查找 + 动态中位数离线做法 邻值查找 一张图+一段代码=理解本题的链表解法 [美团实习T4中位数]见主席树部分多解法 6 倍增 向下取整数对和 应用 多重背包的倍增优化(还有单调队列优化) LCA的倍增法(还有tarjan离线解法) 等待中... 彩色铅笔：倍增总结 int p = 1, k = 0, sum = 0; while (p) { if (sum + s[k + p] - s[k] 天才ACM 给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下: 从集合 S 中取出 M 对数(即 2×M 个数，不能重复使用集合中的数，如果 S 中的整数不够 M 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。 现在给定一个长度为 N 的数列 A 以及一个整数 T。 我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。 求最少需要分成几段。 输入格式 第一行输入整数 K，代表有 K 组测试数据。 对于每组测试数据，第一行包含三个整数 N,M,T 。 第二行包含 N 个整数，表示数列A1,A2…AN。 输出格式 对于每组测试数据，输出其答案，每个答案占一行。 数据范围 1≤K≤12, 1≤N,M≤500000, 0≤T≤1018, 0≤Ai≤220 输入样例： 2 5 1 49 8 2 1 7 9 5 1 64 8 2 1 7 9 输出样例： 2 1 解： 思路： 配对 区间内排序后 最大和最小 次大和次小... 如何分段 二分 n^2logn 倍增 nlognlogn #include #include #include using namespace std; const int N = 500005; int n, m; int ans; typedef long long LL; LL T, w[N], t[N]; LL sq(LL x){ return x * x; } // LL x 啊！！！！！ 否则 x*x还是int 会爆int 导致超时 LL get(int l, int r) // 计算原数组左闭右开区间 [l, r) 的校验值 { int k = 0; for (int i = l; i >= 1; } } start = end; ans ++; } printf(\"%d\\n\", ans); } return 0; } 倍增 + 二路归并优化 nlogn bool check(int l, int mid, int r) { for (int i = mid; i 7 贪心 贪心类问题无疑是基础算法中难度最大的，难点在于思维的跳跃性，没有固定的解题模式，往往是一类题一种解法或结论 贪心算法(Greedy Algorithm) 这样的称呼，往往让刚学习的朋友会误解这类题目的特性 Greedy Algorithm 实际上是在每个阶段做出 启发式（heuristic） 的 局部最优化选择，从而达到 全局最优化 的行为 heuristic 在数学最优化问题中的定义：a technique designed for solving a problem more quickly when classic methods are too slow or for finding an approximate solution when classic methods fail to find any exact solution 即在常规方法不能有效求解时，需要用到的启发式求解（这也就是为什么贪心问题特别杂，往往一题一结论，很难掌握） 如果用“状态空间”来理解的话，动态规划(Dynamic Programming) 在每个 stage 求解所有需要的状态实现递推 而 贪心算法(Greedy Algorithm) 则是在每个 stage 根据 启发式策略 策略只去求解部分解实现递推 从“集合”来理解的话，DP就是把每个状态集合都求干净进行递推；贪心则是每次求集合中的符合策略的一部分递推 贪心类型题目解法 之前也说过，贪心类题目没有固定解题模式，不像数据结构计算几何可以一步步推理得出，贪心解法具有跳跃性 使用贪心算法要求问题的整体最优性可以由局部最优性导出 因此，我们可以从局部最优策略下手，证明该策略也可以实现整体最优 常见的证明手段： 微扰（邻项交换） 证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果变差 常用于以 “排序” 为贪心策略的证明（减少逆序对不会使整体结果变差） 范围缩放 证明任何对局部最优策略作用范围的扩展都不会造成整体结果变差 决策包容性 证明任意局面下，做出局部最优决策以后，在问题状态空间中的可达集合包含了做出其他任何决策后的可达集合 换言之，这个局部最优策略提供的可能性包含其他有策略提供的可能性 反证法 数学归纳法 常见的贪心模型 区间问题 区间选点 问题：数轴上选尽可能少的点，使得每个区间内至少有一个点 启发策略：区间按右端点排序，若当前区间包含当前的点，则不加入新点，否则更新新点为右端点 最大不相交区间数量 问题：数轴上有若干区间，选出最大不相交区间 启发策略：与上一个问题等价，右端点排序，若当前区间与正在维护的区间相交，则不选，否则选上当前区间并维护 区间分组 问题：数轴上有若干区间，给这些区间分组，使得每组内不相交 启发策略：区间按左端点排序，若当前所有组中最后一个加入的区间右端点都大于当前区间左端点，则开新组，否则接在最小的后面 区间覆盖 问题：选择尽可能少的区间，覆盖一个线段 启发策略：区间按左端点排序，找出所有左端点在当前已覆盖的区间内，最远的右端点位置，更新已覆盖区间，继续枚举 Huffman 树模型 问题：给出几个带权点，每次可以合并几个点，求最小带权路径长 启发策略：每次选最小的几个点合并 排序不等式 问题：小学奥数的排队打水问题 启发策略：按照时间递增排序 绝对值不等式 详情见“排序”章节 模拟退火 问题：找多峰函数的极值 启发策略：这个内容很多，以后章节会详细讲 基本思路 区间问题的贪心一般都是上来先按左端点或者右端点排序 最大不相交区间数量 和 区间选点本质一样 最大区间厚度问题 区间分组 区间左端点从小到大排序，结束点按右端点小顶堆排序。 证明 = 充分必要证明 不重叠回文子字符串的最大数目 给你一个字符串 s 和一个 正 整数 k 。 从字符串 s 中选出一组满足下述条件且 不重叠 的子字符串： 每个子字符串的长度 至少 为 k 。 每个子字符串是一个 回文串 。 返回最优方案中能选择的子字符串的 最大 数目。 子字符串 是字符串中一个连续的字符序列。 示例 1 ： 输入：s = \"abaccdbbd\", k = 3 输出：2 解释：可以选择 s = \"abaccdbbd\" 中斜体加粗的子字符串。\"aba\" 和 \"dbbd\" 都是回文，且长度至少为 k = 3 。 可以证明，无法选出两个以上的有效子字符串。 示例 2 ： 输入：s = \"adbcda\", k = 2 输出：0 解释：字符串中不存在长度至少为 2 的回文子字符串。 提示： 1 1.区间dp + 区间安排问题（贪心（注意排序规则） 或排序后dp） int g[2010][2010]; vector> vec; class Solution { int sol(vector>& a) { if(a.size() == 0) return 0; int ans = 1; int n = a.size(); sort(a.begin(), a.end(), [](vector& x, vector&y){ if(x[1] == y[1]) return x[0] > y[0]; return x[1] =now_end){ now_end = a[i][1]; len++; } } return len; } public: int maxPalindromes(string s, int k) { int n = s.size(); memset(g, true, sizeof g); for (int i = n - 1; i >= 0; --i) { // 倒序 for (int j = i + 1; j 2. class Solution { public: int maxPalindromes(string s, int k) { int n = s.length(), f[n + 1]; memset(f, 0, sizeof(f)); for (int i = 0; i = 0 && r = k) { f[r + 1] = max(f[r + 1], f[l] + 1); break; } } return f[n]; } }; 防晒 有 C 头奶牛进行日光浴，第 i 头奶牛需要 minSPF[i] 到 maxSPF[i] 单位强度之间的阳光。 每头奶牛在日光浴前必须涂防晒霜，防晒霜有 L 种，涂上第 i 种之后，身体接收到的阳光强度就会稳定为 SPF[i]，第 i 种防晒霜有 cover[i] 瓶。 求最多可以满足多少头奶牛进行日光浴。 算法流程： 将所有奶牛按照 minSPF 从大到小的顺序排序，然后依次考虑每头奶牛； 逆序进行扫描： 对于每头奶牛，扫描当前所有能用的防晒霜，选择 SPF 值最大的防晒霜来用；尽量选取大的用，小的留给后面的奶牛。 对大小为0和1001的进行预处理，方便处理搜索时的边界。 fir(i,1,n) cin>>cows[i-1].first>>cows[i-1].second; fir(i,1,m) {int s,v; cin>>s>>v; spfs[s]+=v;} sort(cows,cows+n); int res=0; spfs[0] = spfs[1001] = n; //设置哨兵是为了 upper_bound不返回空 for(int i=n-1;i>=0;i--){ auto iter = spfs.upper_bound(cows[i].second); iter--; if(iter->first>=cows[i].first){ res++; if(--iter->second==0){ spfs.erase(iter); } } } 畜栏预定 有 N 头牛在畜栏中吃草。 每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。 给定 N 头牛和每头牛开始吃草的时间 A 以及结束吃草的时间 B，每头牛在 [A,B] 这一时间段内都会一直吃草。 当两头牛的吃草区间存在交集时（包括端点），这两头牛不能被安排在同一个畜栏吃草。 求需要的最小畜栏数目和每头牛对应的畜栏方案。 思路：畜栏预定解 (贪心) O(nlognO(nlogn) 算法步骤： 将所有牛按开始吃草的时间排序； 用小根堆维护当前所有畜栏的最后一头牛的吃草结束时间； 如果当前的牛可以安排在堆顶的畜栏中，则将其安排进去，否则就新建一个畜栏； cin>>n; fir(i,1,n){ cin>>cows[i-1].first.first>>cows[i-1].first.second; cows[i-1].second = i-1; // 保留id，用于排序后找到对应关系 } sort(cows,cows+n); priority_queue,greater> heap; // 小顶堆 fir(i,0,n-1){ if(heap.empty()|| heap.top().first>=cows[i].first.first){ PII stall = {cows[i].first.second,heap.size()}; id[cows[i].second]= heap.size(); heap.push(stall); }else{ auto stall = heap.top(); heap.pop(); stall.first = cows[i].first.second; id[cows[i].second]= stall.second; heap.push(stall); } } cout class Solution { public: int minGroups(vector>& intervals) { sort(intervals.begin(), intervals.end()); // 维护一个小根堆表示所有组的结束时间 priority_queue, greater> pq; for (auto &vec : intervals) { // 判断是否存在一组（结束时间最小的组）使得它的结束时间小于当前区间的开始时间 if (!pq.empty() && pq.top() 差分数组： 如果只需要求需要多少个畜栏，则用差分数组即可。 将区间分为最少组数 class Solution { int cnt[1000005]; public: int minGroups(vector>& I) { for(int i=0;i 雷达设备 同LC-用最少数量的箭引爆气球 假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。 每个小岛都位于海洋一侧的某个点上。 雷达装置均位于海岸线上，且雷达的监测范围为 d，当小岛与某雷达的距离不超过 d 时，该小岛可以被雷达覆盖。 我们使用笛卡尔坐标系，定义海岸线为 x 轴，海的一侧在 x 轴上方，陆地一侧在 x 轴下方。 现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。 雷达模型 算法步骤： 将所有区间按右端点从小到大排序； 依次考虑每个区间： 如果当前区间包含最后一个选择的点，则直接跳过； 如果当前区间不包含最后一个选择的点，则在当前区间的右端点的位置选一个新的点； // 把右端点存到pair的第一个元素 方便排序 typedef pair PDD; const int N = 1010; const double eps = 1e-6, INF = 1e10; sort(seg, seg + n); int res = 0; double last = -INF; for (int i = 0; i last + eps) { res ++ ; last = seg[i].first; } } cout 得到回文串的最少操作次数 给你一个只包含小写英文字母的字符串 s 。 每一次 操作 ，你可以选择 s 中两个 相邻 的字符，并将它们交换。 请你返回将 s 变成回文串的 最少操作次数 。 注意 ，输入数据会确保 s 一定能变成一个回文串。 示例 1： 输入：s = \"aabb\" 输出：2 解释： 我们可以将 s 变成 2 个回文串，\"abba\" 和 \"baab\" 。 -我们可以通过 2 次操作得到 \"abba\" ：\"aabb\" -> \"abab\" -> \"abba\" 。 -我们可以通过 2 次操作得到 \"baab\" ：\"aabb\" -> \"abab\" -> \"baab\" 。 因此，得到回文串的最少总操作次数为 2 。 示例 2： 输入：s = \"letelt\" 输出：2 解释： 通过 2 次操作从 s 能得到回文串 \"lettel\" 。 其中一种方法是：\"letelt\" -> \"letetl\" -> \"lettel\" 。 其他回文串比方说 \"tleelt\" 也可以通过 2 次操作得到。 可以证明少于 2 次操作，无法得到回文串。 贪心O(n^2) 数据量不大时可用 由于题目保证原串一定可以变成回文串，那么原串中最多只有一种字母出现奇数次。如果有一种字母出现奇数次，那么将该字母中排在最中间的字符移动到字符串中间，剩下的字符可以转化为所有字母均出现偶数次的情况。 贪心算法是：每次固定字符串最左边的字母 a 不变，找出距离字符串右侧最近的 a，把它交换到字符串最右边。这样字符串的头尾字母就相等了。把字符串的头尾去掉，就变成了子问题。把所有子问题的答案加起来就是最少交换次数。 由于数据范围较小，通过O(n^2) 的模拟即可通过本题。 class Solution { public: int minMovesToMakePalindrome(string s) { int n = s.size(), ans = 0; for (int i = 0, j = n - 1; i O(nlog(n)) 见洛谷 通过双端队列维护每个字母出现的位置，并用树状数组维护哪些位置的字母已经被交换出去。复杂度 (nlogn)。 题集 设置交集大小至少为2 LCP 32. 批量处理任务 同样的题目，见图论的差分约束区间 某实验室计算机待处理任务以 [start,end,period] 格式记于二维数组 tasks，表示完成该任务的时间范围为起始时间 start 至结束时间 end 之间，需要计算机投入 period 的时长，注意： period 可为不连续时间 首尾时间均包含在内 处于开机状态的计算机可同时处理任意多个任务，请返回电脑最少开机多久，可处理完所有任务。 示例 1： 输入：tasks = [ [1,3,2],[2,5,3],[5,6,2] ] 输出：4 解释： tasks[0] 选择时间点 2、3； tasks[1] 选择时间点 2、3、5； tasks[2] 选择时间点 5、6； 因此计算机仅需在时间点 2、3、5、6 四个时刻保持开机即可完成任务。 示例 2： 输入：tasks = [ [2,3,1],[5,5,1],[5,6,2] ] 输出：3 解释： tasks[0] 选择时间点 2 或 3； tasks[1] 选择时间点 5； tasks[2] 选择时间点 5、6； 因此计算机仅需在时间点 2、5、6 或 3、5、6 三个时刻保持开机即可完成任务。 提示： 2 解 1.贪心解 2.差分约束 贪心解 每一个任务对应一个线段。考虑从左到右扫描任务线段端点。如果扫描到某个任务线段的右端点，就看这个任务线段内的开机时间是否足够。够了就不做操作，否则从右端点开始向左逐步填充开机时间。 怎么看开机时间是否足够？考虑把任务线段端点离散化，然后用树状数组查询。 怎么看从右端点开始向左逐步填充开机时间？考虑所有的线段端点排序后，相邻端点构成的小线段。从右端点开始，向左依次枚举没有装满开机时间的小线段，然后试图向其加满时间，直到该任务时间够为止。 查找左边最近的没有装满的小线段可以用并查集实现。如果一个小线段装满了，就将其 parent 设置为其左边相邻的小线段的 parent。 时间复杂度为 O(n(logn+logm)+m)，其中 n 为任务个数，m 为离散化后端点个数。 class Solution { pair pp[200005]; unordered_map mp; int lis[200005]; int cap[200005], filled[200005]; int c[200005], mm; inline int lowbit(int x){ return x & (-x); } void add(int k, int x){ while (k 0) res += c[r], r -= lowbit(r); return res; } int fa[200005]; int Find(int x){ return (x == fa[x] ? x: (fa[x] = Find(fa[x]))); } public: int processTasks(vector>& tasks) { int tot = 0, n = tasks.size(); // 离散化 for (int i = 1; i = tasks[id][2]) continue; int pos = fa[rbid - 1]; int need = tasks[id][2] - res; // 逐步装入开机时间 for (; ; ){ int left = cap[pos] - filled[pos]; if (left > need){ filled[pos] += need; add(pos, need); break; } else if (left == need){ filled[pos] += need; add(pos, need); fa[pos] = fa[pos - 1]; break; } else { filled[pos] += left; need -= left; add(pos, left); fa[pos] = fa[pos - 1]; pos = Find(pos); } } } } return qu(mm); } }; 差分约束 typedef long long ll; const ll INF = 1ll mp; void init(ll x = -INF, ll y = 0) { mp.clear(); mp[x] = y; } ll query(ll x) { auto cur = mp.upper_bound(x); cur--; return cur->second; } void insert(ll x, ll y) { if (query(x) >= y) return ; for (auto cur = mp.lower_bound(x), pre = cur; cur != mp.end() && cur->second >& tasks) { sort(tasks.begin(), tasks.end()); P.init(); Q.init(-INF, -INF); for (auto &t : tasks) { ll x_p = t[0], x_q = t[1] + 1; ll y_p = max(P.query(x_p), x_p + Q.query(-x_p)), y_q = y_p + t[2]; P.insert(x_q, y_q); Q.insert(-x_q, y_q - x_q); } return P.query(INF); } }; 匈牙利算法 Hungarian Algorithm 另见：图论中二分图部分 相关关键词： 二分图、匹配、最大匹配、交错路径、增广路径 Article:匈牙利算法与增广路径 Article:匈牙利算法 Article:趣写算法系列之--匈牙利算法 关键思想：有机会上，没机会创造机会也要上。先到先得，后到的能抢则抢 bool find(int x){ int i,j; for (j=1;j 题集： Hard：按要求补齐数组 给定一个已排序的正整数数组 nums ，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。 请返回 满足上述要求的最少需要补充的数字个数 。 示例 1: 输入: nums = [1,3], n = 6 输出: 1 解释: 根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。 现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。 其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。 所以我们最少需要添加一个数字。 示例 2: 输入: nums = [1,5,10], n = 20 输出: 2 解释: 我们需要添加 [2,4]。 示例 3: 输入: nums = [1,2,2], n = 5 输出: 0 提示： 1 解： class Solution{ //只需要根据当前缺失的数leak和nums中是否有比leak小且未使用过的数确定下一个缺失的数leak即可 public: int minPatches(vector& nums, int n){ int ans = 0, idx = 0; long long leak = 1; //缺失的数 while(leak 最多可以参加的会议数目 给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。 你可以在满足 startDayi 解：贪心 const int MAX = 1e5 + 1; class Solution { public: int maxEvents(vector>& events) { vector> left(MAX); for (int i = 0; i , greater<>> pq; for (int i = 1; i 课程表 III 这里有 n 门不同的在线课程，按从 1 到 n 编号。给你一个数组 courses ，其中 courses[i] = [durationi, lastDayi] 表示第 i 门课将会 持续 上 durationi 天课，并且必须在不晚于 lastDayi 的时候完成。 你的学期从第 1 天开始。且不能同时修读两门及两门以上的课程。 返回你最多可以修读的课程数目。 示例 1： 输入：courses = [ [100, 200], [200, 1300], [1000, 1250], [2000, 3200] ] 输出：3 解释： 这里一共有 4 门课程，但是你最多可以修 3 门： 首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。 第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。 第三，修第 2 门课，耗时 200 天，在第 1300 天完成。 第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。 示例 2： 输入：courses = [ [1,2] ] 输出：1 示例 3： 输入：courses = [ [3,2],[4,3] ] 输出：0 提示: 1 解： class Solution { public: int scheduleCourse(vector>& courses) { sort(courses.begin(), courses.end(), [](const auto& c0, const auto& c1) { return c0[1] q; // 优先队列中所有课程的总时间 int total = 0; for (const auto& course: courses) { int ti = course[0], di = course[1]; if (total + ti ti) { total -= q.top() - ti; q.pop(); q.push(ti); } } return q.size(); } }; 最小区间 你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中。 我们定义如果 b-a 解： 1.贪心+堆 class Solution { public: vector smallestRange(vector>& nums) { int rangeLeft = 0, rangeRight = INT_MAX; int size = nums.size(); vector next(size); auto cmp = [&](const int& u, const int& v) { return nums[u][next[u]] > nums[v][next[v]]; }; priority_queue, decltype(cmp)> pq(cmp); int minValue = 0, maxValue = INT_MIN; for (int i = 0; i 2.滑动窗口 可参考最小覆盖子串 class Solution { public: vector smallestRange(vector>& nums) { vector> ordered; // (number, group) for (size_t k = 0; k ans; unordered_map count; for (size_t j = 0; j 1) --count[ordered[i++].second]; // minialize range if (ans.empty() || ans[1] - ans[0] > ordered[j].first - ordered[i].first) { ans = vector{ordered[i].first, ordered[j].first}; } } } return ans; } }; 8 双指针 类型 从头开始、一个快 一个慢 从头开始、一个前 一个后 for (int i = 0, j = 0; i 一个从头开始、一个从尾开始 两段区间，各一个 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 同样地，快排，归并，以及kmp均用到了该思想。 如 常见问题 划分单词 mbfgdc 输出单词\"abc ab a c\" 提取出abc,ab,a,c... string str = \"...\"; int n = str.size(); for(int i = 0; i 多种字符分隔 #include string input; char* sp = \" !\"; char* token; token = strtok((char*)input.c_str(), sp); while( token != NULL ) { string t(token); // token = strtok(NULL, sp); } 最长不重复区间 最长不重复区间：给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。#include using namespace std; const int N = 100010; int q[N],s[N]; int main() { int n; cin>>n; for(int i=0;i>q[i]; int res = 0; for(int i=0,j=0;i1) s[q[j++]]--; // 更新数量 并移动左端点 res = max(res,i-j+1); } cout 判断子序列 判断子序列：给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。 请你判断 a 序列是否为 b 序列的子序列。 子序列指序列的一部分项按原有次序排列而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。 #include #include using namespace std; const int N = 100010; int n, m; int a[N], b[N]; int main() { scanf(\"%d%d\", &n, &m); for (int i = 0; i 给定两个**升序**排序的有序数组 A 和 B，以及一个目标值 x。数组下标从 0 开始。 请你求出满足 A[i]+B[j] = x 的数对 (i,j)。数据保证有唯一解。#include using namespace std; const int N = 1e5 + 10; int n, m, x; int a[N], b[N]; int main() { scanf(\"%d%d%d\", &n, &m, &x); for (int i = 0; i = 0 && a[i] + b[j] > x) j -- ; if (j >= 0 && a[i] + b[j] == x) cout ACwing周赛C最大子矩阵 同CF题C. Maximum Subrectangle 给定一个长度为 n 的整数数组 a1,a2,…,an 和一个长度为 m 的整数数组 b1,b2,…,bm。 设 c 是一个 n×m 的矩阵，其中 ci,j=ai×bj。 请你找到矩阵 c 的一个子矩阵，要求：该子矩阵所包含的所有元素之和不超过 x，并且其面积（包含元素的数量）应尽可能大。 输出满足条件的子矩阵的最大可能面积（即包含元素的最大可能数量）。 所有测试点满足 1≤n,m≤2000，1≤ai,bi≤2000，1≤x≤2×109。 #include #include #include using namespace std; const int N = 2010, INF = 1e8; int n, m, X; int s1[N], s2[N]; int a[N], b[N]; int main() { scanf(\"%d%d\", &n, &m); for (int i = 1; i X / a[i]) j -- ; res = max(res, i * j); } printf(\"%d\\n\", res); return 0; } 快慢指针 用途 解决链表问题 获取倒数第k个元素 获取中间位置的元素 判断链表是否存在环 判断环的长度等和长度与位置有关 判断重复数 Floyd 判圈算法（龟兔赛跑问题） 用途 检测链表是否有环 使用两个指针， fast 与 slow 。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。 如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc。 根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的2 倍。因此，我们有 a+(n+1)b+nc=2(a+b) \\implies a=c+(n-1)(b+c) 有了 a=c+(n-1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。 因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和slow 每次向后移动一个位置。最终，它们会在入环点相遇。 精简版： slow * 2 = fast slow = a + b fast = a + b + c + b = a + 2*b + c (a + b)*2 = a + 2*b + c a = c 快针走的是慢针的两倍。 慢针走过的路，快针走过一遍。 快针走过的剩余路程，也就是和慢针走过的全部路程相等。(a+b = c+b) 刨去快针追赶慢针的半圈(b)，剩余路程即为所求入环距离(a=c) 剖析 Q:为何慢指针第一圈走不完一定会和快指针相遇： 思路一：首先，第一步，快指针先进入环 第二步：当慢指针刚到达环的入口时，快指针此时在环中的某个位置(也可能此时相遇) 第三步：设此时快指针和慢指针距离为x，若在第二步相遇，则x = 0； 第四步：设环的周长为n，那么看成快指针追赶慢指针，需要追赶n-x； 第五步：快指针每次都追赶慢指针1个单位，设慢指针速度1/s，快指针2/s，那么追赶需要(n-x)s 第六步：在n-x秒内，慢指针走了n-x单位，因为x>=0，则慢指针走的路程小于等于n，即走不完一圈就和快指针相遇 思路二：从相对运动的角度去考虑，这一刻开始快慢指针都在环内运动，但快指针每次比慢指针快一个节点，相当于慢指针在当前位置不动，快指针每次移动一个节点去追赶 总结 // 快慢指针找环入口，分两步走 // 1.找到相遇点：各自走直到相遇(最初都在head，而不能把快指针先走一步(这样能判断环，但不能找入口？)) // 2.找入口点：此时用一慢指针从起点开始再和慢指针相遇 注意 要不要让快指针先移动一步。最好不要(为了找入口)。如不先移动，可使用do{}while(),或者while(true){ if(fast == last){ ...; break;} }; 若先移动，可使用while(){} 环形链表 II-官方解析 环形链表 II（双指针法，清晰图解） E-环形链表 // 给定一个链表，判断链表中是否有环。 bool hasCycle(ListNode* head) { if (head == nullptr || head->next == nullptr) { return false; } ListNode* slow = head; ListNode* fast = head->next; while (slow != fast) { if (fast == nullptr || fast->next == nullptr) { return false; } slow = slow->next; fast = fast->next->next; } return true; } M-环形链表 II ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (fast != nullptr) { slow = slow->next; if (fast->next == nullptr) { return nullptr; } fast = fast->next->next; if (fast == slow) { ListNode *ptr = head; while (ptr != slow) { ptr = ptr->next; slow = slow->next; } return ptr; } } return nullptr; } M-寻找重复数 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。 要求：不修改数组 nums 且只用常量级 O(1) 的额外空间。 // 1. 二分 抽屉原理 int findDuplicate(vector& nums) { int n=nums.size(); int l=1,r=n-1,ans=-1; while(l>1; int cnt=0; for(int i=0;i& nums) { int slow = 0, fast = 0; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = 0; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; } 滑动窗口 最小覆盖子串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1： 输入：s = \"ADOBECODEBANC\", t = \"ABC\" 输出：\"BANC\" 示例 2： 输入：s = \"a\", t = \"a\" 输出：\"a\" 示例 3: 输入: s = \"a\", t = \"aa\" 输出: \"\" 解释: t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。 class Solution { public: // 滑动窗口 time: O(n) space: O(1) string minWindow(string s, string t) { vector sub = {0, INT_MAX}; // 记录最短覆盖子串的下标，sub[0]表示起始下标，sub[1]表示子串长度 int need[128] = {0}, have[128] = {0};// 分别记录需要覆盖的字母个数和当前窗口内字串包含的字母个数 int toMatch = 0; // 表示当前窗口还需要匹配多少种字母，例如t=\"abbc\", 则toMatch=3，当toMatch=0时表示已经覆盖字串 int l = 0, r = 0; for (auto c : t) { // 遍历待覆盖子串，记录需要覆盖的字母个数toMatch和每个字母的个数need[c] if (need[c] == 0) toMatch++; need[c]++; } while (r 0) { // 不断向右扩展窗口，直到到达字符串末尾或者成功覆盖子串(toMatch == 0)，r最终停留在s.size()或者当前窗口字符串末尾字母的下一位置 if (++have[s[r]] == need[s[r]]) toMatch--; // 更新窗口内字母个数，当某个字母达到需要的个数时，将toMatch减一 r++; } // 如果此时剩余待覆盖字母个数为0，表明已经成功覆盖字符串t，但是此时窗口内的字符串不一定是最短的覆盖子串 // 如果此时剩余待覆盖字母个数大于0，则表明不存在覆盖子串，此时r == s.size()，之后会跳出循环 while (toMatch == 0) { // 不断向右收缩窗口，直到无法覆盖子串(toMatch>0)，l最终等于0（即不存在覆盖子串，toMatch > 0）或者当前最短覆盖字串起始字母的下一位置（此时toMatch == 1） if (--have[s[l]] 9 分治 其他相关 如 多路归并，见归并部分。 袭击 解析： 先从一种类型的距离开始 做，然后 考虑 两种类型。 其中有一个关键点，利用抽屉原理可得知 每处理一个左边的点时，右边最多只会有 66 个点被考虑到 Article:解答 将规模减小 Hard：寻找两个正序数组的中位数 (思路类似找第k小数（快排）) 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 class Solution { public: double findMedianSortedArrays(vector& nums1, vector& nums2) { int m = nums1.size(), n = nums2.size(); int left = m + n + 1 >> 1, right = m + n + 2 >> 1; // + 1, + 2 return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; } int findKth(vector& nums1, int i, vector& nums2, int j, int k){ if(i >= nums1.size()) return nums2[j + k - 1]; if(j >= nums2.size()) return nums1[i + k - 1]; if(k == 1) return min(nums1[i], nums2[j]); int midv1 = (i + k / 2 - 1 Hard：特殊的二进制序列 特殊的二进制序列是具有以下两个性质的二进制序列： 0 的数量与 1 的数量相等。 二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。 给定一个特殊的二进制序列 S，以字符串形式表示。定义一个操作 为首先选择 S 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。) 在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？ 示例 1: 输入: S = \"11011000\" 输出: \"11100100\" 解释: 将子串 \"10\" （在S[1]出现） 和 \"1100\" （在S[3]出现）进行交换。 这是在进行若干次操作后按字典序排列最大的结果。 说明: S 的长度不超过 50。 S 保证为一个满足上述定义的特殊 的二进制序列。 class Solution { public: string makeLargestSpecial(string s) { if (s.size() subs; for (int i = 0; i {}); string ans = accumulate(subs.begin(), subs.end(), \"\"s); return ans; } }; 10 高精度 面试时常考 四种类型 - A+B： 计算时可对A、B的**位数**大小进行判断 *最后判断是否进位* - A-B： 计算时需要对A、B的**大小**进行判断 *最后判断是否有前导零* - A*b： 计算时把b看成**整体**，用A的每一位与其相乘 *最后判断是否有前导零* - A*B：先A[i]*B[j] 放到C[i + j]上，再将进位转移即可 - A/b： 从A的size()-1开始，然后**反转** *最后判断是否有前导零* *大写表示大数，小写表示一个比较小的数,且AB均为正数* 存储 大整数的存储：用一个数组来存大整数的每一位上的数。 这里将大整数的个位，存到数组的第一位，大整数的最高位，存到数组的最后一位，即采用小端序。 对于 A = 123456789，用数组a的索引0表示A的个位数。以此类推... 目的为了进位和借位的考虑。 高精度加法 高精度加法 A + B 高精度加法的流程，就是模拟人手动做加法的过程，将每一位依次相加，并带上前一位的进位。 // 类似于小端序，个数存到数组开头 // C = A + B, A >= 0, B >= 0 vector add(vector &A, vector &B) { if (A.size() C; int t = 0; for (int i = 0; i 高精度减法 模板题 AcWing 792. 高精度减法 A - B 先判断一下A和B的相对大小（比较时先比长度，长度相等比较同一位，注意顺序)，若 A >= B，则直接计算减法 A // 判断AB大小 是否有A >=B bool cmp(vector& A,vector& B) { if(A.size()!=B.size()) return A.size()>B.size(); for(int i = A.size()-1;i>=0;i--){ if(A[i]!=B[i]) return A[i]>B[i]; } return true; } // C = A - B, 满足A >= B, A >= 0, B >= 0 vector sub(vector &A, vector &B) { vector C; for (int i = 0, t = 0; i 1 && C.back() == 0) C.pop_back(); return C; } // 调用 // a = \"123456\" A = [6,5,4,3,2,1]; if(cmp(A,B)) { auto C = sub(A,B); for(int i=C.size()-1;i>=0;i--) printf(\"%d\",C[i]); }else{ auto C = sub(B,A); cout=0;i--) printf(\"%d\",C[i]); } 高精度乘低精度 模板题 AcWing 793. 高精度乘法 A × b 把b看成一个整体，和A的每一位去做乘法。例如：123 × 12。 首先从A的最低位开始，计算3 × 12，得36，则结果中的个位为：36 % 10 = 6，产生的进位为36 / 10 = 3；继续下一位，计算2 × 12，得24，加上进位3，得27，结果中的十位为：27 % 10 = 7，产生的进位是27 / 10 = 2；继续下一位，1 × 12 + 2 = 14，则百位上的结果为14 % 10 = 4，产生进位14 / 10 = 1，则最终结果为1476。 // C = A * b, A >= 0, b >= 0 vector mul(vector &A, int b) { vector C; int t = 0; for (int i = 0; i 1 && C.back() == 0) C.pop_back(); return C; } 拓展： 高精度 X 高精度 A * B #include #include using namespace std; vector mul(vector &A, vector &B) { vector C(A.size() + B.size(), 0); // 初始化为 0，且999*99最多 5 位 for (int i = 0; i 1 && C.back() == 0) C.pop_back(); // 必须要去前导 0，因为最高位很可能是 0 return C; } int main() { string a, b; cin >> a >> b; // a = \"1222323\", b = \"2323423423\" vector A, B; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); auto C = mul(A, B); for (int i = C.size() - 1; i >= 0; i--) cout 高精度除以低精度 AcWing 794. 高精度除法 A / b 算法的流程，是模拟人手动做除法的流程。从最高位除起，依次做商和取余。每一轮的余数，乘以10，加上下一位的数，作为下一轮的被除数。 // A / b = C ... r, A >= 0, b > 0 vector div(vector &A, int b, int &r) { // a =\"1234\" A=[4,3,2,1] 下面计算时把A再倒过来(A的存储为与其他计算统一格式) vector C; r = 0; for (int i = A.size() - 1; i >= 0; i -- ) // 注意顺序 { r = r * 10 + A[i]; // 相当于 一步步还原 一步步计算 C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); // 把C变成A的表示形式... while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } 11 正则表达式 正则表达式匹配？？？ 解:正则表达式匹配 class Solution { public: bool isMatch(string s, string p) { int m = s.size(); int n = p.size(); auto matches = [&](int i, int j) { if (i == 0) { return false; } if (p[j - 1] == '.') { return true; } return s[i - 1] == p[j - 1]; }; vector> f(m + 1, vector(n + 1)); f[0][0] = true; for (int i = 0; i 有效数字 正则表达式 //用正则表达式解决，c++ 用正则表达式记得作为类的静态变量或全局变量，避免重复构造的开销，否则会超时。 class Solution { public: static const regex pattern; bool isNumber(string str) { return regex_match(str, pattern); } }; const regex Solution::pattern(\"[+-]?(?:\\\\d+\\\\.?\\\\d*|\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?\"); 有限状态机 class Solution { public: bool isNumber(string s) { if(s.empty()) return false; int n = s.size(); int state = 0; vector finals({0, 0, 0, 1, 0, 1, 1, 0, 1}); // 合法的终止状态 vector > transfer({ {0, 1, 6, 2, -1, -1}, {-1, -1, 6, 2, -1, -1}, {-1, -1, 3, -1, -1, -1}, {8, -1, 3, -1, 4, -1}, {-1, 7, 5, -1, -1, -1}, {8, -1, 5, -1, -1, -1}, {8, -1, 6, 3, 4, -1}, {-1, -1, 5, -1, -1, -1}, {8, -1, -1, -1, -1, -1}, }); for(int i = 0; i = '0' && c 12 启发式合并 13 最小表示法 14 构造 15 打表 16 其他 摩尔投票 主要元素 数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。 示例 1： 输入：[1,2,5,9,5,9,5,5,5] 输出：5 示例 2： 输入：[3,2] 输出：-1 示例 3： 输入：[2,2,1,1,1,2,2] 输出：2 解：Boyer-Moore 投票算法 class Solution { public: int majorityElement(vector& nums) { int alive = 0; int n = nums.size(); int teambest = -1; for(auto num : nums){ //若当前无人生还，跟踪下一位士兵的势力 if(!alive) teambest = num; //下一位士兵是自己人，那么幸存人数++ if(num == teambest) alive ++; //来了个敌人，同归于尽，幸存人数-- else alive--; } if(! alive) return -1; int count = 0; for(auto num:nums) if(num == teambest) count ++; return count > n / 2 ? teambest : - 1; } }; Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-12-19 14:42:05 "},"01_数据结构与算法笔记/01_学习笔记/01_基本数据结构.html":{"url":"01_数据结构与算法笔记/01_学习笔记/01_基本数据结构.html","title":"1.1 基本数据结构","keywords":"","body":"基本数据结构 1 栈 // c++实现 // tt表示栈顶 int stk[N], tt = 0; // 或 tt = -1 // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt > 0) // 或 tt >=0 { } 最长有效括号？？？ 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 输入：s = \"(()\" 输出：2 解释：最长有效括号子串是 \"()\" 示例 2： 输入：s = \")()())\" 输出：4 解释：最长有效括号子串是 \"()()\" 示例 3： 输入：s = \"\" 输出：0 1 动态规划 class Solution { public: int longestValidParentheses(string s) { int maxans = 0, n = s.length(); vector dp(n, 0); for (int i = 1; i = 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') { dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = max(maxans, dp[i]); } } return maxans; } }; 2 栈 class Solution { public: int longestValidParentheses(string s) { int m=0; stack sk; sk.push(-1); for(int i=0;i 美化数组的最少删除数 给你一个下标从 0 开始的整数数组 nums ，如果满足下述条件，则认为数组 nums 是一个 美丽数组 ： nums.length 为偶数 对所有满足 i % 2 == 0 的下标 i ，nums[i] != nums[i + 1] 均成立 注意，空数组同样认为是美丽数组。 你可以从 nums 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 不变 。 返回使 nums 变为美丽数组所需删除的 最少 元素数目。 示例 1： 输入：nums = [1,1,2,3,5] 输出：1 解释：可以删除 nums[0] 或 nums[1] ，这样得到的 nums = [1,2,3,5] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。 示例 2： 输入：nums = [1,1,2,2,3,3] 输出：2 解释：可以删除 nums[0] 和 nums[5] ，这样得到的 nums = [1,2,2,3] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。 思路： 遍历数组，用栈来模拟这个过程（实际不需要栈，后面会说明）： 如果栈大小为偶数，可以随意加入元素； 如果栈大小为奇数，那么加入的元素不能和栈顶相同。 遍历结束后，若栈大小为奇数，则移除栈顶。 最后栈大小就是保留的元素，用数组大小减去栈大小就是删除的元素个数。 实际上不需要栈，用一个变量表示栈的奇偶性即可。 class Solution { public: int minDeletion(vector& nums) { int flag = 1, last = nums[0], ans = 0; for(int i = 1; i 两个栈维护信息 栈实现浏览器的前进和后退功能 一 概述 当你一次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面b和a。当你后退到页面a，点击前进按钮，就可以重新查看页面b和c。但是，如果你后退到页面b后，点击了新的页面d，那就无法再前继，后退功能查看页面c了。 二 栈 栈是一种操作特性上来看，栈是一种\"操作受限\"的线性表，只允许在一端插入和删除数据。当从这种功能上来说，数组或者链表确实可以替代栈，可是特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。 当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出，先进后出的特性，我们就应该首选\"栈\"这种数据结构。 三 栈的实现 从栈的定义上来看，栈主要包括两个操作，出栈和入栈，也就是在栈顶插入一个数据和栈顶删除一个数据。理解了栈的定义之后，我们来看看如何用代码实现一个栈。 实际上，栈既可以用数组来实现，也可以用链表来实现。用数组来实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。 不管是顺序表还是链式表，我们存储数据只需要一个大小为n的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)。 支持动态扩容的顺序栈 基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要实现指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小受限，但要存储next指针，内存消耗相对较多。 根据动态扩容的数组，当数组空间不够时，我们就重新申请一块更大的内存，将原来数组汇总数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。 如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了以后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。 支持动态扩容的顺序栈的入栈，出栈操作的时间复杂度 入栈：对于入栈而言，最好情况时间复杂度为O(1)，最坏情况时间复杂度时O(n)。对于栈的分析需要从这几点都是可以考虑的。 栈空间不够时，我们重新申请一个是原来大小两倍的数组； 为了简化分析，假设只有入栈操作没有出栈操作； 定义不涉及内存搬移的入栈操作为simple-push操作，时间复杂度为O(1)。 如果当前栈大小为K，并且已满，当再有新的数据要入栈时，就需要重新申请2倍大小的内存，并且做K个数据的搬移操作，然后再入栈。但是，接下来的K-1次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这K-1次入栈操作都需要一个simple-push操作就可以完成 在K次入栈操作，总共涉及了K个数据的搬移，以及K次simple-push操作。将K个数据搬移均摊到k次入栈操作，那每次入栈操作只需要一个数据搬移和一个simple-push操作。所以均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度均为O(1)，只有在个别时刻才会退化为O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近O(1)。 出栈：对于出栈操作不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是O(1)。但是，对于入栈操作而言，情况就不一样。当栈中空闲空间时，入栈操作的时间复杂度为O(1)。但当空间不够时，就需要重新申请内存和数据搬移，数据搬移时的时间复杂度为O(n)。 四 栈在函数中的应用 在软件工程中的实际应用中，栈作为一个比较基础的数据结构，应用场景还是蛮多的，其中，比较经典的应用场景就是函数调用栈。 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成\"栈\"这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。 五 栈实现浏览器的前进和后退功能 其实我们可以通过两个栈，X和Y，我们把首次浏览的页面依次压入栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当我们点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，那就说明没有页面可以继续后退浏览了，同理，当栈Y中没有数据，那就说明没有页面可以再点击前进按钮浏览了。 总结： 两个栈来维护，X Y,每次拿出栈顶时判断是否为空 1.浏览新的进栈X，(如果此时在后退状态，则需要清空 Y) 2.后退从X拿出栈顶 放进Y 3.前进从Y拿出栈顶 放进X 比如你顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈，这个时候，两个栈的数据就是这个样子： X: a b c Y: 当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子： X: a Y: c b 这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子： X: a b Y: c 这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子： X: a b d Y: 六 栈保存临时变量的原因 再函数调用的过程中，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符号后进先出的特性，用栈这种数据结构来实现，是顺理成章的选择。 从函数调用进入被调用函数，对于数据来说，变化的是作用域，所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。 七 内存中堆栈和数据结构中的堆栈 内存中的堆栈和数据结构不是同一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。 单调栈 常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i 2 队列 // c++实现 // 普通队列 // hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空 if (hh 定义时的区别 特性 队列 循环队列 hh 队头 =0 队头 =0 tt 队尾 = -1 队尾的后一个位置 = 0 向队尾添加 q[++ tt] = q[tt ++] = 判断非空 hh hh != tt 其他 无 tt == N 时 令 tt= 0 ，hh == N 时 令 hh = 0 1 2 3 1 2 3 1 2 3 单调队列 应用详见 动态规划部分中的单调队列优化DP。 对比 单调队列和优先队列 单调队列是一种算法，在队列使用的过程中满足单调性质，用于解决一类特定的问题，最典型的就是滑动窗口的最大值，它在一类背包问题里也有应用。类似的还有单调栈：在栈使用的过程中，保证一种单调性。这两种算法其实都是依托于特定的问题场景的。 优先队列的应用就特别广泛了。用于解决需要动态求出当前最大或者最小值的问题，与普通队列不同的是，优先队列中的元素被赋予了优先级，在出队的时候按照指定的优先级规则出队。 模板 常见模型：找出滑动窗口中的最大值/最小值 O(n) （还可以用树状数组做 见树状数组部分） int q[N], hh = 0, tt = -1; for (int i = 0; i 例题：滑动窗口 思路： 最小值和最大值分开来做，两个for循环完全类似，都做以下四步： 1 解决队首已经出窗口的问题; 2 解决队尾与当前元素a[i]不满足单调性的问题; 3 将当前元素下标加入队尾; 4 如果满足条件则输出结果; 需要注意的细节： 1 上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素; 2 队列中存的是原数组的下标，取值时要再套一层，a[q[]]; 3 算最大值前注意将hh和tt重置; 4 此题用cout会超时，只能用printf; 5 hh从0开始，数组下标也要从0开始 重点 如求最小值，从左向右遍历，用一个队列来维护最近 k 个元素；如果队列中存在两个元素，满足 a[i] >= a[j] 且 i # include using namespace std; const int N = 1000010; int a[N], q[N], hh, tt = -1; int main() { int n, k; cin >> n >> k; // 因为求最值，维护(严格和不严格都行)单调就行，只要是最值，且在区间内，不关心具体是哪一个 for (int i = 0; i q[hh]) ++ hh; // 若队首出窗口，hh加1 while (hh = k) printf(\"%d \", a[q[hh]]); // 输出结果 } cout q[hh]) ++ hh; while (hh = a[q[tt]]) -- tt; q[++ tt] = i; if (i + 1 >= k) printf(\"%d \", a[q[hh]]); } return 0; } 题集 力扣：单调队列专题 更详细的应用 见 基本数据结构部分中的单调队列优化。 以及 多重背包的单调队列优化。 3 链表与邻接表 单链表 //c++实现 // head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } 双链表 //c++实现 // e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } 力扣链表 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ 计算长度 int getLength(ListNode* head) { int ret = 0; for (; head != nullptr; ++ret, head = head->next); return ret; } 链表反转 反转全部 方法一：迭代 假设链表为$ 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow \\varnothing $，我们想要把它改成$ \\varnothing \\leftarrow 1 \\leftarrow 2 \\leftarrow 3$ 在遍历链表时，将当前节点的 $\\textit{next}$ 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; while(curr){ ListNode* next = curr->next; //不着急把next的next设置好 在下一个循环中操作即可 curr->next = prev; prev = curr; curr = next; } // 最后curr为空了 return prev; } }; 方法二：递归 递归版本稍微复杂一些，其关键在于反向工作。假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？ class Solution { public: ListNode* reverseList(ListNode* head) { if (!head || !head->next) { return head; } ListNode* newHead = reverseList(head->next); head->next->next = head; head->next = nullptr; // ！！！要置空 否则成环 return newHead; } }; 反转部分 M-反转链表 II 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left 思路：Article:官方解答：头插法 整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。下面的图展示了整个流程。 使用三个指针变量 pre、curr、nxt 来记录反转的过程中需要的变量，它们的意义如下： curr：指向待反转区域的第一个节点 left； next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 nxt 会变化； pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。 操作步骤： 先将 curr 的下一个节点记录为 next； 执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点； 执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点； 执行操作 ③：把 pre 的下一个节点指向 next // 一次遍历「穿针引线」反转链表（头插法） // 以上图为例，m = 3，n=7 ListNode* reverseBetween(ListNode* head, int m, int n) { if(m>n)return head; ListNode* HEAD=new ListNode(0,head); ListNode* pre=HEAD, *nxt; for(int i=1;inext; } ListNode* curr=pre->next; for(int i=m;inext; // curr->next=nxt->next; // ① nxt->next=pre->next; // ② 用的是pre->next而不是curr pre->next=nxt; // ③ } return HEAD->next; } 合并链表 合并两个有序链表 class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* HEAD = new ListNode(0); ListNode* cur = HEAD; while(list1 || list2){ if(list1 && list2){ if(list1->val val){ cur->next = new ListNode(list1->val); list1 = list1->next; }else{ cur->next = new ListNode(list2->val); list2 = list2->next; } }else if(list1){ cur->next = new ListNode(list1->val); list1 = list1->next; }else{ cur->next = new ListNode(list2->val); list2 = list2->next; } cur = cur->next; } return HEAD->next; } }; 合并K个升序链表 优先队列 class Solution { public: struct comp { bool operator()(ListNode* a, ListNode* b) { return a->val > b->val; } }; priority_queue, comp> q; ListNode* mergeKLists(vector& lists) { for (auto node: lists) { if (node) q.push(node); } ListNode* head = new ListNode(); ListNode* tail = head; while (!q.empty()) { ListNode* node = q.top(); q.pop(); tail->next = node; tail = tail->next; if (node->next) q.push(node->next); } return head->next; } }; 分治归并 class Solution { public: ListNode* mergeTwoLists(ListNode *a, ListNode *b) { if ((!a) || (!b)) return a ? a : b; ListNode head, *tail = &head, *aPtr = a, *bPtr = b; // 或ListNode head = new ListNode(0), * tail; // tail = head; return head->next; while (aPtr && bPtr) { if (aPtr->val val) { tail->next = aPtr; aPtr = aPtr->next; } else { tail->next = bPtr; bPtr = bPtr->next; } tail = tail->next; } tail->next = (aPtr ? aPtr : bPtr); return head.next; } ListNode* merge(vector &lists, int l, int r) { if (l == r) return lists[l]; if (l > r) return nullptr; int mid = (l + r) >> 1; return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r)); } ListNode* mergeKLists(vector& lists) { return merge(lists, 0, lists.size() - 1); } }; 操作节点 删除节点 删除链表的倒数第 N 个结点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 注意输出第一个节点(以及考虑最后一个节点)class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(0, head); ListNode *pre=head,*cur=dummy; while(n--){ pre=pre->next; } while(pre){ pre=pre->next; cur=cur->next; } cur->next=cur->next->next; ListNode *ans=dummy->next; delete dummy; return ans; } }; 删除排序链表中的重复元素 II 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。 输入：head = [1,2,3,3,4,4,5] 输出：[1,2,5] 遍历 ```c++class Solution { public: ListNode deleteDuplicates(ListNode head) { if (!head) { return head; } ListNode* dummy = new ListNode(0, head); ListNode* cur = dummy; while (cur->next && cur->next->next) { if (cur->next->val == cur->next->next->val) { int x = cur->next->val; while (cur->next && cur->next->val == x) { cur->next = cur->next->next; } } else { cur = cur->next; } } return dummy->next; } }; - **递归** - 1.1 递归函数定义 递归最基本的是要明白递归函数的定义！ 我反复强调过这一点。 递归函数直接使用题目给出的函数 deleteDuplicates(head) ，它的含义是 删除以 head 作为开头的有序链表中，值出现重复的节点。 - 1.2 递归终止条件 终止条件就是能想到的基本的、不用继续递归处理的case。 如果 head 为空，那么肯定没有值出现重复的节点，直接返回 head； 如果 head.next 为空，那么说明链表中只有一个节点，也没有值出现重复的节点，也直接返回 head。 - 1.3 递归调用 什么时候需要递归呢？我们想一下这两种情况： - 如果 head.val != head.next.val ，说明头节点的值不等于下一个节点的值，所以当前的 head 节点必须保留；但是 head.next 节点要不要保留呢？我们还不知道，需要对 head.next 进行递归，即对 head.next 作为头节点的链表，去除值重复的节点。所以 head.next = self.deleteDuplicates(head.next). - 如果 head.val == head.next.val ，说明头节点的值等于下一个节点的值，所以当前的 head 节点必须删除，并且 head 之后所有与 head.val 相等的节点也都需要删除；删除到哪个节点为止呢？需要用 move 指针一直向后遍历寻找到与 head.val 不等的节点。此时 move 之前的节点都不保留了，因此返回 deleteDuplicates(move); - 1.4 返回结果 题目让我们返回删除了值重复的节点后剩余的链表，结合上面两种递归调用的情况。 如果 head.val != head.next.val ，头结点需要保留，因此返回的是 head； 如果 head.val == head.next.val ，头结点需要删除，需要返回的是deleteDuplicates(move); ![](./assets/链表删除相同元素.jpg) ```c++ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (!head || !head->next) { return head; } if (head->val != head->next->val) { head->next = deleteDuplicates(head->next); } else { ListNode* move = head->next; while (move && head->val == move->val) { move = move->next; } return deleteDuplicates(move); } return head; } }; 删除特定值的节点 移除链表元素 新建表class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* res = new ListNode(0, nullptr); ListNode* dum = res; while(head){ if(head->val != val){ dum->next = new ListNode(head->val); dum = dum->next; } head = head->next; } return res->next; } }; 迭代 ```c++ ListNode removeElements(ListNode head,int val){ if(!head)return nullptr; ListNode *cur=head,*del; //每次循环我们判断cur的next节点值是否为val，确定是否删除 while(cur->next){ if(cur->next->val==val){//若cur->next的节点值为val，那么我们需要删除cur->next del=cur->next; cur->next=del->next; delete del; } else{//若不为val，那么我们需要移动cur cur=cur->next; } } return head->val==val?head->next:head; } - 递归 ```c++ //题解1：递归法 ListNode* removeElements_1(ListNode* head, int val) { //1、递归边界 if(!head)return nullptr; //2、递去：直到到达链表尾部才开始删除重复元素 head->next=removeElements(head->next,val); //3、递归式：相等就是删除head，不相等就不用删除 return head->val==val?head->next:head; } 交换相邻节点 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）(第i个和第i+1个，i为奇数)。 输入：head = [1,2,3,4] 输出：[2,1,4,3] class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0, head); ListNode* temp = dummyHead; while (temp->next != nullptr && temp->next->next != nullptr) { ListNode* node1 = temp->next; ListNode* node2 = temp->next->next; temp->next = node2; node1->next = node2->next; node2->next = node1; temp = node1; } return dummyHead->next; } }; 旋转链表 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 输入：head = [1,2,3,4,5], k = 2 输出：[4,5,1,2,3] 闭合为环 再断开 记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 nn 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n−1)−(k mod n) 个节点（从 00 开始计数）。 这样，我们可以先将给定的链表连接成环，然后将指定位置断开。 具体代码中，我们首先计算出链表的长度 nn，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第(n−1)−(k mod n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。 特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。 class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if (k == 0 || head == nullptr || head->next == nullptr) { return head; } int n = 1; ListNode* iter = head; while (iter->next != nullptr) { iter = iter->next; n++; } int add = n - k % n; if (add == n) { return head; } iter->next = head; while (add--) { iter = iter->next; } ListNode* ret = iter->next; iter->next = nullptr; return ret; } }; 链表有环 判断环 class Solution { public: bool hasCycle(ListNode* head) { if (head == nullptr || head->next == nullptr) { return false; } ListNode* slow = head; ListNode* fast = head->next; // 先走一步，emm能判断环，但不能求入口？？ while (slow != fast) { // while在前 if (fast == nullptr || fast->next == nullptr) { return false; // 无法再前进两步 } slow = slow->next; fast = fast->next->next; } return true; } }; 寻找入环点 见基本算法中 Floyd 判圈算法（龟兔赛跑问题） 快慢指针相遇后，把快指针移回到head，继续走到相同点即为入环点。 class Solution { public: ListNode *detectCycle(ListNode *head) { if(head==nullptr||head->next==nullptr) return nullptr; //第一步 判断是否存在环形节点：双指针法 ListNode *s=head,*f=head; do{ if(f->next==nullptr||f->next->next==nullptr) return nullptr; s=s->next; f=f->next->next; }while(s!=f); // ListNode *s=head,*f=head->next; // while(s!=f){ // // if(f->next==nullptr||f->next->next==nullptr) return nullptr; // if(f==nullptr||f->next==nullptr) return nullptr; // s=s->next; // f=f->next->next; // } cout val val next; //->next; s=s->next; } // do{ //这样不对 对于 [1,2] 应返回指向1，而不是指向2 // f=f->next; // s=s->next; // }while(s!=f); return s; } }; 链表排序 常规转数组 再转链表 插入排序(O(n^2)) 归并排序(O(log(n))) 归并算法的本质是分成治之。当有多个数据的时候，处理不过来，从逻辑上切分成多分最小处理单位，分别处理。处理完，再合并每一份的结果。也就是从小结果一点点累积出最终结果。 class Solution { public: ListNode* sortList(ListNode* head) { return (head==NULL)?NULL:mergeSort(head); } private: ListNode* findMid(ListNode *head) { ListNode *slow=head; ListNode *fast=head; ListNode *previous=NULL; while(fast!=NULL&&fast->next!=NULL) { previous=slow; slow=slow->next; fast=fast->next->next; } previous->next=NULL; return slow; } ListNode* mergeTwoLists(ListNode* l1,ListNode *l2) { if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1->valval) { l1->next=mergeTwoLists(l1->next,l2); return l1; } else { l2->next=mergeTwoLists(l1,l2->next); return l2; } } ListNode* mergeSort(ListNode* head) { if(head->next==NULL) return head; ListNode* mid=findMid(head); ListNode *l1=mergeSort(head); ListNode *l2=mergeSort(mid); return mergeTwoLists(l1,l2); } }; 归并-简化版 ```c++class Solution { public: ListNode sortList(ListNode head, ListNode *tail = nullptr) { if(!head) return nullptr; if(head->next == tail){ head->next = nullptr; return head; } auto quick = head, slow = head; while (quick != tail && quick->next !=tail) slow = slow->next, quick = quick->next->next; return merge(sortList(head, slow), sortList(slow, tail)); } private: ListNode merge(ListNode l1, ListNode l2) { ListNode sub(0), ptr = ⊂ while(l1 && l2) { auto &node = l1->val val ? l1 : l2; ptr = ptr->next = node, node = node->next; } ptr->next = l1 ? l1 : l2; return sub.next; } }; ## 综合 ### 反转链表+快慢指针 [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/) >给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 输入：head = [1,2,2,1] 输出：true - 快慢指针+反转部分链表 避免使用 O(n)O(n) 额外空间的方法就是改变输入。 我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。 该方法虽然可以将空间复杂度降到 O(1)O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。 **算法** 整个流程可以分为以下五个步骤： - 找到前半部分链表的尾节点。 - 反转后半部分链表。 - 判断是否回文。 - 恢复链表。 - 返回结果。 执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。 我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。 若链表有奇数个节点，则中间的节点应该看作是前半部分。 ```c++ class Solution { public: bool isPalindrome(ListNode* head) { ListNode *slow = head, *fast = head; while(fast != nullptr && fast->next != nullptr){ slow = slow->next; fast = fast->next->next; } // 1->2->3->4->5 slow为3，fast为5 // 1->2->3->4->5->6 slow为4，fast为null // 而为奇数情况下，3可以不用比较，即把slow移到4，只反转 4 next; } slow = reverse(slow); fast = head; while(slow != nullptr) // slow 比较短 { if(slow->val != fast->val) return false; slow = slow->next; fast = fast->next; } return true; } private: ListNode* reverse(ListNode *head){ ListNode *pre = nullptr, *cur = head; while(cur != nullptr) { ListNode *next = cur->next; cur->next = pre; pre = cur; cur = next; } return pre; } }; 重排链表 给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln-1 → Ln 请将其重新排列后变为： L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 输入: head = [1,2,3,4] 输出: [1,4,2,3] 示例 2: 输入: head = [1,2,3,4,5] 输出: [1,5,2,4,3] 提示： 链表的长度范围为 [1, 5 * 104] 1 解： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: void reorderList(ListNode* head) { if(!head) return; // 1 快慢指针取中点 2 反转后一半 3 合并链表 ListNode * mid = getMid(head); ListNode * l1 = head; ListNode * l2 = mid->next; mid->next = nullptr; l2 = reverse(l2); merge(l1, l2); } ListNode* getMid(ListNode* node){ if(!node) return nullptr; ListNode* slow = node; ListNode* fast = node; while(fast->next && fast->next->next){ slow = slow->next, fast = fast->next->next; } return slow; } ListNode* reverse(ListNode* node){ ListNode* pre = nullptr; ListNode* cur = node; while(cur){ ListNode* nxt = cur->next; cur->next = pre; pre = cur; cur = nxt; } return pre; } void merge(ListNode* l1, ListNode* l2){ ListNode* ans = new ListNode(0); while(l1 || l2){ if(l1) ans->next = l1, l1 = l1->next, ans = ans->next; if(l2) ans->next = l2, l2 = l2->next, ans = ans->next; } l1 = ans->next; } }; 其他 链表建树 有序链表转换二叉搜索树 分治 具体地，设当前链表的左端点为left，右端点right，包含关系为「左闭右开」，即left 包含在链表中而right 不包含在链表中。我们希望快速地找出链表的中位数节点 mid。 为什么要设定「左闭右开」的关系？由于题目中给定的链表为单向链表，访问后继元素十分容易，但无法直接访问前驱元素。因此在找出链表的中位数节点 mid 之后，如果设定「左闭右开」的关系，我们就可以直接用 (left,mid) 以及 (mid.next,right) 来表示左右子树对应的列表了。并且，初始的列表也可以用(head,null) 方便地进行表示，其中 null 表示空节点。 找出链表中位数节点的方法多种多样，其中较为简单的一种是「快慢指针法」。初始时，快指针fast 和慢指针 slow 均指向链表的左端点left。我们将快指针 fast 向右移动两次的同时，将慢指针slow 向右移动一次，直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）。此时，慢指针对应的元素就是中位数。 在找出了中位数节点之后，我们将其作为当前根节点的元素，并递归地构造其左侧部分的链表对应的左子树，以及右侧部分的链表对应的右子树。 class Solution { public: TreeNode* sortedListToBST(ListNode* head) { return buildTree(head,nullptr); } TreeNode* buildTree(ListNode* left, ListNode* right) { if (left == right) { return nullptr; } ListNode* mid = findMid(left, right); TreeNode* root = new TreeNode(mid->val); root->left = buildTree(left, mid); root->right = buildTree(mid->next, right); return root; } ListNode *findMid(ListNode *first,ListNode *last){ ListNode *fast=first; ListNode *slow=first; while(fast!=last&&fast->next!=last){ fast=fast->next->next; slow=slow->next; } return slow; } }; 分治+中序遍历优化O(n) Article:官方解答 链表相交 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 双指针 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode* pA=headA,*pB=headB; while(pA!=pB){ pA=pA!=nullptr?pA->next:headB; pB=pB!=nullptr?pB->next:headA; } return pA; } }; 4 哈希 一般哈希 模拟散列表(拉链法+开放寻址法) (1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 头插法 void insert(int x) // 相当于 在k的链表中 插入了x 即 k -> x 类似于 a -> b { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) // 在k的有向图中 是否能找到x { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { int t = (x % N + N) % N; while (h[t] != null && h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } 设计 (后续用拉链法写一下) 设计哈希集合 不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 实现 MyHashSet 类： void add(key) 向哈希集合中插入值 key 。 bool contains(key) 返回哈希集合中是否存在这个值 key 。 void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 class MyHashSet { private: vector> data; static const int base = 769; static int hash(int key) { return key % base; } public: /** Initialize your data structure here. */ MyHashSet(): data(base) {} void add(int key) { int h = hash(key); for (auto it = data[h].begin(); it != data[h].end(); it++) { if ((*it) == key) { return; } } data[h].push_back(key); } void remove(int key) { int h = hash(key); for (auto it = data[h].begin(); it != data[h].end(); it++) { if ((*it) == key) { data[h].erase(it); return; } } } /** Returns true if this set contains the specified element */ bool contains(int key) { int h = hash(key); for (auto it = data[h].begin(); it != data[h].end(); it++) { if ((*it) == key) { return true; } } return false; } }; 设计哈希映射 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。 实现 MyHashMap 类： MyHashMap() 用空映射初始化对象 void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。 int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。 void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。 class MyHashMap { private: vector>> data; static const int base = 769; static int hash(int key) { return key % base; } public: /** Initialize your data structure here. */ MyHashMap(): data(base) {} /** value will always be non-negative. */ void put(int key, int value) { int h = hash(key); for (auto it = data[h].begin(); it != data[h].end(); it++) { if ((*it).first == key) { (*it).second = value; return; } } data[h].push_back(make_pair(key, value)); } /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) { int h = hash(key); for (auto it = data[h].begin(); it != data[h].end(); it++) { if ((*it).first == key) { return (*it).second; } } return -1; } /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) { int h = hash(key); for (auto it = data[h].begin(); it != data[h].end(); it++) { if ((*it).first == key) { data[h].erase(it); return; } } } }; 字符串哈希 全称：字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），实现不同的字符串映射到不同的数字。 对形如 X1X2X3⋯Xn−1Xn的字符串,采用字符的ascii 码乘上 P 的次方来计算哈希值。 此处采用左边的数权值高 映射公式 (X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ 注意点： 任意字符不可以映射成0，否则会出现不同的字符串都映射成0的情况，比如A,AA,AAA皆为0 冲突问题：通过巧妙设置P (131 或 13331) , Q (2^64)的值，一般可以理解为不产生冲突。 是kmp劲敌，除了循环节需要用kmp做，其他kmp能做的字符串哈希都能做 数据类型取unsigned long long(ULL): 通常我们取 M=2^64，即直接使用unsigned long long类型存储这个Hash值，在计算时不处理算术溢出问题，产生溢出时相当于自动对 2^64取模，这样可以避免低效的取模运算。 根据以往经验，当p=131或13331，Q=264时，99.99%的情况下都不存在冲突 这里的Q=264,模数Q是很巧妙的，可以利用unsign long long来存储计算的结果，这样可以完成对Q取模的效果，从而省略在代码里写额外的取模操作 除了在及特殊构造的数据上，上述Hash很难产生冲突，一般情况下上述Hash算法完全可以出现在题目的标准解答中。我们还可以多取一些恰当的P和M值（例如大质数），多进行几组Hash运算，当结果都相同时才认为原字符串相等，就更难以构造出使这个Hash产生错误的数据。 对字符串的各种操作，都可以直接对P进制数进行算数运算反映到Hash值上。 // 核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 // 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果 typedef unsigned long long ULL; const int P = 13331; const int N = 100010; ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64 // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } // 初始化 p[0] = 1; for (int i = 1; i 查找给定哈希值的子串 给定整数 p 和 m ，一个长度为 k 且下标从 0 开始的字符串 s 的哈希值按照如下函数计算： hash(s, p, m) = (val(s[0]) p0 + val(s[1]) p1 + ... + val(s[k-1]) pk-1) mod m. 其中 val(s[i]) 表示 s[i] 在字母表中的下标，从 val('a') = 1 到 val('z') = 26 。 给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 k 的 子串 sub ，满足 hash(sub, power, modulo) == hashValue 。 测试数据保证一定 存在 至少一个这样的子串。 子串 定义为一个字符串中连续非空字符组成的序列。 示例 1： 输入：s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0 输出：\"ee\" 解释：\"ee\" 的哈希值为 hash(\"ee\", 7, 20) = (5 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。 \"ee\" 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 \"ee\" 。 class Solution { public: string subStrHash(string s, int power, int mod, int k, int hashValue) { int n = s.size(), ans = 0; long long hashv = 0, p = 1; for(int i = n-1; i >= n-k+1; --i) { p = p * power % mod; hashv = power * (hashv+s[i]-96) % mod; } for(int i = n-k; i >= 0; --i){ hashv = (hashv+s[i]-96) % mod;//加头 if(hashv == hashValue) ans = i; hashv = power * (hashv + mod - p * (s[i+k-1]-96) % mod) % mod;//去尾 } return s.substr(ans, k); } }; 二维哈希 5 字符串 kmp 解决的问题：解决字符串匹配问题。（换言之，判断一个字符串“原串”里面是否包含另一个字符串“模式串”） 简介： Knuth-Morris-Pratt（简称KMP）算法，是三个发明者名字首字母。 举例：原串 str = ABAFCDABAFDCC，索引为 i，模式串 tar = ABAFD，索引为 j 以下代码和上述表述不一致 Article:KMP字符串 注意s和p串的下标均从1开始!!! 若用长度为N的char s[N]存储，可 cin >> (s + 1);将字符串读入 1、s[]是主串，即比较长的字符串。 2、p[]是模式串，即比较短的字符串。（这样可能不严谨。。。） 3、“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。 4、“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。（后面会有例子，均简称为前/后缀） 5、“部分匹配值”：前缀和后缀的最长共有元素的长度。 6、next[]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”，是KMP算法的核心。（后面作详细讲解）。 核心思想： 在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。 next数组含义 next数组的含义：即最长公共前后缀(不能和本身等长)，对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 p[ 1, next[ j ] ] = p[ j - next[ j ] + 1, j ]。 KMP主要分两步：求next数组、匹配字符串。 1. 匹配： ​s串 和 p串都是从1开始的。i 从1开始，j 从0开始，每次s[ i ] 和p[ j + 1 ]比较 // 匹配 // 注意： i从1开始， for (int i = 1, j = 0; i 2. next数组 next数组的求法是通过模板串自己与自己进行匹配操作得出来的（代码和匹配操作几乎一样）。 // kmp求next数组和匹配。其中大部分代码是一样的，注意循环起点i的值以及 // s[]是长文本，p[]是模式串，n是s的长度，m是p的长度 // 求模式串的Next数组： // 注意： i从2开始，p和p自己匹配 多一行ne[i]=j的赋值 for (int i = 2, j = 0; i 总结 kmp与循环节 周期 一个字符串的前缀是从第一个字符开始的连续若干个字符，例如 abaab 共有 5 个前缀，分别是 a，ab，aba，abaa，abaab。 我们希望知道一个 N 位字符串 S 的前缀是否具有循环节。 换言之，对于每一个从头开始的长度为 i（i>1）的前缀，是否由重复出现的子串 A 组成，即 AAA…A （A 重复出现 K 次,K>1）。 如果存在，请找出最短的循环节对应的 K 值（也就是这个前缀串的所有可能重复节中，最大的 K 值）。 参考：周期解析 关于 kmp 算法中 next 数组的周期性质 引理： 对于某一字符串 $S[1$～$i ]$，在它众多的$next[ i ]$的“候选项”中，如果存在某一个$next[ i ]$，使得: $i$ % $( i - next[ i ] ) == 0$ ，那么 $S[ 1$～ $( i -next[ i ] ) ]$ 可以为 $S[ 1$ ～ $i ]$ 的循环元而 $i / ( i - next[ i ] )$ 即是它的循环次数 $K$。 证明如下： 如图，$next[ i ] = j$,由定义得红色部分两个子串完全相同。 那么有$S[ 1$～$j ] = S[ m$～$i ]$ $( m = i - next[ i ] )$。 如果我们在两个子串的前面框选一个长度为 m 的小子串(橙色部分)。 可以得到：$S[ 1$～$m ] = S[ m$～$b ]$。 如果在紧挨着之前框选的子串后面再框选一个长度为 m 的小子串(绿色部分)，同样的道理， 可以得到：$S[ m$～$b ] = S[ b$～$c ]$ 又因为：$S[ 1$～$m ] = S[ m$～$b ]$ 所以：$S[ 1$～$m ] = S[ m$～$b ] = S[ b$～$c ]$ 如果一直这样框选下去，无限推进，总会有一个尽头。 当满足 $i$ % $m == 0$ 时，刚好可以分出 $K$ 个这样的小子串， 且形成循环$( K = i / m )$。 因此我们需要从 $1$～$N$ 扫一遍，判断如果 $next[ i ]$ 可以整除 $i$ ，即满足 $i$ % $( i - next[ ] ) == 0$ ，那么就可以 肯定$S[ 1$～ $( i - next[ i ] ) ]$是 $S[ 1$～$i ]$ 的最小循环元，而 $i / ( i - next[ i ] )$ 即是它的最大循环次数 $K$ ，直接依次输 出这些 $i$和 $K$ 即可。 那么为什么只判断 $next[ i ]$ 而不判断 $next[?]$呢？ （注：$next[i]$和$next[?]$表述的意义不同，为方便描 述，这里定义$next[?]$为$next[i]$的$“候选项”中的某一个） 实际上由这道题可以总结出很多结论： 结论一： 若$i-next[i]$可整除$i$,则$s[1$～$i]$具有长度为$i-next[i]$ 的循环元，即$s[1$～$i-next[i]]$。(前面的一大堆文 字和图片已经给出了这个结论的证明，同时结论一 也是后面推导其他结论的理论基础） 结论二： 若$i-next[?]$可整除$i$,则$s[1$～$i]$具有长度为$i-next[?]$ 的循环元，即$s[1$～$i-next[?]]$。 (用与结论一同样的证明方法可以推导出结论二) (由此处可知，$i-next[?]$想用作循环元要满足的 条件是：$i-next[?]$可整除$i$)。 结论三： 任意一个循环元的长度必定是最小循环元长度的倍数 结论四： 如果$i-next[i]$不可整除$i$，$s[1$～$i-next[?]]$一定 不能作为$s[1$～$i]$的循环元。 关于结论四的证明和扩展： ①.如果$s[1$～$i-next[i]]$不能作为$s[1$～$i]$循环元，那么 $s[1$～$i-next[?]]$也都一定不能作为$s[1$～$i]$的循环元。 (即结论四) ②.如果$i-next[i]$不可整除$i$，$s[1$～$i]$一定不存在循环元。 ③.如果$i-next[i]$不可整除$i$，$i-next[?]$也都一定不可整除$i$。 ④.如果$s[1$～$m]$是$s[1$～$i]$的循环元，$next[i]$一定为$i-m$($i-m$一定为 $next[i]$)。(在算法竞赛进阶指南上有这么一句话：如果$s[1$～$m]$为$s[1$～$i]$的循 环元，$i-m$一定是$next[i]$的“候选项”，与此处意义略有不同) ⑤.若$m=i-next[i]$，$j=next[?]$，$next[j]=j-m$。(无论$m$可否整除$i$) (由④扩展而来) 一些题外话： 关于③的证明，有一个很有趣的想法。 有两个数$a$,$c$和一个数的集合$b$，且$b$与$a$有一定的关系(限制)。 已知$a$不可整除$c$，证明$x(x∈b$)不可整除$c$(目前尚未成功)。 虽然表面上看起来并没有什么用，但这种思想把图形匹配转 化为了代数证明。 如果有大佬感兴趣可以思考一下。。。 附：来自某李姓Math大佬。 ②③④比较好理解，这个⑤是个什么意思呢？ 其实不难懂，通俗点说就是$i-next[?]$一定是在$m$的倍数处 $(m,2m,3m…)$，如果有循环，也可以说是$i-next[?]$一定在循环 节点上,或者说是一定在我们先前图片中框选的黑色块的边界相 邻处，不可能在某个黑色块的中间（如图红色为不可能的情况） 注意一下这个等式：$i-next[j]=i-j+m$ 可以化简为：$next[j]=j-m$ 那么可以发现每个$next[?]$和$next[next[?]]$之间刚好相差m， 只是要由⑤推导①的话，用化简前的样子似乎会更好懂一些。 假如④⑤得证，那么它们和①有什么关系呢？ 如果$i-next[?]$一定是在$m$的倍数处$(m=i-next[i])$， 因为当$m$不可整除$i$时，$m$的倍数也不可整除$i$， 所以$i-next[?]$均不满足作为$s[1$～$i]$循环元的条件(前面已 提到过“条件”具体指什么)。 因此，⑤$→$①得证。 如何证明④或者⑤？ 如图，$j=next[i]$，$m=i-next[i]$ 先按照与之前相同的方法先将$s[1$～$i]$划分成$K$个黑色块 $j0=next[j]$，$n=i-next[j]$，假设n不在m的倍数处，如图红色。 同样的，框选出红色块。 然后再作一些辅助线。接下来就开始推理。 设$v=j-j0$。 先看左边：$s[1$～$1+v]=s[m$～$m+v]$，$s[1+v$～$1+2v]=s[m+v$～$m+2v] $ 再看右边： $s[1$～$1+v]=s[m+v$～$m+2v]$ 综合可得：$s[1$～$1+v]=s[m$～$m+v]=s[m+v$～$m+2v]=s[1+v$～$1+2v]$ 无限的推进，再推进，辅助线划分出的长度为v的区域全部相等，直至边界。而此时的边界出现了两种情况： ⑴v可整除i。 此时刚好将$s[1$～$i]$分成了若干个完全相同的长度为$v$的小块，明显形成了循环元$s[1$～$v]$，那么$next[i]$至少应为$i-v$，这与之前的$next[i]=j$相矛盾。 ⑵v不可整除i。 观察下列图片，你发现了什么？ 将蓝圈处放大，发现了一种交叉相等的情况(如图绿色处)。 再把它压扁，并取几个新的名字$1’,m’,j’,i’$。此时它变得和初始 的情况一模一样，于是经过相同的操作后，再一次使出了无限 推进，假如每次的$v’$都不可整除$m’$，那么就一路推了边界：$v’=1$。 $1$可以整除任何数，于是$s[1$～$i]$形成了长度为$1$的循环元，矛盾。 当n不在m的倍数处时，一定会出现矛盾，所以假设不成立。 因此④得证。同理⑤也得证。 #include int t,i,j,n,nex[1000005];char a[1000005]; int main(){ while(scanf(\"%d\",&n),n){ scanf(\"%s\",a+1); printf(\"Test case #%d\\n\",++t); for(i=2,j=0;i 奶牛矩阵？？？ 完全覆盖： 所有循环节长度都是最小循环节长度的倍数 不完全覆盖：则不满足上述特性 完美循环节 最短循环节 n-next[n] 每天早上，农夫约翰的奶牛们被挤奶的时候，都会站成一个 R 行 C 列的方阵。 现在在每个奶牛的身上标注表示其品种的大写字母，则所有奶牛共同构成了一个 R 行 C 列的字符矩阵。 现在给定由所有奶牛构成的矩阵，求它的最小覆盖子矩阵的面积是多少。 如果一个子矩阵无限复制扩张之后得到的矩阵能包含原来的矩阵，则称该子矩阵为覆盖子矩阵。 输入格式 第 1 行：输入两个用空格隔开的整数，R 和 C。 第 2..R+1 行：描绘由奶牛构成的 R 行 C 列的矩阵，每行 C 个字符，字符之间没有空格。 输出格式 输出最小覆盖子矩阵的面积。（每个字符的面积为 1） 数据范围 1≤R≤10000, 1≤C≤75 输入样例： 2 5 ABABA ABABA 输出样例： 2 #include using namespace std; const int N = 1e4+10, M=100; int n, m, ne[N]; char s[N][M]; bool st[M]; int main() { cin>>n>>m; for(int i=1; i>s[i]; for(int j=1; j 匹配统计 D-最短回文串 解析 思路1.求最长回文前缀： 1. 对于str数组，可先使 `s = \" \" + str + \"#\" + reverse(str)`; 2. 将问题转化为 求取s的next数组，则最长回文前缀的长度即为next.back(); 3. 同时注意`#`的使用：因为字符串已经不是字符串本身了，已经是2倍长度了，防止最长公共前后缀的长度超过模式串长度本身。所以添加了一个字符，将其在中间截断。 如'aaa'+'aaa'得到'aaaaaa'，求出的最长公共前后缀是 6，但其实想要的是 3。 class Solution { public: string shortestPalindrome(string s) { if (s.size() == 0) { return \"\"; } string rev = s; reverse(rev.begin(), rev.end()); string str = \" \"+ s + \"#\" + rev; vector next(str.size(),0); int res = GetNext(str, next); return rev + s.substr(res , s.size() - res ); } int GetNext(string p, vector& next) { for(int i=2,j=0;i 思路2.字符串哈希 一个字符串是回文串，当且仅当该字符串与它的反序相同。因此，我们仍然暴力地枚举 s_1的结束位置，并计算 s_1与 s_1 反序的哈希值。如果这两个哈希值相等，说明我们找到了一个 s 的前缀回文串。 class Solution { public: string shortestPalindrome(string s) { int n = s.size(); int base = 131, mod = 1000000007; int left = 0, right = 0, mul = 1; int best = -1; for (int i = 0; i 拓展kmp (exKmp) 拓展kmp 样例： z(aaaaa) = [0,4,3,2,1] z(aaabaab) = [0,2,1,0,2,1,0] z(abacaba) = [0,0,1,0,3,0,1] 朴素算法 Z 函数的朴素算法复杂度为 O(n^2) // C++ Version vector z_function_trivial(string s) { int n = (int)s.length(); vector z(n); for (int i = 1; i 线性算法(n) // C++ Version vector z_function(string s) { int n = (int)s.length(); vector z(n); for (int i = 1, l = 0, r = 0; i r) l = i, r = i + z[i] - 1; } return z; } 构造字符串的总得分和 你需要从空字符串开始 构造 一个长度为 n 的字符串 s ，构造的过程为每次给当前字符串 前面 添加 一个 字符。构造过程中得到的所有字符串编号为 1 到 n ，其中长度为 i 的字符串编号为 si 。 比方说，s = \"abaca\" ，s1 == \"a\" ，s2 == \"ca\" ，s3 == \"aca\" 依次类推。 si 的 得分 为 si 和 sn 的 最长公共前缀 的长度（注意 s == sn ）。 给你最终的字符串 s ，请你返回每一个 si 的 得分之和 。 示例 1： 输入：s = \"babab\" 输出：9 解释： s1 == \"b\" ，最长公共前缀是 \"b\" ，得分为 1 。 s2 == \"ab\" ，没有公共前缀，得分为 0 。 s3 == \"bab\" ，最长公共前缀为 \"bab\" ，得分为 3 。 s4 == \"abab\" ，没有公共前缀，得分为 0 。 s5 == \"babab\" ，最长公共前缀为 \"babab\" ，得分为 5 。 得分和为 1 + 0 + 3 + 0 + 5 = 9 ，所以我们返回 9 。 示例 2 ： 输入：s = \"azbazbzaz\" 输出：14 解释： s2 == \"az\" ，最长公共前缀为 \"az\" ，得分为 2 。 s6 == \"azbzaz\" ，最长公共前缀为 \"azb\" ，得分为 3 。 s9 == \"azbazbzaz\" ，最长公共前缀为 \"azbazbzaz\" ，得分为 9 。 其他 si 得分均为 0 。 得分和为 2 + 3 + 9 = 14 ，所以我们返回 14 。 哈希 + 二分 二分+哈希做法 前置技能 哈希：会求一个字符串的哈希值，会求一段区间[l,r]的哈希值 二分： 对于每个后缀[i,n]，都需要求[1,n]和[i,n]的最长公共子串长度x， 二分长度x，比较[1,x]和[i,i+x-1]是否一致，一致则往大二分，否则往小二分。 tips 防止哈希被卡，可以采用双哈希或三哈希等方式，这里采用双哈希 // 单哈希 class Solution { public: typedef unsigned long long ULL; static const int P = 131, N = 1e5 + 7; ULL p[N], h[N]; ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } long long sumScores(string s) { long long n = s.size(), ans = 0; p[0] = 1; for (int i = 1; i > 1; if (get(i, i + mid - 1) == h[mid]) l = mid; else r = mid - 1; } ans += l; } return ans; } }; exkmp(Z函数法) OI-WIKI 这是一道模板题，求出z数组后， 若z数组表示的是长度，直接求和； 若表示的是下标，加1之后求和。 class Solution { public: int n, m, z[100005]; char a[100005]; long long sumScores(string s) { n = s.size(); for (int i = 0; i r) r = i + z[i] - 1, j = i; } LL ans = 0; for (int i = 1; i 暴力+优化 此做法可以用在 1163. 按字典序排在最后的子串。 基础思想是既然要找所有后缀和原字符串的公共前缀长度，那么首先它们的首字母得一样，于是把可能的位置加入候选集合。 枚举完了首字母再检查第二个字母，这里就只需要在候选集合里检查了，等踢掉了不合法的位置后再检查第三个字母。。。。。。直到集合清空。 显然这么暴力地做，最坏情形会退化到O(N^2)O(N ^2 )，例如\"bacbacbacbacbac.....\"。我们看一下有没有办法把这种情况优化掉。 就以\"bacbacbacbacbac.....\"为例，当我们检查到第二个 b 时，候选集合内实际上存在了很多 \"bac\" 链。当候选集合内存在这种链时，只有与首位置开始的 \"bac\" 链长度相同的位置才有继续检查的必要，因为：若 \"bac\" 链数不够，我们直接它往后跳到第一个不是\"bac\"的部分，这里和 \"bac\" 的公共部分已经求出，可以直接计算 lcp ；若 \"bac\" 链更长，那么在跳转了相同个数的 \"bac\" 后，首字母接下来的部分一定不是 \"bac\" ，而该位置接下来仍然为 \"bac\" ,这个公共长度也被求过了，因此也可以直接计算 lcp 。 于是就可以在均摊线性的时间内完成计算了。 long long sumScores(string s) { long long ret = 0; int n = s.length(); vector q , common(n + 1 , 0); for(int i = 1 ; i 1 ; step++) { vector tmp; // 检查下一个字母 auto target = s[q[0]]; for(auto i : q) if(i == n || s[i] != target) common[i - step + 1] = step; else tmp.push_back(i + 1); swap(tmp , q); // 首字母待检查部分的公共长度未求出，说明内部存在链 if(common[q[0]] == -1) { // 计算链长 int m = q.size(); vector repeat(m + 1 , 1); for(int i = q.size() - 1 ; i >= 0 ; i--) if(common[q[i]] == -1) repeat[i] = repeat[i + 1] + 1; // 将链长与首字母链长不同的都计算出公共前缀长度，然后踢出候选集合 int head_repeat = repeat[0]; tmp.clear(); for(int i = 0 ; i 回文串 最长回文子序列(连续) 证明：字符串的 最长回文子序列（lps） 长度等于其自身与反转的 最长公共子序列（lcs）长度 证明LPS=LCS 最长回文子串(不要求连续) 动态规划 O(n^2) manacher O(n) 判断 分割 分割回文串 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 示例 1： 输入：s = \"aab\" 输出：[ [\"a\",\"a\",\"b\"],[\"aa\",\"b\"] ] 示例 2： 输入：s = \"a\" 输出：[ [\"a\"] ] 解： 关键：预处理 vector> g(n, vector(n, true)); for (int i = n - 1; i >= 0; --i) { // 倒序 for (int j = i + 1; j 具体代码： 回溯+动态规划预处理 class Solution { private: vector> f; vector> ret; vector ans; int n; public: void dfs(const string& s, int i) { if (i == n) { ret.push_back(ans); return; } for (int j = i; j > partition(string s) { n = s.size(); f.assign(n, vector(n, true)); for (int i = n - 1; i >= 0; --i) { for (int j = i + 1; j 回溯 + 记忆化搜索 ```c++class Solution { private: vector> f; vector> ret; vector ans; int n; public: void dfs(const string& s, int i) { if (i == n) { ret.push_back(ans); return; } for (int j = i; j // 记忆化搜索中，f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串 int isPalindrome(const string& s, int i, int j) { if (f[i][j]) { return f[i][j]; } if (i >= j) { return f[i][j] = 1; } return f[i][j] = (s[i] == s[j] ? isPalindrome(s, i + 1, j - 1) : -1); } vector> partition(string s) { n = s.size(); f.assign(n, vector(n)); dfs(s, 0); return ret; } }; [分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/) >给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文。 返回符合要求的 **最少分割次数** 。 **示例 1：** 输入：s = \"aab\" 输出：1 解释：只需一次分割就可将 s 分割成 [\"aa\",\"b\"] 这样两个回文子串。 **示例 2：** 输入：s = \"a\" 输出：0 **示例 3：** 输入：s = \"ab\" 输出：1 **提示：** * `1 > g(n, vector(n, true)); for (int i = n - 1; i >= 0; --i) { for (int j = i + 1; j f(n, INT_MAX); for (int i = 0; i 最短回文串 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 示例 1： 输入：s = \"aacecaaa\" 输出：\"aaacecaaa\" 示例 2： 输入：s = \"abcd\" 输出：\"dcbabcd\" 解： 实用的暴力法 很容易想到的是，将字符串 s 翻转过来，加到 s 的开头，但这并不是最短的，如下图： 这是因为，a 本身就自成回文串，它不需要有镜像。 再比如：s：ananab，rev_s：banana： anana是回文的，它翻转还是anana，这是回文的特点，所以 rev_s：banana要砍掉相同的部分（anana），变成 b，再加上去。 KMP 解法 从暴力法可以看出，其实就是求 s 的「最长回文前缀」，然后在 rev_s 的后缀中砍掉这个回文，再加到 s 前面。 这个最长前缀是回文的，它翻转之后等于它自己，出现在 rev_s 的后缀，这不就是公共前后缀吗？KMP 的 next 数组记录的就是一个字符串的每个位置上，最长公共前后缀的长度。公共前后缀指的是前后缀相同。 因此，我们 “制造” 出公共前后缀，去套 KMP。 s：abab，则 s + '#' + rev_s，得到 str ：abab#baba。 求出 next 数组，最后一项就是 str 的最长公共前后缀的长度，即 s 的最长回文前缀的长度。 添加 # 目的：因为字符串已经不是字符串本身了，已经是2倍长度了，防止最长公共前后缀的长度超过模式串长度本身。所以添加了一个字符，将其在中间截断 class Solution { public: string shortestPalindrome(string s) { if (s.size() == 0) { return \"\"; } string rev = s; reverse(rev.begin(), rev.end()); string str = \" \"+ s + \"#\" + rev; vector next(str.size(),0); int res = GetNext(str, next); return rev + s.substr(res , s.size() - res ); } int GetNext(string p, vector& next) { for(int i=2,j=0;i malache解法见下部分 malache Manacher发明了Manacher算法（中文名：马拉车算法），是一个可以在O(n)的复杂度中返回字符串s中最长回文子串长度的算法 例题： 最短回文串 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 示例 1： 输入：s = \"aacecaaa\" 输出：\"aaacecaaa\" 示例 2： 输入：s = \"abcd\" 输出：\"dcbabcd\" class Solution { public: string shortestPalindrome(string s) { // 将原串变形，如样例：\"aacecaaa\" -> \"$#a#a#c#e#c#a#a#a#^\" string a = \"$#\"; for(auto c : s) a += c, a += '#'; a += '^'; int n = a.size(); vector p(n); // manacher算法 int mr = 0, mid; for(int i = 1; i mr) { mr = i + p[i]; mid = i; } } //找到最长的回文前缀 //如果当前第 i 个字符的半径 p[i] == i, 则当前位置对于的回文串即为前缀回文串, 最靠右的即为最长 int k = 0; for(int i = 0; i 参考： Manacher 算法详解 6 字典树Trie 高效存储和查找字符串集合的数据结构 y总模板 拓展了前缀和通配符，见 实现 Trie (前缀树) 添加与搜索单词 - 数据结构设计 // 模板 1 ：英文单词小写 int son[N][26], cnt[N], idx; // 如果放到类里面 注意初始化 memset(son,0x00,sizeof son),idx =0;... // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; // index：第几个节点，按插入顺序递增 无具体意义 p = son[p][u]; } cnt[p] ++ ; // 以index==p为结尾的完整字符串的数目 } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } // 拓展 // 前缀prefix bool startsWith(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return true; // 只要 能到这，就是有该前缀 } // 通配符 str = \"a.b\" \".a\" \"a.\" // 查询是否能与str匹配 bool match(string str,int p = 0,int ind = 0) { if(ind >= str.size()) return cnt[p]!=0; for (int i = ind; i 以下模板用与正整数，多用于异或题目。 // 模板2 int类型正整数 ，求数组的最大异或对 class Solution { // N为数组大小稍大，M为节点数目啊 private: static const int N = 20010,M = 20010*31; //M是节点数，不是原数组的个数 int son[M][2],idx=0; // 此处无cnt计数了 用不到 void insert(int x) { int p=0; for(int i =30;i>=0;--i){ int &s = son[p][x>>i &1]; // if(!s) s = ++idx; p = s; } } int search(int x) // 求异或 ，与上述query不同 { int p =0,res = 0; for(int i=30;i>=0;--i){ // 从(除去符号位的最高位开始)！！！ int s = x>>i&1; if(son[p][!s]){ // 为使异或值更大，尽量取反值 !s res+=1& nums) { int n = nums.size(); int x = 0; for(int i=1;i Trie类模板 class Trie { private: bool isEnd; Trie* next[26]; public: Trie() { isEnd = false; memset(next,0x00,sizeof next); } void insert(string word) { Trie* node = this; for(auto a:word){ if(node->next[a-'a']==nullptr){ node->next[a-'a'] = new Trie(); } node = node->next[a-'a']; } node->isEnd = true; } bool search(string word) { Trie* node = this; for(auto w:word){ if(node->next[w-'a']== nullptr){ return false; } node = node->next[w-'a']; } return node->isEnd; } bool startsWith(string prefix) { Trie* node = this; for(auto w:prefix){ if(node->next[w-'a']== nullptr){ return false; } node = node->next[w-'a']; } return true; } }; 例题 单词搜索 II Trie + dfs回溯 问题求解时不是按找每一个Word去搜索，而是把Word都插入到trie，对表格进行搜索时，查看是否存在某Word。 static const int NN = 30000 * 10 + 10; static int son[NN][26], cnt[NN], idx; class Solution { set res; unordered_map mp; int M, N; void insert(string s){ int p = 0, n = s.size(); for(int i = 0; i >& bb, int a, int b, int p = 0){ int u = bb[a][b] - 'a'; if( !son[p][u]) return ; p = son[p][u]; if(cnt[p]) res.insert(mp[p]); int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1}; bb[a][b] = '#'; for(int i = 0;i = 0 && x = 0 && y findWords(vector>& board, vector& words) { idx = 0; memset(son, 0, sizeof son); memset(cnt, 0, sizeof cnt); for(auto& w: words) insert(w); int m = board.size(), n = board[0].size(); M = m; N = n; vector ans; for(int i = 0; i Trie + dfs记忆化搜索 class Solution { static const int N = 100010; int son[N][26], cnt[N], idx; void insert(string& s){ int p = 0, n = s.size(); for(int i = 0; i findAllConcatenatedWordsInADict(vector& words) { vector ans; sort(words.begin(), words.end(), [&](const string& a, const string &b){ return a.size() vis(word.size(), 0); if(dfs(word, 0, vis)) ans.push_back(word); // 能重复叠加，即一个连接词可以作为另一个连接词的一部分。但因为一个连接词由多个更短的非空单词组成，如果存在一个较长的连接词的组成部分之一是一个较短的连接词，则一定可以将这个较短的连接词换成多个更短的非空单词，因此不需要将连接词加入字典树。 else insert(word); } return ans; } bool dfs(const string& w, int st, vector& vis){ if(w.size() == st) return true; if(vis[st]) return false; vis[st] = true; int p = 0; for(int i = st; i 序列dp + 字符串哈希 class Solution { typedef unsigned long long ULL; const int P = 131; unordered_set st; public: vector findAllConcatenatedWordsInADict(vector& words) { for (string &s: words) { ULL h = 0; for (char c: s) { h = h * P + c; } st.insert(h); } vector ans; for (string &s: words) { if (check(s)) ans.push_back(s); } return ans; } bool check(const string &s) { int n = s.size(); int f[n + 1]; memset(f, -1, sizeof f); f[0] = 0; for (int i = 0; i 1) return true; } return false; } }; 统计异或值在范围内的数对有多少 给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数：low 和 high ，请返回 漂亮数对 的数目。 漂亮数对 是一个形如 (i, j) 的数对，其中 0 - (0, 1): nums[0] XOR nums[1] = 5 - (0, 2): nums[0] XOR nums[2] = 3 - (0, 3): nums[0] XOR nums[3] = 6 - (1, 2): nums[1] XOR nums[2] = 6 - (1, 3): nums[1] XOR nums[3] = 3 - (2, 3): nums[2] XOR nums[3] = 5 示例 2： 输入：nums = [9,8,4,2,1], low = 5, high = 14 输出：8 解释：所有漂亮数对 (i, j) 列出如下： ​​​​​ - (0, 2): nums[0] XOR nums[2] = 13 - (0, 3): nums[0] XOR nums[3] = 11 - (0, 4): nums[0] XOR nums[4] = 8 - (1, 2): nums[1] XOR nums[2] = 12 - (1, 3): nums[1] XOR nums[3] = 10 - (1, 4): nums[1] XOR nums[4] = 9 - (2, 3): nums[2] XOR nums[3] = 6 - (2, 4): nums[2] XOR nums[4] = 5 提示： 1 104 1 104 1 解： class Solution { public: int tr[20005*20][2],cnt[20005*20],tot=0; void insert(int x) { int p=0; for(int i=5;i>=0;--i) { int idx=x>>i&1; if(!tr[p][idx]) tr[p][idx]=++tot; p=tr[p][idx]; cnt[p]++; // emm 和字符串中的 cnt意义不同，此处经过某节点的数目吧 } } int query(int x, int hi) { int ret=0,p=0; for(int i=5;i>=0;--i) { int a=x>>i&1,h=hi>>i&1; cout hi return ret; } int countPairs(vector& a, int l, int h) { int ret=0; for(int i:a) { insert(i); ret+=query(i,l-1)-query(i,h); } return ret; } }; 遍历 递归 首先容易想到使用「递归」来实现 DFS。 将 [1, n] 的数按照字典序添加到答案，本质上是对一颗节点数量为 n，形态类似字典树的多阶树进行遍历，根节点为 0，需要被跳过，因此我们可以从树的第二层开始搜索。 树中每个节点的值为其搜索路径所代表的数字，且每个节点有 [0, 9] 共 10 个子节点。 时间复杂度：本质上在搜索一棵节点数量为 nn 的多阶树（形态类似于字典树），复杂度为 O(n)O(n) 空间复杂度：忽略递归带来的额外空间开销，复杂度为 O(1)O(1) class Solution { vector ans; public: vector lexicalOrder(int n) { for (int i = 1; i limit) return ; ans.push_back(cur); for (int i = 0; i 迭代 递归具有额外的空间开销，为了实现严格的 O(1) 空间，我们需要使用「迭代」来实现 DFS。 共有 n 个数需要被处理，假设当前处理到的数为 j，根据字典序规则，在满足条件的前提下，我们优先在 j 的后面添加 0（即j∗10 class Solution { public: vector lexicalOrder(int n) { vector ans; ans.reserve(n); for (int i = 0, j = 1; i n) j /= 10; j++; } } return ans; } }; 7 树 基础 建树 遍历 深搜 dfs 前序 二叉树/多叉树的前序遍历 递归class Solution { public: void preorder(TreeNode *root, vector &res) { if (root == nullptr) { return; } res.push_back(root->val); // ① preorder(root->left, res); // ② preorder(root->right, res); // ③ } vector preorderTraversal(TreeNode *root) { vector res; preorder(root, res); return res; } }; 迭代:区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，class Solution { public: vector preorderTraversal(TreeNode* root) { vector res; if (root == nullptr) { return res; } stack stk; TreeNode* node = root; while (stk.size() || node) { while (node) { res.emplace_back(node->val); stk.push(node); node = node->left; } node = stk.top(); stk.pop(); node = node->right; } return res; } }; 中序 递归 非递归class Solution { public: vector inorderTraversal(TreeNode* root) { vector ans; stack stk; TreeNode* node = root; while(stk.size() || node){ while(node){ stk.push(node); node = node->left; } TreeNode* top = stk.top(); stk.pop(); ans.push_back(top->val); if(top->right) node = top->right; } return ans; } }; 后序 递归 非递归class Solution { public: vector postorderTraversal(TreeNode* root) { vector ans; if(!root) return ans; stack stk1, stk2; stk1.push(root); while(stk1.size()){ TreeNode* node = stk1.top(); stk1.pop(); stk2.push(node); if(node->left) stk1.push(node->left); // 先进后出 即stk1 入顺序： 左右 stk2 入：中右左 if(node->right) stk1.push(node->right); } while(stk2.size()){ ans.push_back(stk2.top()->val); stk2.pop(); } return ans; } }; 广搜 bfs 即层序 二叉树的层序遍历 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 输出一层为一个vector class Solution { public: vector> levelOrder(TreeNode* root) { vector > ret; if (!root) { return ret; } queue q; q.push(root); while (!q.empty()) { int currentLevelSize = q.size(); ret.push_back(vector ()); for (int i = 1; i val); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } } return ret; } }; 不同序转化 从前序与中序遍历序列构造二叉树 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 解析见下文 序列化 二叉树的序列化与反序列化 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 示例 1： 输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[1,2] 提示： 树中结点数在范围 [0, 104] 内 -1000 解： class Codec { public: // Encodes a tree to a single string. string serialize(TreeNode* root) { if(root==nullptr){ return \"#\"; } return to_string(root->val) + ' ' + serialize(root->left) + ' ' + serialize(root->right); } TreeNode* mydeserialize(istringstream &ss ){ string tmp; ss>>tmp; if(tmp==\"#\"){ return nullptr; } TreeNode* node = new TreeNode(stoi(tmp)); node->left = mydeserialize(ss); node->right = mydeserialize(ss); return node; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { istringstream ss(data); return mydeserialize(ss); } }; 从前序与中序遍历序列构造二叉树 同样的，还有 从中序与后序遍历序列构造二叉树 即通过 中序+ 前/后序 可唯一构造。由前序+后序并不能唯一构造。 根据前序和后序遍历构造二叉树 思路类似，均可用递归法。 以前+中->构造为例： 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 递归 二叉树前序遍历的顺序为： 先遍历根节点； 随后递归地遍历左子树； 最后递归地遍历右子树。 二叉树中序遍历的顺序为： 先递归地遍历左子树； 随后遍历根节点； 最后递归地遍历右子树。 在「递归」地遍历某个子树的过程中，我们也是将这颗子树看成一颗全新的树，按照上述的顺序进行遍历。挖掘「前序遍历」和「中序遍历」的性质，我们就可以得出本题的做法。 方法一：递归 思路 对于任意一颗树而言，前序遍历的形式总是 [ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ] 即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是 [ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ] 只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。 这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。 细节 在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。 细节： 预先处理 中序各值在中序中的索引 传递参数的root为前序中的根索引(起始为0，后面为前序表中 左右子树的根索引，即每一段的第一个位置，可通过在中序中的长度确定) class Solution { private: vector preorder; // 备份一下前序 会常用 unordered_map dic; TreeNode* recur(int root,int left,int right){ //root为在前序的根索引，left,right为中序中一个(子)树的左右端点索引 if(rightleft=recur(root+1,left,index-1); // 由中序知 左子树长度为 indx - left 。则右子树的第一个节点 在前序中的索引 为 root + (index - left) + 1 // 右子树在中序遍历的区间为 [index + 1, right] node->right=recur(root+(index-left)+1,index+1,right); return node; } public: TreeNode* buildTree(vector& preorder, vector& inorder) { this->preorder=preorder; //计算中序遍历中每个值所在的索引 for(int i=0;i 迭代法 搜索树 BST 预备知识 二叉搜索树具有如下性质： 结点的左子树只包含小于当前结点的数。 结点的右子树只包含大于当前结点的数。 所有左子树和右子树自身必须也是二叉搜索树。 二叉树的中序遍历即按照访问左子树——根结点——右子树的方式遍历二叉树；在访问其左子树和右子树时，我们也按照同样的方式遍历；直到遍历完整棵树。 二叉搜索树的三个特性： 二叉搜索树的中序遍历的序列是递增排序的序列。中序遍历的遍历次序：Left -> Node -> Right。 Successor代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。 Node successor(root) { root = root -> right; while(root -> left){ root = root -> left; } return root; } Predecessor代表的是中序遍历序列的前一个节点。即比当前节点小的最大节点，简称前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。 Node successor(root) { root = root -> left; while(root -> right){ root = root -> right; } return root; } 将有序数组转换为二叉搜索树 二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。 给定二叉搜索树的中序遍历，是否可以唯一地确定二叉搜索树？答案是否定的。如果没有要求二叉搜索树的高度平衡，则任何一个数字都可以作为二叉搜索树的根节点，因此可能的二叉搜索树有多个。 如果增加一个限制条件，即要求二叉搜索树的高度平衡，是否可以唯一地确定二叉搜索树？答案仍然是否定的。 直观地看，我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 11，可以使得树保持平衡。如果数组长度是奇数，则根节点的选择是唯一的，如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点，选择不同的数字作为根节点则创建的平衡二叉搜索树也是不同的。 确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。 当然，这只是我们直观的想法，为什么这么建树一定能保证是「平衡」的呢？这里可以参考「1382. 将二叉搜索树变平衡」，这两道题的构造方法完全相同，这种方法是正确的，1382 题解中给出了这个方法的正确性证明：1382 官方题解，感兴趣的同学可以戳进去参考。 递归的基准情形是平衡二叉搜索树不包含任何数字，此时平衡二叉搜索树为空。 在给定中序遍历序列数组的情况下，每一个子树中的数字在数组中一定是连续的，因此可以通过数组下标范围确定子树包含的数字，下标范围记为 $[\\textit{left}, \\textit{right}]$。对于整个中序遍历序列，下标范围从 $\\textit{left}=0 $到$ \\textit{right}=\\textit{nums}.\\text{length}-1$。当 $\\textit{left}>\\textit{right}$ 时，平衡二叉搜索树为空。 以下三种方法中，方法一总是选择中间位置左边的数字作为根节点，方法二总是选择中间位置右边的数字作为根节点，方法三是方法一和方法二的结合，选择任意一个中间位置数字作为根节点。 具体来说，都是终中序遍历，但每次可总是选择中间位置左/右/或随机选一边的数字作为根节点 代码以中间位置左边的数字作为根节点为例。 class Solution { public: TreeNode* sortedArrayToBST(vector& nums) { return helper(nums, 0, nums.size() - 1); } TreeNode* helper(vector& nums, int left, int right) { if (left > right) { return nullptr; } // 总是选择中间位置左边的数字作为根节点 即偶数个数 取中间左边的那个 int mid = (left + right) / 2; TreeNode* root = new TreeNode(nums[mid]); root->left = helper(nums, left, mid - 1); root->right = helper(nums, mid + 1, right); return root; } }; 不同的二叉搜索树 Article:删除二叉搜索树中的节点 class Solution { int f[20]; public: int numTrees(int n) { f[0] = 1, f[1] = 1; for(int i = 2; i 删除二叉搜索树中的节点 解： 这里有三种可能的情况： 要删除的节点为叶子节点，可以直接删除。 要删除的节点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点。 要删除的节点不是叶子节点，且没有右节点但是有左节点。这意味着它的后继节点在它的上面，但是我们并不想返回。我们可以使用它的前驱节点进行替代，然后再递归的向下删除前驱节点。 算法： 如果 key > root.val，说明要删除的节点在右子树，root.right = deleteNode(root.right, key)。 如果 key 如果 key == root.val，则该节点就是我们要删除的节点，则： 如果该节点是叶子节点，则直接删除它：root = null。 如果该节点不是叶子节点且有右节点，则用它的后继节点的值替代 root.val = successor.val，然后删除后继节点。 如果该节点不是叶子节点且只有左节点，则用它的前驱节点的值替代 root.val = predecessor.val，然后删除前驱节点。 返回 root。 另一简单思路 但会破坏平衡 增加树的深度 根据二叉搜索树的性质 如果目标节点大于当前节点值，则去右子树中删除； 如果目标节点小于当前节点值，则去左子树中删除； 如果目标节点就是当前节点，分为以下三种情况： 其无左子：其右子顶替其位置，删除了该节点； 其无右子：其左子顶替其位置，删除了该节点； 其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。 class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if (root == nullptr) return nullptr; if (key > root->val) root->right = deleteNode(root->right, key); // 去右子树删除 else if (key val) root->left = deleteNode(root->left, key); // 去左子树删除 else // 当前节点就是要删除的节点 { if (! root->left) return root->right; // 情况1，欲删除节点无左子 if (! root->right) return root->left; // 情况2，欲删除节点无右子 TreeNode* node = root->right; // 情况3，欲删除节点左右子都，找后驱节点 while (node->left) // 寻找欲删除节点右子树的最左节点 node = node->left; node->left = root->left; // 将欲删除节点的左子树成为其右子树的最左节点的左子树 root = root->right; // 欲删除节点的右子顶替其位置，节点被删除 } return root; } }; 二叉搜索树中第K小的元素 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。 法一： 中序遍历 迭代 因为二叉搜索树和中序遍历的性质，所以二叉搜索树的中序遍历是按照键增加的顺序进行的。于是，我们可以通过中序遍历找到第 k 个最小元素。class Solution { public: int kthSmallest(TreeNode* root, int k) { stack stack; while (root != nullptr || stack.size() > 0) { while (root != nullptr) { stack.push(root); root = root->left; } root = stack.top(); stack.pop(); --k; if (k == 0) { break; } root = root->right; } return root->val; } }; 如果你需要频繁地查找第 kk 小的值，你将如何优化算法？ 法二：记录子树的结点数 类似二分？？ class MyBst { public: MyBst(TreeNode *root) { this->root = root; countNodeNum(root); } // 返回二叉搜索树中第k小的元素 int kthSmallest(int k) { TreeNode *node = root; while (node != nullptr) { int left = getNodeNum(node->left); if (left right; k -= left + 1; } else if (left == k - 1) { break; } else { node = node->left; } } return node->val; } private: TreeNode *root; unordered_map nodeNum; // 统计以node为根结点的子树的结点数 int countNodeNum(TreeNode * node) { if (node == nullptr) { return 0; } nodeNum[node] = 1 + countNodeNum(node->left) + countNodeNum(node->right); return nodeNum[node]; } // 获取以node为根结点的子树的结点数 int getNodeNum(TreeNode * node) { if (node != nullptr && nodeNum.count(node)) { return nodeNum[node]; }else{ return 0; } } }; class Solution { public: int kthSmallest(TreeNode* root, int k) { MyBst bst(root); return bst.kthSmallest(k); } }; 法三：平衡二叉搜索树 解 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 kk 小的值，你将如何优化算法？ 方法三需要先掌握 平衡二叉搜索树（AVL树） 的知识。平衡二叉搜索树具有如下性质： 平衡二叉搜索树中每个结点的左子树和右子树的高度最多相差 1； 平衡二叉搜索树的子树也是平衡二叉搜索树； 一棵存有 nn 个结点的平衡二叉搜索树的高度是 O(logn)。 思路和算法 我们注意到在方法二中搜索二叉搜索树的时间复杂度为 O(H)，其中 HH 是树的高度；当树是平衡树时，时间复杂度取得最小值 O(logN)。因此，我们在记录子树的结点数的基础上，将二叉搜索树转换为平衡二叉搜索树，并在插入和删除操作中维护它的平衡状态。 代码过于复杂略 关于平衡树见下部分 平衡树 将二叉搜索树变平衡 解： 参考：贪心构造解法 class Solution { public: vector inorderSeq; void getInorder(TreeNode* o) { if (o->left) { getInorder(o->left); } inorderSeq.push_back(o->val); if (o->right) { getInorder(o->right); } } TreeNode* build(int l, int r) { int mid = (l + r) >> 1; TreeNode* o = new TreeNode(inorderSeq[mid]); if (l left = build(l, mid - 1); } if (mid + 1 right = build(mid + 1, r); } return o; } TreeNode* balanceBST(TreeNode* root) { getInorder(root); return build(0, inorderSeq.size() - 1); } }; b树 红黑树 递归： class Solution { public: string tree2str(TreeNode *root) { if (root == nullptr) { return \"\"; } if (root->left == nullptr && root->right == nullptr) { return to_string(root->val); } if (root->right == nullptr) { return to_string(root->val) + \"(\" + tree2str(root->left) + \")\"; } return to_string(root->val) + \"(\" + tree2str(root->left) + \")(\" + tree2str(root->right) + \")\"; } }; 应用 LCA问题 见图论中LCA问题 树的直径 以下同步在 树形dp 树的直径： 以下同步在 基本数据结构中 的树 不带边权(边权为1) 步骤: 任取一点，求距其最远点u(u一定为某条直径的一个端点) 再求距u最远点v，u与v即为所求 方法： bfs，dfs 见正文 详细证明：力扣官方解答：「算法导论习题解答 9-1 带边权 且边权可为正也可为负 方法： 树形dp 求挂到某个点的两条边的最大值 和 次大值，即所有向子树或父树延伸的最大深度 和 次大深度，但两者不能在同一棵延伸树上。 用dfs搜深度 树的最长路径int dfs(int u, int f){ // 记录 出发节点 f 防止重复遍历 int dist = 0; int d1 = 0, d2 = 0; for(int i = h[u]; ~ i; i = ne[i]){ int j = e[i]; if(j == f) continue; int d = dfs(j, u) + w[i]; dist = max(dist, d); if(d >= d1) d2 = d1, d1 = d; else if(d > d2) d2 = d; } ans = max(ans, d1 + d2); return dist; } 8 堆 完全二叉树： 定义 一棵深度为k且有 2^k -1个结点的二叉树称为满二叉树。 根据二叉树的性质2, 满二叉树每一层的结点个数都达到了最大值, 即满二叉树的第i层上有 2^(k -1)个结点 (i ≥ 1) 。 如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时, 称之为完全二叉树。从满二叉树和完全二叉树的定义可以看出, 满二叉树是完全二叉树的特殊形态, 即如果一棵二叉树是满二叉树, 则它必定是完全二叉树。 性质 1、具有n个结点的完全二叉树的深度 L log2(n) L+ 1（注：[ ]表示向下取整） 2、如果对一棵有n个结点的完全二叉树的结点按层序编号, 则对任一结点i (1≤i≤n) 有:如果i=1, 则结点i是二叉树的根, 无双亲;如果i>1, 则其双亲parent (i) 是结点[i/2]. 如果2i>n, 则结点i无左孩子, 否则其左孩子lchild (i) 是结点2i; 如果2i+1>n, 则结点i无右孩子, 否则其右孩子rchild (i) 是结点2i+1. 特点 完全二叉树的特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。 假设这棵完全二叉树有K层，因此我们可以总结一下完全二叉树的规律： 前K-2层：每个节点都有两个孩子，节点饱和 前K-1层：节点肯定是饱和的—>到达了最大值 第K-1层：不一定所有的节点都有孩子节点，如果有孩子节点，至少要是左孩子节点,有可能出现不饱和节点 完全二叉树判定 算法思路 判断一棵树是否是完全二叉树的思路1>如果树为空，则直接返回错 2>如果树不为空：层序遍历二叉树 2.1>如果一个结点左右孩子都不为空，则pop该节点，将其左右孩子入队列； 2.1>如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉树； 2.2>如果遇到一个结点，左孩子不为空，右孩子为空；或者左右孩子都为空，且则该节点之后的队列中的结点都为叶子节点，该树才是完全二叉树，否则就不是完全二叉树； 方法1: 从上面的规律中我们可以知道： 完全二叉树的前k-1层一定是包和节点，第k-1层就可能出现不饱和节点。 判断二叉树是否为一棵完全二叉树的关键就是找到第一个不饱和节点，再判断后续节点与当前不饱和节点的关系（即：找到第一个不饱和的节点之后，后序的所有节点不能有孩子节点才是完全二叉树）。 不饱和节点有： 只有左孩子 只有右孩子 没有孩子； 不饱和节点和后续节点的关系： 是叶子节点（没有孩子）或者只有左孩子的节点：也就是这两种不饱和的节点出现之后还需要判断后面的节点是否有孩子 只有右孩子没有左孩子：一定不是完全二叉树 综上，我们把代码的步骤理一下： 空树：返回true 树不为空：将根节点入队列，设置isLeafOrLeft=false（表示没有找到第一个不饱和节点），循环执行如下操作（循环条件：队列不为空）： 将队头元素出队列并标记：cur=queue.pop()； 找到第一个不饱和节点： 从第一个不饱和结点之后，所有节点不能有孩子，如果有左孩子或者右孩子：返回false 没有找到第一个不饱和节点，继续按照层序遍历寻找： cur节点（当前节点）左右孩子都存在：左孩子入队列，右孩子入队列 cur只有左孩子：即找到第一个不饱和节点，标记isLeafOrLeft=true cur只有右孩子：找到不饱和节点，一定不是完全二叉树，返回false cur是叶子节点：找到不饱和节点：标记isLeafOrLeft=true 方法二： 判断是否为完全二叉树的关键也是找到不饱和节点，但是第二个方法减少了各种不饱和节点的判断，在代码上减少了一定的代码量，同时思路也简洁了不少。 思路： 由于完全二叉树在每一层非空节点都是一个接一个连续分布的，不可能出现两个非空节点之间交叉一个空节点，因此： 我们可以通过层序遍历从上往下，从左往右将每一个节点（包括非空节点）都放到队列里 在出队列的过程中，如果遇到空节点，则跳出循环 跳出循环后，然后再判断队列中剩下的元素是否有非空节点： 有非空节点：非完全二叉树； 没有非空节点（全是空节点）：完全二叉树。 代码步骤： 1、树为空：返回true 2、树不为空：将二叉树的跟入队，并循环执行以下操作，循环条件：队列不为空；跳出循环条件：cur==null 取出队头元素，cur=queue.poll() 如果有左孩子：入队列 如果有右孩子：入队列 3、当通过条件：cur==null跳出循环后，判断队列里边是否还有非空元素 如果有非空元素：不是完全二叉树 没有非空元素：是完全二叉树 更简单的思路：如何判断一棵二叉树是完全二叉树 任意的一个二叉树，都可以补成一个满二叉树。这样中间就会有很多空洞。在广度优先遍历的时候，如果是满二叉树，或者完全二叉树，这些空洞是在广度优先的遍历的末尾，所以，但我们遍历到空洞的时候，整个二叉树就已经遍历完成了。而如果，是非完全二叉树， 我们遍历到空洞的时候，就会发现，空洞后面还有没有遍历到的值。这样，只要根据是否遍历到空洞，整个树的遍历是否结束来判断是否是完全的二叉树。 bool is_complete(TreeNode *root) { if(root == nullptr) return true; queue q; TreeNode* tmp = nullptr; q.push(root); // 进行广度优先遍历（层次遍历），并把NULL节点也放入队列 while (tmp = q.front()) { q.pop(); q.push(tmp->left); q.push(tmp->right); } // 判断是否还有未被访问到的节点 while (q.size()) { tmp = q.pop(); // 有未访问到的的非NULL节点，则树存在空洞，为非完全二叉树 if (nullptr != tmp) // if(tmp) { return false; } } return true; } 根据以下性质可用于堆： 完全二叉树：除了最后一层节点，其他节点都有两个子节点。且最后一层节点从左到右分布。 满足： 1、左右子树的节点数满足 Ln/Rn=1 2、左右子树高度满足 Rh+1>=Lh>=Rh 3、子节点值统一比父节点大（小）。 最大堆：2叉树的所有子节点都比不父节点大。所以根节点是最大的。 最小堆：2叉树的所有子节点都比不父节点小。所以根节点是最小的。 如何手写一个堆？ （以小顶堆为例） 插入一个数 heap[++size] = x; up[size]; 求集合当中的最小值 heap[1] 删除最小值 heap[1]=heap[size]; size--; down(1); 用最后一个元素覆盖堆顶，再down操作（因为是用数组模拟，删除头节点困难，而删除尾节点方便，y总奇妙比喻：干掉最后一个巡逻兵） 删除任意一个元素 heap[k]=heap[size];size--;down(k);up(k);(只会执行一个!而非必定执行down吧，虽然把size位置的数替换到k了，但size和k如果不在同一棵子树上就需要up) 修改任意一个元素 heap[k]=x;down(k);up(k);(不清楚会改大还是改小，但只会执行一个) 堆排序，也叫二叉堆排序。 堆排序 模拟堆 建堆：假设最多有N个数据。开辟一段用来存这N个数据的空间。根节点位置为0。其子节点位置为1、2。所有子节点位置与父节点的位置（k）关系：k，2k+1，2k+2。 假设已经有了n个数据，那么新数据自然放在n位（因为位置是从0开始），定义一个函数 shift_up() 用来调整新数据。它的功能是：将新数据与 (n-1)/2 位置的数据（新数据的父节点）比较，如果比父节点大，那么就交换，继续比较，直到它比父节点小。 重新建堆： 当取数据时，就是将根节点取出来。因为根节点是最大的，所以自然还要将其所有子节点进行调整，以保证剩下的数据的根节点是最大的。方法是：将最后一个数放到根节点位置（因为根节点取出后，根节点就空了），然后调用 shift_down()函数将其与1、2位置的数比较，如果比它大，则交换，然后继续与2k+1，2k+2位置的比较，直到这两个位置的数都比它小。 // 带删除 和 修改任意元素的堆 // 不带就话直接把heap_swap替换成默认的swap(h[u],h[t])即可 // h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 ，子节点为x/2 // (因为此处从1开始索引) (如果从0开始，则左右分别为 2x+1，2x+2,子节点为(x-1)/2) // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) // 下沉，主要用于插入一个新节点 以及初始建堆时从n/2 -> 1 倒序down { int t = u; if (u * 2 >= 1; //继续上浮，直到父节点大于当前节点为止 } } // O(n)建堆 从倒数第二层的n/2开始往上调整 从下往上 依次down for (int i = n / 2; i; i -- ) down(i); 代码理解 Article: 如何理解AcWing模拟堆的实现过程？ hp数组维护插入顺序——>堆下标，hp[k] = i 由于down和up操作，导致hp数组映射关系更改, hp[k1] = i, hp[k2] = j ——>hp[k1] = j, hp[k2] = i 但是在down和up操作中并不知道原来的k1和k2，因此要么将k1和k2保存传入，要么再创建一个ph数组维护和记录。 从i=n/2处开始建堆，即down() 首先要明确要进行down操作时必须满足左儿子和右儿子已经是个堆。 开始创建堆的时候，元素是随机插入的，所以不能从根节点开始down，而是要找到满足下面三个性质的结点： 1.左右儿子满足堆的性质。 2.下标最大（因为要往上遍历） 3.不是叶结点（叶节点一定满足堆的性质） 那这个点为什么时n/2？看图。 在swap_heap里面 顺序可以交换，但是hp与ph不可交换？？ //这个交换过程其实有那么些绕 但关键是理解 如果hp[u]=k 则ph[k]=u 的映射关系 //之所以要进行这样的操作是因为 经过一系列操作 堆中的元素并不会保持原有的插入顺序 //从而我们需要对应到原先第K个堆中元素 //如果理解这个原理 那么就能明白其实三步交换的顺序是可以互换 //h,hp,ph之间两两存在映射关系 所以交换顺序的不同对结果并不会产生影响 举个栗子： hp[5]=1,ph[1]=5; 就像是函数与其反函数或积分与微分一样：ph[hp[1]]=1。 一般地，我们有 ph[hp[x]]=x ；ph[hp[y]]=y。 假如交换了hp[x]与hp[y]的值，则ph[hp[x]]=y，ph[hp[y]]=x； 因此，我们还需交换hp[ph[x]]与hp[ph[x]]的值，即 ph[hp[x]]=x ；ph[hp[y]]=y 注意，这道题我们需要的是交换的是存放堆中点的插入次序，即交换hp[x]与hp[y]的值，并不需要交换数组下标的值。 数据结构实现* 深浅拷贝 知识点： 深拷贝 复制带随机指针的链表class Solution { public: unordered_map cashedNode; Node* copyRandomList(Node* head){ if(head == nullptr) return nullptr; if(!cashedNode.count(head)){ // 没创建对应的则递归地进行创建 Node* headNew = new Node(head->val); cachedNode[head] = headNew; headNew->next = copyRandomList(head->next); headNew->random = copyRandomList(head->random); } return cashedNode[head]; } }; Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-10-15 17:58:00 "},"01_数据结构与算法笔记/01_学习笔记/02_搜索.html":{"url":"01_数据结构与算法笔记/01_学习笔记/02_搜索.html","title":"1.2 搜索","keywords":"","body":"搜索 包括BFS(Flood Fill、最短路模型、多源BFS、最小步数模型、双端队列广搜、双向广搜、A)、DFS(DFS之连通性模型、DFS之搜索顺序、DFS之剪枝与优化、迭代加深、双向DFS、IDA)等内容 BFS 一层层搜索 迭代，不会爆栈 用queue 空间 O(2^h) 可求最短路(对于权重均为1的边) 关键词： Flood Fill 最短路 多源BFS 最小步数模型 双端队列广搜(边权只有0和1的最短路) 双向广搜 A* DFS 一条路走到黑 递归(回溯) 用stack 空间 O(n) 不具有最短性 关键词：恢复现场(棋盘内部搜索不用、换个棋盘则需要？) 连通性 搜索顺序 剪枝与优化(已非最优或已无可行解) 迭代加深 双向DFS IDA* 树是一种无环连通图 图包括有向图和无向图，无向图可以看作有向图，即把每一条无向边看作两条有向图。 拓扑序列：针对有向无环图（DAG）来说。 用来判断是否存在环。 不唯一 方法：bfs 入度 出度统计 bfs 详情见图论 n为点数，m为边数（稠密图m~n^2,所以用朴素即可，稀疏图则用堆优化) 1 BFS 1 Blood Fill 求连通块数量，大小，类型。 AcWing: 池塘计数 城堡问题 山峰和山谷 力扣: 模板 2 最短路 迷宫问题 武士风度的牛 抓住那头牛 3 多源最短路 构建一个虚拟源点，根据需要是否真的把该点添加进来。 地图中的最高点 给你一个大小为 m x n 的整数矩阵 isWater ，它代表了一个由 陆地 和 水域 单元格组成的地图。 如果 isWater[i][j] == 0 ，格子 (i, j) 是一个 陆地 格子。 如果 isWater[i][j] == 1 ，格子 (i, j) 是一个 水域 格子。 你需要按照如下规则给每个单元格安排高度： 每个格子的高度都必须是非负的。 如果一个格子是 水域 ，那么它的高度必须为 0 。 任意相邻的格子高度差 至多 为 1 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边） 找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。 请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。如果有多种解法，请返回 任意一个 。 解： class Solution { public: vector> highestPeak(vector>& isWater) { int m = isWater.size(), n = isWater[0].size(); queue,int>> q; vector> st(m,vector(n,false)); vector> res(m,vector(n,0x3f3f3f3f)); for(int i = 0; i =0 && x =0 && y 4 最小步数模型 5 双端队列广搜 (边权只有0和1的最短路) 区别于一般bfs，把边权为0的放到队头，边权为1的才按照正常方式放到队尾。 但同时每个元素可能入队多次。(类似Dijkstra) 所以需要一个st数组。 同时使用deque结构。 电路维修 LCP-信物传送 class Solution { public: typedef pair PII; int dist[110][110]; //需要更改传送带的次数。 bool st[110][110]; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; //4个方向。上右下左。 char g[4] = {'^', '>', 'v', '& matrix, vector& start, vector& end) { int n = matrix.size(), m = matrix[0].size(); deque q; q.push_back({start[0], start[1]}); memset(dist, -1, sizeof dist); dist[start[0]][start[1]] = 0; while (q.size()) { auto t = q.front(); q.pop_front(); int x = t.first, y = t.second; //到终点，直接return if (x == end[0] && y == end[1]) return dist[x][y]; if (st[x][y]) continue; st[x][y] = true; for (int i = 0; i = n || b = m || st[a][b]) continue; if (g[i] == matrix[x][y]) { //如果当前前进的方向 和传送带一个方向 加入队头 q.push_front({a, b}); dist[a][b] = dist[x][y]; } else {//前进方向和传送带不是一个方向，加入队尾。 q.push_back({a, b}); //如果当前点被更新过, 则更新为最小值。 if (dist[a][b] != -1) dist[a][b] = min(dist[a][b], dist[x][y] + 1); else dist[a][b] = dist[x][y] + 1; } //cout 6 双向广搜 应用于最少步数模型 如A -> B 字串变换 最小基因变化 基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 'A'、'C'、'G' 和 'T' 之一。 假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。 例如，\"AACCGGTT\" --> \"AACCGGTA\" 就是一次基因变化。 另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。 给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。 注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。 示例 1： 输入：start = \"AACCGGTT\", end = \"AACCGGTA\", bank = [\"AACCGGTA\"] 输出：1 示例 2： 输入：start = \"AACCGGTT\", end = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"] 输出：2 示例 3： 输入：start = \"AAAAACCC\", end = \"AACCCCCC\", bank = [\"AAAACCCC\",\"AAACCCCC\",\"AACCCCCC\"] 输出：3 提示： start.length == 8 end.length == 8 0 解： 本题数据量过小。 直接bfs能过 双向bfs 注意技巧 class Solution { public: // 解法2：双向bfs int minMutation(string start, string end, vector& bank) { // 1：建立hashmap表，顺便去掉重复元素 unordered_map mp; for(const auto& b:bank)mp[b]=0; // 2：排除极端情况，end不在基因库中 if(mp.count(end)==0)return -1; // 3：bfs的初始化工作 queue q1({start}),q2({end});// 前向队列，后向队列 int step=0; const char table[4]={'A','C','G','T'};// 基因的字符 // 或1表示前向队列由前往后遍历，或2表示后向队列由后向前遍历，每次我们选用较小的队列进行遍历 for(mp[start]|=1,mp[end]|=2;q1.size()&&q2.size();++step)//每遍历完一次，步长+1 { bool first=q1.size() &q=first?q1:q2;// 选择较小的队列进行遍历节约时间 int flag=first?1:2;// 此次遍历的方式 for(int n=q.size();n--;q.pop()){ string& temp=q.front(); if(mp[temp]==3)return step;// 两个队列碰头，返回步长 for(int i=0;i 打开转盘锁 LC：单词接龙 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列beginWord -> s1 -> s2 -> ... -> sk： 每一对相邻的单词只差一个字母。 对于 1 \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", 返回它的长度 5。 示例 2： 输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] 输出：0 解释：endWord \"cog\" 不在字典中，所以无法进行转换。 提示： 1 解：双向bfs class Solution { string A, B; set st; int extend(queue& q, unordered_map& da, unordered_map& db){ int d = da[q.front()]; while(q.size() && da[q.front()] == d){ auto u = q.front(); q.pop(); for(int i = 0; i da, db; queue qa, qb; qa.push(A), qb.push(B); da[A] = 0; db[B] = 0; int t = -1; while(qa.size() && qb.size()){ if(qa.size() & wordList) { A = beginWord, B = endWord; st.clear(); for(auto s : wordList) st.insert(s); if(!st.count(endWord)) return 0; return bfs(); } }; 7 A* PNC:图搜索基础算法，用于路径或速度规划 先上题目： 八数码 详情可见基本算法部分中的逆序对问题。 ★★★★★第K短路 相似度为 K 的字符串 相似度为 K 的字符串 对于某些非负整数 k ，如果交换 s1 中两个字母的位置恰好 k 次，能够使结果字符串等于 s2 ，则认为字符串 s1 和 s2 的 相似度为 k 。 给你两个字母异位词 s1 和 s2 ，返回 s1 和 s2 的相似度 k 的最小值。 示例 1： 输入：s1 = \"ab\", s2 = \"ba\" 输出：1 示例 2： 输入：s1 = \"abc\", s2 = \"bca\" 输出：2 提示： 1 解： 1.bfs+剪枝 class Solution { public: int kSimilarity(string s1, string s2) { int n = s1.size(); queue> q; q.emplace(s1, 0); unordered_set vis; vis.emplace(s1); for(int step = 0; ; ++ step){ int sz = q.size(); for(int i = 0; i 2.A* class Solution { public: int minSwap(const string &s1, const string &s2, const int &pos) { int tot = 0; for (int i = pos; i State; int n = s1.size(); priority_queue, greater> pq; unordered_set visit; pq.emplace(0, 0, 0, s1); visit.emplace(s1); while (!pq.empty()) { auto [_, cost, pos, cur] = pq.top(); pq.pop(); if (cur == s2) { return cost; } while (pos 2 DFS 对于BFS求最小步数(但存在占用空间太大问题，最多存储每层的数，且难以剪枝)，dfs亦能实现。通过两种方式： 1. 记全局最小值 2. 迭代加深？？ 1 连通性 2 搜索顺序 3 剪枝与优化(已非最优或已无可行解) 回溯 dfs+剪枝 = 回溯 适用于组合数相当大按 [深度优先策略] ，根节点出发搜索空间树，搜索任意节点是否包含问题的解，不包含回溯，否则，继续进行深度优先搜索 通过 [剪枝函数] 约束条件 (constraint) 在扩展结点处减去不满足约束的子树；用限界函数（bound）剪去得不到最优解的子树（假如我们只需要最优解的时候用） 避免不必要搜索的穷举式搜索 回溯和深度优先搜索的区别 回溯是一种更通用的算法。可以用于任何类型的结构，其中可以消除域的部分 ——无论它是否是逻辑树。 深度优先搜索是与搜索树或图结构相关的特定回溯形式。它使用回溯作为其使用树的方法的一部分，但仅限于树/图结构。 回溯和 DFS 之间的区别在于回溯处理隐式树而 DFS 处理显式树。这似乎微不足道，但它意味着很多。当通过回溯访问问题的搜索空间时，隐式树在其中间被遍历和修剪。然而对于 DFS 来说，它处理的树/图是明确构造的，并且在完成任何搜索之前已经抛出了不可接受的情况，即修剪掉了。 因此，回溯是隐式树的 DFS，而 DFS 是回溯而不修剪。 3、回溯法模版 回溯法的基本思想： 针对所给问题，定义问题的解空间； 确定易于搜索的解空间结构； 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。 划分为k个相等的子集 给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 示例 1： 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 示例 2: 输入: nums = [1,2,3,4], k = 3 输出: false 提示： 1 解： 状态压缩 + 记忆化搜索 题目给定长度为 n 的数组nums，和整数 k，我们需要判断是否能将数组分成 k个总和相等的非空子集。首先计算数组的和 SUM，如果 SUM 不是 k 的倍数，那么不可能能有合法方案，此时直接返回 False。否则我们需要得到 k 个和为sum = SUM/k,的集合，那么我们每次尝试选择一个还在数组中的数，若选择后当前已选数字和等于 sum 则说明得到了一个集合，而已选数字和大于 sum 时，不可能形成一个集合从而停止继续往下选择新的数字。又因为 n 满足 1≤n≤16，所以我们可以用一个整数 S 来表示当前可用的数字集合：从低位到高位，第 i 位为 1 则表示数字 nums[i] 可以使用，否则表示nums[i] 已被使用。为了避免相同状态的重复计算，我们用 dp[S] 来表示在可用的数字状态为 S 的情况下是否可行，初始全部状态为记录为可行状态 True。这样我们就可以通过记忆化搜索这种「自顶向下」的方式来进行求解原始状态的可行性，而当状态集合中不存在任何数字时，即 S = 0时，表示原始数组可以按照题目要求来进行分配，此时返回 True 即可 同时为了更快剪枝，可将nums数组降序。 class Solution { public: bool canPartitionKSubsets(vector& nums, int k) { int SUM = accumulate(nums.begin(), nums.end(), 0); if(SUM % k) return false; int sum = SUM / k; sort(nums.begin(), nums.end(), greater<>()); if(nums[0] > sum) return false; int n = nums.size(); vector dp(1 dfs = [&](int s, int p)->bool { if(s == 0) return true; if(!dp[s]) return dp[s]; dp[s] = false; for(int i = 0;i sum) continue; //break; if((s >> i) & 1){ if(dfs(s ^ (1 参考： 回溯与DFS 4 迭代加深 5 双向DFS 6 IDA* 对dfs的优化 以下均为随机算法 1.模拟退火 2.爬山 3 模拟退火 oi-wiki 模拟退火是一种随机化算法。当一个问题的方案数量极大（甚至是无穷的）而且不是一个单峰函数时，我们常使用模拟退火求解。 模拟退火，顾名思义，是模拟「退火」的过程。当我们使用爬山算法的时候，对于非单峰函数的情形容易陷入次优解。爬山算法省略了最优解附近的非最优解从而想得到更优的答案，但是模拟退火试图以一定概率接受这个解。这个事情的实现即为「模拟退火」算法。（胡扯） 由于退火的过程有更多随机的选择因素，我们得到最优解的概率也会增加。 注意卡时间： C++ 里面自带一个函数 clock() ，返回的是程序运行时间（单位是微秒），除以 CLOCKS_PER_SEC 就是运行秒数。所以我们可以这样： while (clock() / (1.0 * CLOCKS_PER_SEC) 1.基础 速通模拟退火（Simulated Annealing） 1.是什么？为什么？怎么做？ Q1:模拟退火是什么算法？ 模拟退火是模拟物理上退火方法，通过N次迭代（退火），逼近函数的上的一个最值（最大或者最小值）。 比如逼近这个函数的最大值C点： Q2:模拟退火为什么可行？ 讨论这个问题需要理解一下物理原型是怎么样的，也就是原来是怎么“退火”的： 模拟退火算法的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。 注意标粗字体： 温度高->运动速度快（温度低->运动速度慢） 温度是缓慢（想象成特别慢的那种）降低的 温度基本不再变化后，趋于有序(最后内能达到最小，也就是接近最优) 我们通过模拟这个操作，使得我们需要的答案“趋于有序”，也就是最靠近需要的值（最值）。 Q3:怎么做？ 大方向 首先，理解一下大方向： 模拟退火就是一种循环算法。 1.我们先设定一个初始的温度T（这个温度会比较高，比如2000） 2.每次循环都退火一次。（具体怎么操作后面详解） 3.然后降低T的温度，我们通过让T和一个“降温系数”ΔT（一个接近1的小数，比如0.99)相乘，达到慢慢降低温度的效果，直到接近于0（我们用eps来代表一个接近0的数(比如0.00001)，只要T double T = 2000; //代表开始的温度 double dT = 0.99; //代表系数delta T double eps = 1e-14; //相当于0.0000000000000001 while(T > eps) { //-------------- //这里是每一次退火的操作 //-------------- T = T * dT; //温度每次下降一点点， T * 0.99 } 退火详解 我们要求解的答案无非是两个：自变量x和对应函数的最大值f(x) 那么模拟退火的是怎么做到的呢？【下面车速很快，请系好安全带！】 1.我们先随机找一点x0 ，不论是哪个点都可以，随机！（不超过定义域就行）。 这个点作为我们的初始值（相当于物体里的一个粒子） 2.再找到一点f(x0),来代表x0所对应的函数值 3.现在正式开始退火！ 刚才我们说了x0相当于是一个粒子，所以我们会进行一个无序运动，也就是向左或者向右随机移动 是的，是随机移动，可能向左，也可能向右，但是请记住一个关键点：移动的幅度和当前的温度T有关。 温度T越大，移动的幅度越大。温度T越小，移动的幅度就越小。这是在模拟粒子无序运动的状态。 4.接受(Accept)更\"好\"的状态 假设我们移动到了x1处，那么这个点对应的f(x1)很明显答案是优于（大于）当前的f(x0)的 因此我们将答案进行更新。也就是将初始值进行替换：x0=x1,f(x0)=f(x1)。这是一种贪心的思想。 5.以一定概率接受(Accept)更差的状态 这是退火最精彩的部分。 为什么我们要接受一个更加差的状态呢？因为可能在一个较差的状态旁边会出现一个更加高的山峰 如果我们鼠目寸光，只盯着右半区，很容易随着温度的下降、左右跳转幅度的减小而迷失自己，最后困死在小山丘中。 而我们如果找到了左边山峰的低点，以一定的概率接受了它（概率大小和温度以及当前的值的关键程度有关），会在跳转幅度减少之前，尽可能找到最优点。 那么我们以多少的概率去接受它呢？我们用一个公式表示（这个公式我们只需记住，这是科学家推导出来的结论）： e^(Δf/kT) 别慌！很简单！我们来理解一下这里面的变量： e是自然对数，约等于2.71。我们可以把右上角这一坨值Δf/kT看成一个整体x: e^x的图形画出来是这样的： 因为我们想要函数e^x来代表一个概率值，所以我们只需要关注x为负数的部分即可： 负数部分的值域是在(0,1)开区间内，x越小，越接近0，越大越靠近1 因为在0到1之间，所以这个值相当于是概率了。比如e^x=0.97，那么我们接受的概率就是97% 而正数部分的值域会大于1，也就是说概率会超过100%，所以会一定选（其实是上一种找到更优的情况） kT k其实是个物理学常数，我们在代码中不会用到。 T很简单，就是当前的温度。所以实际上这个分母就是T，k当做1使用。 Δf 我们着重讲一下什么是Δf。 其实从前面的函数e^x中可以发现，Δf必须是个负数！ 我们想要函数e^x来代表一个概率值，一定要让它的值域属于(0,1)，所以Δf/kT必须是个负数。但是kT在我们的模拟中一定是正数，那么Δf必须是个负数！ 其实Δf就是当前解的函数值与目标解函数值之差，Δf=−|f(x0)−f(x1)|，并且一定是个负数。这个需要具体问题具体分析。 比如现在我们求一个函数的最大值，那么如果f(x0)了，那就说明结果变好了，我们肯定选择它（见第4点） 如果f(x0)>f(x1)，那就说明结果变差了，我们需要概率选择它，因此Δf=−(f(x0)−f(x1)) 所以总结一下就是： 随机后的函数值如果结果更好，我们一定选择它(即x0=x1,f(x0)=f(x1)) 随机后的函数值如果结果更差，我们以e^(Δf/kT)的概率接受它 关于接受概率ex和Δf以及kT的关系： 当kT越大时(温度越高)，由于Δf是一个负数，所以算出来的值会越大。比如-1 / 1000 等于 -0.001，很明显-0.001 > -1，由于ex是个单调递增函数，所以温度越高时，接受的概率就越大。 Δf越小，说明答案越糟糕，那么接受的概率就越小。 伪代码流程 注：对代码中的函数作出解释： ①对rand()函数 1.rand()函数可以默认拿到[0,32767]内的随机整数 2.RAND_MAX = 32767，可以看作常量。本质是宏定义: #define RAND_MAX 32767 3.rand() 2 的范围是[0,32767 2] 4.rand() 2 - RAND_MAX 的范围是[-32767, 32767] ②对exp()函数 exp(x)代表e^x ③关于exp((df - f) / T) RAND_MAX > rand() 1.目的是要概率接受，但是ex是个准确值，所以从理论上我们可以生成一个（0,1）的随机数，如果ex比(0,1)这个随机数要大，那么我们就接受。 2.但是由于rand()只能产生[0,32767]内的随机整数，化成小数太过麻烦。所以我们可以把左边乘以RAND_MAX（也就是把概率同时扩大32767倍），效果就等同于ex比(0,1)了。 double T = 2000; //代表开始的温度 double dT = 0.99; //代表系数delta T double eps = 1e-14; //相当于0.0000000000000001 //用自变量计算函数值,这里可能存在多个自变量对应一个函数值的情况，比如f(x,y) double func(int x, ... ) { //这里是对函数值进行计算 double ans = ....... return ans; } //原始值 double x = rand(); //x0取随机值 double f = func(x,...); //通过自变量算出f(x0)的值 while(T > eps) { //-------------- //这里是每一次退火的操作 //x1可以左右随机移动，幅度和温度T正相关，所以*T //注意这里移动可以左右移动，但是也可以单向移动 //关于rand()详细见开头注的① double dx = x + (2*rand() - RAND_MAX) * T; //让x落在定义域内，如果没在里面，就重新随机。题目有要求需要写，否则不用写 // ================ while(x > ? || x rand()) { f = df; x = dx; [...y = dy;] // 接受，替换值，如果多个自变量，那么都替换 } //-------------- T = T * dT; //温度每次下降一点点， T * 0.99 } //最后输出靠近最优的自变量x值，和函数值f(x) cout 2.应用 2.1 开根号 通过模拟退火算出√n的值 思路是这样的：我们试图通过退火找出一个值x0，使得x0^2的值更加接近于√n^2。（记住退火是让一个随机值去逼近最后的答案） 因为x0^2的值更加接近于√n^2。因此x0值就更加接近于√n 1.所以我们需要一个函数f(x)，算出x02和n−−√2的接近程度，那么毋庸置疑，我们需要算出他们绝对值的差。 f(x)=∣x^2−n∣ 也就是说我们的函数表达式就有了 //n代表我们最后函数要逼近的值 double n; //x表示我们随机产生的那个数的平方和n的靠近程度 double func(double x) { return fabs(x * x - n); } 2.写出退火函数SA() double T = 20000; //初始温度，初始温度主要是看题目开始需要跳转的幅度。 double dT = 0.993; //变化率，这里需要速度稍微慢一点，写0.995 或者 0.997都可以，但是越靠近1速度就越慢 const double eps = 1e-14; //10的-14次方已经非常小了，写这个大概率没问题 void SA() { //首先随机生成一个点x0，这里我用0代替。 double x = 0; //算出x平方和n的差距f(x0) double f = func(x); while(T > eps) { //这里x0既可以变小，也可以变大，所以我们正负都要进行一个跳转,算出变换后的点dx double dx = x + (2 * rand() - RAND_MAX) * T; //但是请注意，dx很明显要保证 >= 0才行，因为算术平方根的定义域是>=0，因此小于0就重新随机 while(dx rand()) { //注意更新所有变量 f = df; x = dx; } //温度下降一下 T *= dT; } printf(\"%.8lf\",x); } 最后贴上完整代码和注释供大家调试。 #include using namespace std; //n代表我们最后函数要逼近的值 double n; //x表示我们随机产生的那个数的平方和n的靠近程度 double func(double x) { return fabs(x * x - n); } double T = 20000; //初始温度，初始温度主要是看题目开始需要跳转的幅度。 double dT = 0.993; //变化率，这里需要速度稍微慢一点，写0.995 或者 0.997都可以，但是越靠近1速度就越慢 const double eps = 1e-14; //10的-14次方已经非常小了，写这个大概率没问题 void SA() { //首先随机生成一个点x0，这里我用0代替。 double x = 0; //算出x平方和n的差距f(x0) double f = func(x); while(T > eps) { //这里x0既可以变小，也可以变大，所以我们正负都要进行一个跳转,算出变换后的点dx double dx = x + (2 * rand() - RAND_MAX) * T; //但是请注意，dx很明显要保证 >= 0才行，因为算术平方根的定义域是>=0，因此小于0就重新随机 while(dx rand()) { //注意更新所有变量 f = df; x = dx; } //温度下降一下 T *= dT; } printf(\"%.8lf\",x); } int main() { cin >> n; SA(); } 2.2 连续区间内最值 星星还是树 给出平面上N（N 解： 1.模拟退火法 一次模拟退火中温度tt需要覆盖数据范围的3倍,比如题目中[0, 1e4],当t=1e4时新的x或y 的范围是[x−t,x+t]=[−1e4,2e4]区间范围是3e4,这大概是因为这符合正态分布3δ3δ覆盖了 绝大部分(大概96%)数据范围. 时间复杂度 每一个t计算距离和O(n) ,每次t都乘0.9,所以总的时间复杂度是O(nlogt) . 由于一次模拟退火时间复杂度很小故而进行多次模拟退火选取最小的距离作为答案 #include #include #include #include #include #include #include using namespace std; const int N = 110; typedef pair PDD; #define x first #define y second int n; PDD q[N]; double ans = 1e8; double rand(double l, double r){ return (double)rand() / RAND_MAX * (r - l) + l; } double get_dist(PDD a, PDD b){ double dx = a.x - b.x; double dy = a.y - b.y; return sqrt(dx * dx + dy * dy); } double cal(PDD p){ double res = 0; for(int i = 0; i 1e-4; t *= 0.9){ PDD np(rand(cur.x - t, cur.x + t), rand(cur.y - t, cur.y + t)); double dt = cal(np) - cal(cur); if(exp(- dt / t) > rand(0, 1)) cur = np; // 妙啊 } } int main() { scanf(\"%d\", &n); for(int i = 0; i 2.三分法？？ 最小球覆盖——模拟退火&&三分套三分套三分 (三分套三分) 距离最小点在多边形内部 先三分x维度，然后在三分x维的基础上三分y维度 三分套三分 求z=x2+y2的最小值，根据多元函数求偏导，二阶导数大于0，凹函数，存在最小值，有多元函数微分学味了。 固定x，三分求y，一般这样求多个变量的，一般可以先固定一个！ 一行语句实现浮点数的四舍五入printf(\"%d\",(int)(check(l) + 0.5)); // 浮点数四舍五入，学到了！ 时间复杂度O(logn∗logn∗n) #include #include using namespace std; const int N = 110; #define eps 1e-4 int n; int x[N],y[N]; double dis(double x1,double y1) { double sum = 0.0; for(int i =0;i eps) { double mid = (l + r) / 2; double mmid = (mid + r) / 2; if(dis(x1, mid) > dis(x1, mmid)) l = mid; else r = mmid; // 这里是r = mmid; } return dis(x1,l); } int main() { cin >> n; for(int i = 0;i > x[i] >> y[i]; double l = 0.0,r = 10000.0; while(r - l > eps) // 三分x { double mid = (l + r) / 2; double mmid = (mid + r) / 2; if(check(mid) > check(mmid)) l = mid; else r = mmid; // 这里是r = mmid; } printf(\"%d\",(int)(check(l) + 0.5)); // 浮点数四舍五入，学到了！ return 0; } 均分数据 输入样例： 6 3 1 2 3 4 5 6 输出样例： 0.00 1.模拟退火 #include #include #include #include using namespace std; const int N = 25, M = 10; int n, m; int w[N], s[M]; double ans = 1e8; double calc() { memset(s, 0, sizeof s); for (int i = 0; i 1e-6; t *= 0.95) { int a = rand() % n, b = rand() % n; double x = calc(); swap(w[a], w[b]); double y = calc(); double delta = y - x; if (exp(-delta / t) > n >> m; for (int i = 0; i > w[i]; for (int i = 0; i 贪心 我们可以用random_shuffle()用来对原数据进行重新排序，然后利用贪心的思想（每次把数加在最小的组里），即可满足均方差最小。 用while ((double)clock()/CLOCKS_PER_SEC来卡时。 #include using namespace std; #define pb push_back #define mp(aa,bb) make_pair(aa,bb) #define _for(i,b) for(int i=(0);i=(a);i--) #define mst(abc,bca) memset(abc,bca,sizeof abc) #define X first #define Y second #define lowbit(a) (a&(-a)) #define debug(a) cout pii; typedef unsigned long long ull; typedef long double ld; const int N=25; const int INF=0x3f3f3f3f; const int mod=1e9+7; const double eps=1e-6; const double PI=acos(-1.0); int n,m; double x[N],s[N]; double ans=INF,aver; void calc(){ double tmp=aver*aver*m-2*aver*aver*m; random_shuffle(x+1,x+1+n); mst(s,0); rep(i,1,m) s[i]=x[i]; rep(i,m+1,n){ int p=min_element(s+1,s+m+1)-s;//找出最小的位置 s[p]+=x[i]; } double sum=0; rep(i,1,m) sum+=s[i]*s[i]; ans=min(ans,sum+tmp); } void solve(){ cin>>n>>m; aver=0; rep(i,1,n) cin>>x[i],aver+=x[i]; aver/=m; while ((double)clock()/CLOCKS_PER_SEC>t;while(t--) solve(); return 0; } 2.3 常规问题退火解法 串联字符串的最大长度 给定一个字符串数组 arr，字符串 s 是将 arr 的含有 不同字母 的 子序列 字符串 连接 所得的字符串。 请返回所有可行解 s 中最长长度。 子序列 是一种可以从另一个数组派生而来的数组，通过删除某些元素或不删除元素而不改变其余元素的顺序。 示例 1： 输入：arr = [\"un\",\"iq\",\"ue\"] 输出：4 解释：所有可能的串联组合是： \"\" \"un\" \"iq\" \"ue\" \"uniq\" (\"un\" + \"iq\") \"ique\" (\"iq\" + \"ue\") 最大长度为 4。 示例 2： 输入：arr = [\"cha\",\"r\",\"act\",\"ers\"] 输出：6 解释：可能的解答有 \"chaers\" 和 \"acters\"。 示例 3： 输入：arr = [\"abcdefghijklmnopqrstuvwxyz\"] 输出：26 剪枝 DFS 回溯 位运算 class Solution { public: int maxLength(vector &arr) { vector masks; for (string &s : arr) { int mask = 0; for (char ch : s) { ch -= 'a'; if ((mask >> ch) & 1) { // 若 mask 已有 ch，则说明 s 含有重复字母，无法构成可行解 mask = 0; break; } mask |= 1 0) { masks.push_back(mask); } } int ans = 0; function backtrack = [&](int pos, int mask) { if (pos == masks.size()) { ans = max(ans, __builtin_popcount(mask)); return; } if ((mask & masks[pos]) == 0) { // mask 和 masks[pos] 无公共元素 backtrack(pos + 1, mask | masks[pos]); } backtrack(pos + 1, mask); }; backtrack(0, 0); return ans; } }; 2.二进制枚举 class Solution { public: int maxLength(vector& arr) { int n = arr.size(); int ans = 0; for( int i = 0; i 1 ) { ok = false; break; } } } if( !ok ) break; } if( ok ) ans = max( ans, accumulate(f, f + 26, 0) ); } return ans; } }; 3.01背包+掩码 1.2.背包大小为26。 vector dp[i]表示占用背包空间i时，可能的字符串序列集合（所有字符串均使用位运算转化为int）。 vector> dp(27, vector{}); 3.string->int： ans |= 1 int str2bin(string& str){ int ans = 0; for(auto c:str){ if((ans & (1& arr) { vector> dp(27, vector{}); dp[0] = {0}; for(auto str:arr){ int len=str.size(); int bin=str2bin(str); if(bin=len; i--){ if(dp[i-len].size()){ for(auto item:dp[i-len]){ if((item & bin)==0){ dp[i].push_back(item|bin); } } } } } for(int i=26;i>=0;i--){ if(dp[i].size()) return i; } return 0; } 3.模拟退火 class Solution { vector a; int n, ans = 0; int enegry(){ int res = 0, mask = 0; for(int i = 0; i > i & 1) res ++; return res; } void sa(){ srand(time(NULL)); random_shuffle(a.begin(), a.end()); for(int t = 1e6; t > 1e-6; t *= 0.95){ int i = rand() % n, j = rand() % n; int ei = enegry(); swap(a[i], a[j]); int ej = enegry(); ans = max({ans, ei, ej}); int de = ei - ej; if(de = rand()) continue; swap(a[i], a[j]); } } public: int maxLength(vector& arr) { for(auto& s : arr){ int mask = 0, f = 1; for(auto c : s){ int i = c - 'a'; if((mask >> i) & 1){ f = 0; break; }else{ mask |= (1 n = a.size(); if(!n) return 0; for(int i = 0; i 其他能用模拟退火求解的问题有： 模拟退火——leetcode 如下： 1815. 得到新鲜甜甜圈的最多组数 1723. 完成所有工作的最短时间 1879. 两个数组最小的异或值之和 1655. 分配重复整数 1515. 服务中心的最佳位置 上题亦可用爬山法。 具体代码与解法： 1815. 得到新鲜甜甜圈的最多组数 有一个甜甜圈商店，每批次都烤 batchSize 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 所有 甜甜圈都必须已经全部销售完毕。给你一个整数 batchSize 和一个整数数组 groups ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 groups[i] 表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。 当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。 你可以随意安排每批顾客到来的顺序。请你返回在此前提下，最多 有多少组人会感到开心。 示例 1： 输入：batchSize = 3, groups = [1,2,3,4,5,6] 输出：4 解释：你可以将这些批次的顾客顺序安排为 [6,2,4,5,1,3] 。那么第 1，2，4，6 组都会感到开心。 示例 2： 输入：batchSize = 4, groups = [1,3,2,5,2,2,1,6] 输出：4 提示： 1 1.dfs+二进制(二进制模拟32进制)+状压 本题问题为：如何排列时，则有最多数量的下标的前缀和模 batchSizebatchSize 余 00 ？（此处前缀和不包括下标所在的数） 比如，示例一中： 6,2,4,5,1,3 66 左边的数的和为 00，模 33 余 00 ，ans++ ; 22 左边的数的和为 66，模 33 余 00 ，ans++ ; 44 左边的数的和为 88，模 33 余 22 ; 55 左边的数的和为 1212，模 33 余 00 ，ans++ ; 11 左边的数的和为 1717，模 33 余 22 ; 33 左边的数的和为 1818，模 33 余 00 ，ans++ 。 所以上述四个下标的顾客可以吃到新鲜的甜甜圈，ans=4 。 class Solution { typedef long long ll; unordered_mapM; int batchSize; //cur表示目前左边的余数，state表示剩余顾客的分布 int dfs(int cur,ll state){ if(M.count(state))return M[state]; if(!state)return M[state]=0; int res=0; for(int i=1;i>(i*5))%32){ int temp=dfs((cur+i)%batchSize,state-(1ll& groups) { batchSize=_batchSize; ll state=0; int mod0=0; for(int a:groups){ a%=batchSize; if(!a)mod0++;//余数为0直接贪心作为最左边的顾客 else state+=1ll 2.状压DP(极难)？？ int freq0[9], freq[9], w[9], f[300000]; class Solution { public: int maxHappyGroups(int b, vector& groups) { for(int i = 0; i 模拟退火 ```c++class Solution { public: int batchSize; int n; int ans = 0; vector groups; int energy() { int res = 1; for (int i = 0, s = 0; i } void SA() { srand(time(NULL)); //很重要 random_shuffle(groups.begin(), groups.end()); for(double t = 1e6; t > 1e-6; t *= 0.96) { int a = rand() % n, b = rand() % n; int ea = energy(); swap(groups[a], groups[b]); int eb = energy(); int dt = eb - ea; if(exp(-dt / t) > (double)rand() / RAND_MAX) continue; swap(groups[a], groups[b]); } } int maxHappyGroups(int _batchSize, vector& _groups) { //调整groups的顺序，使最多人开心 batchSize = _batchSize; groups = _groups; n = groups.size(); for(int i = 0; i } }; [1723. 完成所有工作的最短时间](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/) >给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。 请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。 返回分配方案中尽可能 最小 的 最大工作时间 。 示例 1： 输入：jobs = [3,2,3], k = 3 输出：3 解释：给每位工人分配一项工作，最大工作时间是 3 。 示例 2： 输入：jobs = [1,2,4,7,8], k = 2 输出：11 解释：按下述方式分配工作： 1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11） 2 号工人：4、7（工作时间 = 4 + 7 = 11） 最大工作时间是 11 。 提示： 1 & jobs, int k) { int n = jobs.size(); vector sum(1 > dp(k, vector(1 2.二分+回溯+剪枝 O(nlogn+log(S−M)×k^n) class Solution { public: bool backtrack(vector& jobs, vector& workloads, int idx, int limit) { if (idx >= jobs.size()) { return true; } int cur = jobs[idx]; for (auto& workload : workloads) { if (workload + cur & jobs, int k, int limit) { vector workloads(k, 0); return backtrack(jobs, workloads, 0, limit); } int minimumTimeRequired(vector& jobs, int k) { sort(jobs.begin(), jobs.end(), greater()); int l = jobs[0], r = accumulate(jobs.begin(), jobs.end(), 0); while (l > 1; if (check(jobs, k, mid)) { r = mid; } else { l = mid + 1; } } return l; } }; 3.模拟退火 class Solution { public: int ans = INT_MAX; vector jobs; int energy(int k) { int n = jobs.size(); vector s(k); for(int i = 0; i 1e-4) //降温过程 { T *= 0.92; int a = rand() % n, b = rand() % n; int ea = energy(k); swap(jobs[a], jobs[b]); int eb = energy(k); int dt = eb - ea; if(dt rand() / RAND_MAX) continue;//以一定概率接受 swap(jobs[a], jobs[b]);//不接受 } } int minimumTimeRequired(vector& _jobs, int k) { //每个工人至少分配一个工作 jobs = _jobs; for(int i = 0; i 1879. 两个数组最小的异或值之和 见状压dp部分的四种解法. 1655. 分配重复整数 给你一个长度为 n 的整数数组 nums ，这个数组中至多有 50 个不同的值。同时你有 m 个顾客的订单 quantity ，其中，整数 quantity[i] 是第 i 位顾客订单的数目。请你判断是否能将 nums 中的整数分配给这些顾客，且满足： 第 i 位顾客 恰好 有 quantity[i] 个整数。 第 i 位顾客拿到的整数都是 相同的 。 每位顾客都满足上述两个要求。 如果你可以分配 nums 中的整数满足上面的要求，那么请返回 true ，否则返回 false 。 示例 1： 输入：nums = [1,2,3,4], quantity = [2] 输出：false 解释：第 0 位顾客没办法得到两个相同的整数。 示例 2： 输入：nums = [1,2,3,3], quantity = [2] 输出：true 解释：第 0 位顾客得到 [3,3] 。整数 [1,2] 都没有被使用。 示例 3： 输入：nums = [1,1,2,2], quantity = [2,2] 输出：true 解释：第 0 位顾客得到 [1,1] ，第 1 位顾客得到 [2,2] 。 提示： n == nums.length 1 1.状压dp class Solution { public: bool canDistribute(vector& nums, vector& quantity) { unordered_map cache; for (int x: nums) { cache[x]++; } vector cnt; for (auto& kv: cache) { cnt.push_back(kv.second); } int n = cnt.size(), m = quantity.size(); vector sum(1 > dp(n, vector(1 0 && dp[i-1][j]) { dp[i][j] = true; continue; } for (int s = j; s != 0; s = ((s - 1) & j)) { // 子集枚举，详见 https://oi-wiki.org/math/bit/#_14 int prev = j - s; // 前 i-1 个元素需要满足子集 prev = j-s bool last = (i == 0) ? (prev == 0): dp[i-1][prev]; // cnt[0..i-1] 能否满足子集 prev bool need = sum[s] 1515. 服务中心的最佳位置 一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 到所有客户的欧几里得距离的总和最小 。 给你一个数组 positions ，其中 positions[i] = [xi, yi] 表示第 i 个客户在二维地图上的位置，返回到所有客户的 欧几里得距离的最小总和 。 换句话说，请你为服务中心选址，该位置的坐标 [xcentre, ycentre] 需要使下面的公式取到最小值： 与真实值误差在 10-5之内的答案将被视作正确答案。 提示： 1 官方解答：三种方法 1.梯度下降 class Solution { public: double getMinDistSum(vector>& positions) { double eps = 1e-7; double alpha = 1; double decay = 1e-3; int n = positions.size(); // 调整批大小 int batchSize = n; double x = 0.0, y = 0.0; for (const auto& pos: positions) { x += pos[0]; y += pos[1]; } x /= n; y /= n; // 计算服务中心 (xc, yc) 到客户的欧几里得距离之和 auto getDist = [&](double xc, double yc) { double ans = 0; for (const auto& pos: positions) { ans += sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc)); } return ans; }; mt19937 gen{random_device{}()}; while (true) { // 将数据随机打乱 shuffle(positions.begin(), positions.end(), gen); double xPrev = x; double yPrev = y; for (int i = 0; i 2.爬山 bug:(gitbook 导不出来两个连续的 { ) const int dirs[4][2] = { ,{1,0},{0,-1},{0,1}}; 处为{-1, 0} const int dirs[4][2] = \\{\\{-1, 0} ,{1,0},{0,-1},{0,1}}; class Solution { public: double getMinDistSum(vector>& positions) { double eps = 1e-7; double step = 1; double decay = 0.5; int n = positions.size(); double x = 0.0, y = 0.0; for (const auto& pos: positions) { x += pos[0]; y += pos[1]; } x /= n; y /= n; // 计算服务中心 (xc, yc) 到客户的欧几里得距离之和 auto getDist = [&](double xc, double yc) { double ans = 0; for (const auto& pos: positions) { ans += sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc)); } return ans; }; while (step > eps) { bool modified = false; for (int i = 0; i 3.三分 class Solution { public: double getMinDistSum(vector>& positions) { double eps = 1e-7; // 计算服务中心 (xc, yc) 到客户的欧几里得距离之和 auto getDist = [&](double xc, double yc) { double ans = 0; for (const auto& pos: positions) { ans += sqrt((pos[0] - xc) * (pos[0] - xc) + (pos[1] - yc) * (pos[1] - yc)); } return ans; }; // 固定 xc，使用三分法找出最优的 yc auto checkOptimal = [&](double xc) { double yLeft = 0.0, yRight = 100.0; while (yRight - yLeft > eps) { double yFirst = (yLeft + yLeft + yRight) / 3; double ySecond = (yLeft + yRight + yRight) / 3; if (getDist(xc, yFirst) eps) { // 左 1/3 点 double xFirst = (xLeft + xLeft + xRight) / 3; // 右 1/3 点 double xSecond = (xLeft + xRight + xRight) / 3; if (checkOptimal(xFirst) 4.模拟退火 class Solution { public: double sum(double x, double y, vector>& positions) { int n = positions.size(); double ans = 0; for (int i = 0; i >& positions) { int n = positions.size(); double step = 100; double x = positions[0][0]; double y = positions[0][1]; while (step > 1e-7) { bool flag = true; double rad = rand() % 360; while(flag) { flag = false; double nx = x + step * cos(rad); double ny = y + step * sin(rad); if (sum(nx, ny, positions) 4 遗传算法 主要思想： 遗传算法是根据达尔文的“适者生存，优胜劣汰”的思想来找到最优解的额，其特点是所找到的解是全局最优解，相对于蚁群算法可能出现的局部最优解还是有优势的。 遗传算法简介 遗传算法是用于解决最优化问题的一种搜索算法，算法的整体思路是建立在达尔文生物进化论“优胜劣汰”规律的基础上。它将生物学中的基因编码、染色体交叉、基因变异以及自然选择等概念引入最优化问题的求解过程中，通过不断的“种群进化”，最终得到问题的最优解。 遗传算法实现步骤 (a)初始化：设置进化代数计数器t=0，设置最大进化代数T，随机生成M个个体作为初始群体P(t)。 (b)个体评价：计算群体P(t)中各个个体的适应度。 (c)选择运算：将选择算子作用于群体。选择的目的是把优化的个体直接遗传到下一代或通过配对交叉产生新的个体再遗传到下一代。选择操作是建立在群体中个体的适应度评估基础上的。 (d)交叉运算：将交叉算子作用于群体。遗传算法中起核心作用的就是交叉算子。 (e)变异运算：将变异算子作用于群体。即是对群体中的个体串的某些基因座上的基因值作变动。群体P(t)经过选择、交叉、变异运算之后得到下一代群体P(t+1)。 (f)终止条件判断：若t=T,则以进化过程中所得到的具有最大适应度个体作为最优解输出，终止计算。 主要步骤： 1）种群初始化。我们需要首先通过随机生成的方式来创造一个种群，一般该种群的数量为100~500，这里我们采用二进制将一个染色体(解)编码为基因型。随后用进制转化，将二进制的基因型转化成十进制的表现型。 2）适应度计算(种群评估)。这里我们直接将目标函数值作为个体的适应度。 3）选择(复制)操作。根据种群中个体的适应度大小，通过轮盘赌等方式将适应度高的个体从当前种群中选择出来。其中轮盘赌即是与适应度成正比的概率来确定各个个体遗传到下一代群体中的数量。 具体步骤如下： (1)首先计算出所有个体的适应度总和Σfi。 (2)其次计算出每个个体的相对适应度大小fi/Σfi，类似于softmax。 (3)再产生一个0到1之间的随机数，依据随机数出现在上述哪个概率区域内来确定各个个体被选中的次数。 4）交叉(交配)运算。该步骤是遗传算法中产生新的个体的主要操作过程，它用一定的交配概率阈值(pc，一般是0.4到0.99)来控制是否采取单点交叉，多点交叉等方式生成新的交叉个体。 具体步骤如下： (1)先对群体随机配对。 (2)再随机设定交叉点的位置。 (3)再互换配对染色体间的部分基因。 5）变异运算。该步骤是产生新的个体的另一种操作。一般先随机产生变异点，再根据变异概率阈值(pm,一般是0.0001到0.1)将变异点的原有基因取反。 6）终止判断。如果满足条件(迭代次数，一般是200~500)则终止算法，否则返回step2。 在讲下面几个基于生物学提出的概念之前，首先我们需要理解为什么需要在最优化问题的求解中引入生物学中的各种概念。 假设我们需要求一个函数的最大值，但这个函数异常复杂以至于无法套用一般化的公式，那么就会想到：如果可以将所有可能的解代入方程，那么函数最大值所对应的那个解就是问题的最优解。但是，对于较复杂的函数来说，其可能的解的个数的数量级是我们所无法想象的。因此，我们只好退而求其次，只代入部分解并在其中找到最优解。那么这样做的核心就在于如何设定算法确定部分解并去逼近函数的最优解或者较好的局部最优解。 遗传算法就是为了解决上述问题而诞生的。假设函数值所对应的所有解是一个容量超级大的种群，而种群中的个体就是一个个解，接下去遗传算法的工作就是让这个种群中的部分个体去不断繁衍，在繁衍的过程中一方面会发生染色体交叉而产生新的个体。另一方面，基因变异也会有概率会发生并产生新的个体。接下去，只需要通过自然选择的方式，淘汰质量差的个体，保留质量好的个体，并且让这个繁衍的过程持续下去，那么最后就有可能进化出最优或者较优的个体。这么看来原来最优化问题居然和遗传变异是相通的，而且大自然早已掌握了这样的机制，这着实令人兴奋。为了将这种机制引入最优化问题并利用计算机求解，我们需要将上述提到的生物学概念转化为计算机能够理解的算法机制。 下面介绍在计算机中这种遗传变异的机制是如何实现的： 基因编码与解码： 在生物学中，交叉与变异能够实现是得益于染色体上的基因，可以想象每个个体都是一串超级长的基因编码，当两个个体发生交叉时，两条基因编码就会发生交换，产生的新基因同时包含父亲和母亲的基因编码。在交叉过程中或者完成后，某些基因点位又会因为各种因素发生突变，由此产生新的基因编码。当然，发生交叉和变异之后的个体并不一定优于原个体，但这给了进化(产生更加优秀的个体)发生的可能。 因此，为了在计算机里实现交叉和变异，就需要对十进制的解进行编码。对于计算机来说其最底层的语言是由二进制0、1构成的，而0、1就能够被用来表示每个基因点位，大量的0、1就能够表示一串基因编码，因此我们可以用二进制对十进制数进行编码，即将十进制的数映射到二进制上。但是我们并不关心如何将十进制转换为二进制的数，因为计算机可以随机生成大量的二进制串，我们只需要将办法将二进制转化为十进制就可以了。 二进制转换为十进制实现方式： 假设，我们需要将二进制映射到以下范围： x ∈[-1, 1] 首先，将二进制串展开并通过计算式转化为[0,1]范围内的数字： alpha = (累乘(g_i 2 ^(n - i)))/(2 ^ n - 1) 将[0,1]范围内的数字映射到我们所需要的区间内： x = alpha (x ^ up - x ^ button) + x ^ button 交叉与变异： 在能够用二进制串表示十进制数的基础上，我们需要将交叉与变异引入算法中。假设我们已经获得两条二进制串(基因编码)，一条作为父亲，一条作为母亲，那么交叉指的就是用父方一半的二进制编码与母方一半的二进制编码组合成为一条新的二进制串(即新的基因)。变异则指的是在交叉完成产生子代的过程中，二进制串上某个数字发生了变异，由此产生新的二进制串。当然，交叉与变异并不是必然发生的，其需要满足一定的概率条件。一般来说，交叉发生的概率较大，变异发生的概率较小。交叉是为了让算法朝着收敛的方向发展，而变异则是为了让算法有几率跳出某种局部最优解。 自然选择： 在成功将基因编码和解码以及交叉与变异引入算法后，我们已经实现了让算法自动产生部分解并优化的机制。接下去，我们需要解决如何在算法中实现自然选择并将优秀的个体保留下来进而进化出更优秀的个体。 首先我们需要确定个体是否优秀，考虑先将其二进制串转化为十进制数并代入最初定义的目标函数中，将函数值定义为适应度。在这里，假设我们要求的是最大值，则定义函数值越大，则其适应度越大。那是否在每一轮迭代过程中只需要按照适应度对个体进行排序并选出更加优秀的个体就可以了呢？事实上，自然选择的过程中存在一个现象，并没有说优秀的个体一定会被保留，而差劲的个体就一定被会被淘汰。自然选择是一个概率事件，越适应环境则生存下去的概率越高，反之越低。为了遵循这样的思想，我们可以根据之前定义的适应度的大小给定每个个体一定的生存概率，其适应度越高，则在筛选时被保留下来的概率也越高，反之越低。 那么问题就来了，如何定义这种生存概率，一般来说，我们可以将个体适应度与全部个体适应度之和的比率作为生存概率。但我们在定义适应度时使用函数值进行定义的，但函数值是有可能为负的，但概率不能为负。因此，我们需要对函数值进行正数化处理，其处理方式如下： 定义适应度函数： fitness_i = y_i - min(y) + 0.0001 定义生存概率函数： belta = fitness_i / sum(fitness) 注：最后一项之所以加上0.0001是因为不能让某个个体的生存概率变为0，这不符合自然选择中包含的概率思想。 遗传算法优缺点 优点： 1、 通过变异机制避免算法陷入局部最优，搜索能力强 2、 引入自然选择中的概率思想，个体的选择具有随机性 3、 可拓展性强，易于与其他算法进行结合使用 缺点： 1、 遗传算法编程较为复杂，涉及到基因编码与解码 2、 算法内包含的交叉率、变异率等参数的设定需要依靠经验确定 3、 对于初始种群的优劣依赖性较强 . 相关术语 基因型(genotype)：性状染色体的内部表现； 表现型(phenotype)：染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现； 进化(evolution)：种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的。 适应度(fitness)：度量某个物种对于生存环境的适应程度。 选择(selection)：以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程。 复制(reproduction)：细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。 交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交； 变异(mutation)：复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状。 编码(coding)：DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射。 解码(decoding)：基因型到表现型的映射。 个体（individual）：指染色体带有特征的实体； 种群（population）：个体的集合，该集合内个体数称为种群 案例： 现在我以一个多元函数最值问题求解来一步步阐述遗传算法的实现过程。 问题：求一个多元函数的最大值，f(x1,x2) = 21.5+x1sin(4pix1)+x2sin(20pix2)，其中-3.0≤x1≤12.1,4.1≤x2≤5.8。 5.1. 设计与实现 (a)前提条件： const int Po_Size = 50;//种群规模 const int Ev_Algebra = 500;//进化代数 const double Ov_Probability = 0.850; //交叉概率,交叉概率用于判断两两个体是否需要交叉 const double Va_Probability = 0.050;//变异概率,变异概率用于判断任一个体是否需要变异 const int De_Variable = 2;//函数自变量的个数,如果要进行多元函数的最值求解，直接修改自变量数个De_Variable即可 vector nowpopulation;//P(t)种群 vector midpopulation;//中间种群，存放轮盘选择后的优秀个体 vector nextpopulation;//P(t+1)种群 (b)类的实现： class Individual //定义个体类 { private: double Variable[De_Variable];//存放变量x1,x2,x3........ double Fitness;//适应值 double ReFitness;//适应值概率 double SumFitness;//累加概率，为轮盘转做准备 public： ............ }; (c)：初始化： 随机生成两个满足条件范围的x1和x2自变量，生成一个个体，初始化种群，得到第一代种群。在这里用一个随机函数生成两个指定范围的小数，然后创建一个对象（个体），加入到初始种群中，直到达到种群规模。 (d)计算适应值，适应值概率，累加概率： 适应值是根据每个个体的自变量进行计算的，这里是求函数的最大值，所以把函数就作为适应值计算函数，适应值概率的计算是每个个体占所有个体适应值总和的百分比，累加概率是为了轮盘法选择做准备。 (e)进行选择，杂交，变异： 最重要的就是这三个算子，选择即就是用轮盘法选出一些相对优秀的个体，在程序中我没有用精英制选择，读者自己可以加以实现。杂交之前需要对自变量进行编码，我在程序中采用的是二进制的编码，用的是c++标准库中的bitset类来进行编码的，杂交的方式我用的是单点杂交，你也可以选择其他杂交方式。变异我用的是基本位变异方式，相对比较简单。 5.2. 代码 GeneticAlgorithm.cpp文件 #include\"GeneticAlgorithm.h\"//包含头文件 //自变量取值范围向量和种群向量定义 const X_Range Range[De_Variable] = { X_Range(-3.0,12.1) ,X_Range(4.1,5.8) };//自变量（或者基因）x1,x2的取值范围 vector nowpopulation;//P(t)种群 vector midpopulation;//中间种群，存放轮盘选择后的优秀个体 vector nextpopulation;//P(t+1)种群 //X_Range类实现 X_Range::X_Range(double m_Lower, double m_Upper) :Lower(m_Lower), Upper(m_Upper){}//X_Range类构造函数实现 double X_Range::GetUpper()const//获取变量上限 { return Upper; } double X_Range::GetLower()const//获取变量下限 { return Lower; } //Individual类实现 Individual::Individual(double* m_Variable)//构造函数 { for (int i = 0; i = Range[i].GetLower() && m_Variable[i] Fitness = 0; this->ReFitness = 0; this->SumFitness = 0; } double* Individual::GetVariable()//获取基因值 { return Variable; } double Individual::GetFitness()const//获取适应值 { return Fitness; } double Individual::GetReFitness()const //获取适应值概率 { return ReFitness; } double Individual::GetSumFitness()const//获取累加概率 { return SumFitness; } void Individual::ChaFitness(const double m_fitness)//修改适应值 { this->Fitness = m_fitness; } void Individual::ChaReFitness(const double m_ReFitness)//修改适应值概率 { this->ReFitness = m_ReFitness; } void Individual::ChaSumFitness(const double m_SumFitness)//修改累加概率 { this->SumFitness = m_SumFitness; } //遗传算法的准备工作 void Initialize()//随机初始化种群，得到第一代种群 { //产生指定范围的随机变量（基因） double X[Po_Size][De_Variable];//为了使程序可以满足多元函数最值的计算，用矩阵保存产生的随机数变量值 for (int j = 0; j u(Range[j].GetLower(), Range[j].GetUpper());//分布 for (int i = 0; i u(0.0, 1.0); //分布 for (int i = 0; i = nowpopulation.at(i - 1).GetSumFitness() && array[j] array1b1((array1[j] + 3.0)* pow(10, 6));//加上3.0形成一个unsigaed数之后在进行母体1的x1编码 bitset array2b1((array2[j] + 3.0)* pow(10, 6));//加上3.0形成一个unsigaed数之后在进行母体2的x1编码 //现在随机生成0到length1-1的数，确定交叉点的位置 localx1 = rand() % length1; //现在进行单点交叉，交换双亲localx1后面的基因 for (int i = 0; i Range[0].GetUpper() || newx2[0]Range[0].GetUpper()) { p1 = false; break; } } if (j == 1)//x2进行编码并且杂交 { bitset array1b2((array1[j]) * pow(10, 6));//母体1的x2编码 bitset array2b2((array2[j]) * pow(10, 6));//母体2的x2编码 //现在随机生成0到length2-1的数，确定交叉点的位置 localx2 = rand() % length2; //现在进行单点交叉，交换双亲localx2后面的基因 for (int i = 0; i Range[1].GetUpper() || newx2[1]Range[1].GetUpper()) { p2 = false; break; } } } if (p1 == true && p2 == true) { Individual newchiled1(newx1); Individual newchiled2(newx2); nextpopulation.push_back(newchiled1); nextpopulation.push_back(newchiled2); } else//将原来的个体遗传给下一代 { nextpopulation.push_back(midpopulation.at(num)); nextpopulation.push_back(midpopulation.at(num + 1)); } } else//否则直接遗传给下一代nextpopulation { nextpopulation.push_back(midpopulation.at(num));//生成一个新的个体并且加入到nextpopulation中 nextpopulation.push_back(midpopulation.at(num + 1)); } num += 2; } midpopulation.clear();//清空midpopulation } void variating()//变异 { int num = 0; while (num array1((x[0]+ 3.0)* pow(10, 6));//x1编码 bitset array2(x[1]*pow(10,6));//x2编码 x1local = rand() % length1;//array1该位取反 x2local = rand() % length2;//array2该位取反 array1.flip(x1local);//改变array1 x1local位的状态 array2.flip(x2local);//改变array2 x2local位的状态 x[0] = double(array1.to_ullong()) / pow(10, 6) - 3.0; x[1] = double(array2.to_ullong()) / pow(10, 6); //判断是否符合条件 if (x[0]Range[0].GetUpper() || x[1]Range[1].GetUpper()) p = false; if (!p) nowpopulation.push_back(nextpopulation.at(num)); if (p) { Individual newchiled(x); nowpopulation.push_back(newchiled); } } else nowpopulation.push_back(nextpopulation.at(num)); num++; } nextpopulation.clear();//清空nextpopulation } void genetic_algorithm() { Initialize();//初始化种群,随机生成第一代个体 //进化500代 for (int i = 0; i main.cpp文件 1 #include\"GeneticAlgorithm.h\" 2 int main() 3 { 4 genetic_algorithm(); 5 system(\"pause\"); 6 return 0; 7 } 更多代码见参考文章. 问题 (未整理) 1、遗传算法的问题。 遗传算法主要是用来求解最优化问题的。 一般来讲可以求解函数的最大、最小值问题，还可以结合其它一些方法解决（非）线性回归、分类问题等等。 但遗传算法有两个缺点，一是时间长，二是初值的选择会影响收敛的效果。 它的本质，实际上还www.nfysw.com是随机搜索算法，还是属于所谓的蒙特卡罗式的方法。 2、模拟退火和遗传算法都可以解决什么问题啊 模拟退火算法和遗传算法，包括禁忌搜索算法，蚁群算法等都可以用来求解优化问题。这些算法的一个特点是虽然对于一些复杂问题，比如说DP难题，可能不好找到最优解(理论上找到最优解是可以的)，但是可以以较高的效率找到满意解。 3、遗传算法解背包问题需要解决的是什么? 给个该问题思路的描述，流程图，或者c代码。问题补充： 0-1背包算法用遗传算法来解决 我有个c代码，给我邮箱地址。你很无聊``` 4、遗传算法解决的问题的类型 数值优化，如多目标函数优化。 组合优化，如NP问题－〉作业调度，旅行问题，背包问题。 给出问题的近似最优解。 进一步可以解决机器学习与人工只能问题。 5、怎样解决遗传算法的局部最优问题 这个看看遗传算法的专着吧。 局部收敛，就是所谓的“早熟现象”是遗传算法的一个很让人头疼的问题。对应的措施，我举个例子，可以是提高变异算子的变异概率。变异算子是跳出局部收敛的重要操作算子，当然，遗传算法有很多的改进类型。这里不多说了，我介绍本书，叫《MATLAB遗传算法工具箱及应用》，雷英杰，西安电子科技大学出版社 6、遗传算法解决TSP问题 遗传算法在很多领域都得到应用；从神经网络研究的角度上考虑，最关心的是遗传算法在神经网络的应用。在遗传算法应用中，应先明确其特点和关键问题，才能对这种算法深入了解，灵活应用，以及进一步研究开发。 一、遗传算法的特点 1．遗传算法从问题解的中集开始嫂索，而不是从单个解开始。 这是遗传算法与传统优化算法的极大区别。传统优化算法是从单个初始值迭代求最优解的；容易误入局部最优解。遗传算法从串集开始搜索，复盖面大，利于全局择优。 2．遗传算法求解时使用特定问题的信息极少，容易形成通用算法程序。 由于遗传算法使用适应值这一信息进行搜索，并不需要问题导数等与问题直接相关的信息。遗传算法只需适应值和串编码等通用信息，故几乎可处理任何问题。 3．遗传算法有极强的容错能力 遗传算法的初始串集本身就带有大量与最优解甚远的信息；通过选择、交叉、变异操作能迅速排除与最优解相差极大的串；这是一个强烈的滤波过程；并且是一个并行滤波机制。故而，遗传算法有很高的容错能力。 4．遗传算法中的选择、交叉和变异都是随机操作，而不是确定的精确规则。 这说明遗传算法是采用随机方法进行最优解搜索，选择体现了向最优解迫近，交叉体现了最优解的产生，变异体现了全局最优解的复盖。 5．遗传算法具有隐含的并行性 遗传算法的基础理论是图式定理。它的有关内容如下： (1)图式(Schema)概念 一个基因串用符号集{0，1，}表示，则称为一个因式；其中可以是0或1。例如：H=1x x 0 x x是一个图式。 (2)图式的阶和长度 图式中0和1的个数称为图式的阶，并用0(H)表示。图式中第1位数字和最后位数字间的距离称为图式的长度，并用(H)表示。对于图式H＝1x x0x x，有0(H)＝2，(H)＝4。 (3)Holland图式定理 低阶，短长度的图式在群体遗传过程中将会按指数规律增加。当群体的大小为n时，每代处理的图式数目为0(n3)。 遗传算法这种处理能力称为隐含并行性(Implicit Parallelism)。它说明遗传算法其内在具有并行处理的特质。 二、遗传算法的应用关键 遗传算法在应用中最关键的问题有如下3个 1．串的编码方式 这本质是问题编码。一般把问题的各种参数用二进制编码，构成子串；然后把子串拼接构成“染色体”串。串长度及编码形式对算法收敛影响极大。 2．适应函数的确定 适应函数(fitness function)也称对象函数(object function)，这是问题求解品质的测量函数；往往也称为问题的“环境”。一般可以把问题的模型函数作为对象函数；但有时需要另行构造。 3．遗传算法自身参数设定 遗传算法自身参数有3个，即群体大小n、交叉概率Pc和变异概率Pm。 群体大小n太小时难以求出最优解，太大则增长收敛时间。一般n＝30-160。交叉概率Pc太小时难以向前搜索，太大则容易破坏高适应值的结构。一般取Pc=0.25-0.75。变异概率Pm太小时难以产生新的基因结构，太大使遗传算法成了单纯的随机搜索。一般取Pm＝0．01—0．2。 三、遗传算法在神经网络中的应用 遗传算法在神经网络中的应用主要反映在3个方面：网络的学习，网络的结构设计，网络的分析。 1．遗传算法在网络学习中的应用 在神经网络中，遗传算法可用于网络的学习。这时，它在两个方面起作用 (1)学习规则的优化 用遗传算法对神经网络学习规则实现自动优化，从而提高学习速率。 (2)网络权系数的优化 用遗传算法的全局优化及隐含并行性的特点提高权系数优化速度。 2．遗传算法在网络设计中的应用 用遗传算法设计一个优秀的神经网络结构，首先是要解决网络结构的编码问题；然后才能以选择、交叉、变异操作得出最优结构。编码方法主要有下列3种： (1)直接编码法 这是把神经网络结构直接用二进制串表示，在遗传算法中，“染色体”实质上和神经网络是一种映射关系。通过对“染色体”的优化就实现了对网络的优化。 (2)参数化编码法 参数化编码采用的编码较为抽象，编码包括网络层数、每层神经元数、各层互连方式等信息。一般对进化后的优化“染色体”进行分析，然后产生网络的结构。 (3)繁衍生长法 这种方法不是在“染色体”中直接编码神经网络的结构，而是把一些简单的生长语法规则编码入“染色体”中；然后，由遗传算法对这些生长语法规则不断进行改变，最后生成适合所解的问题的神经网络。这种方法与自然界生物地生长进化相一致。 3．遗传算法在网络分析中的应用 遗传算法可用于分析神经网络。神经网络由于有分布存储等特点，一般难以从其拓扑结构直接理解其功能。遗传算法可对神经网络进行功能分析，性质分析，状态分析。 遗传算法虽然可以在多种领域都有实际应用，并且也展示了它潜力和宽广前景；但是，遗传算法还有大量的问题需要研究，目前也还有各种不足。首先，在变量多，取值范围大或无给定范围时，收敛速度下降；其次，可找到最优解附近，但无法精确确定最扰解位置；最后，遗传算法的参数选择尚未有定量方法。对遗传算法，还需要进一步研究其数学基础理论；还需要在理论上证明它与其它优化技术的优劣及原因；还需研究硬件化的遗传算法；以及遗传算法的通用编程和形式等。 参考： 遗传算法详解及c++实现 遗传算法解决二维和高维优化问题——基于Python python遗传算法(详解) 遗传算法关于多目标优化python（详解） 遗传算法解决什么问题 5 爬山法 Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-10-02 23:07:11 "},"01_数据结构与算法笔记/01_学习笔记/03_数学知识.html":{"url":"01_数据结构与算法笔记/01_学习笔记/03_数学知识.html","title":"1.3 数学知识","keywords":"","body":"数学知识 包括质数、约数、同余、矩阵乘法、高斯消元与线性空间、组合计数、容斥原理与Mobius函数、概率与数学期望、0/1分数规划、博弈论之SG函数等内容。 暂不整理 基本概念 因子就是所有可以整除这个数的数,不包括这个数自身.（就是一个数的约数，比如20的因子有 1 2 4 5 10） 因数包括这个数本身而因子不包括, 如：比如15的因子是1,3,5 而因数为1,3,5,15 完数是指此数的所有因子之和等于此数,例如：28=1+2+4+7+14. 最大公约数 // 最大公约数:辗转相除法(欧几里得法) // 不要求ab大小关系，只需要为正数 // 求两个正整数 a 和 b 的 最大公约数 d // 则有 gcd(a,b) = gcd(b,a%b) // 证明： // 设a%b = a - k*b 其中k = a/b(向下取整) // 若d是(a,b)的公约数 则知 d|a 且 d|b 则易知 d|a-k*b 故d也是(b,a%b) 的公约数 // 若d是(b,a%b)的公约数 则知 d|b 且 d|a-k*b 则 d|a-k*b+k*b = d|a 故而d|b 故而 d也是(a,b)的公约数 // 因此(a,b)的公约数集合和(b,a%b)的公约数集合相同 所以他们的最大公约数也相同 证毕# int gcd(int a, int b) // 欧几里得算法 { return b ? gcd(b, a % b) : a; } // 附：辗转相减法 过于复杂... int gcd_2(int a, int b){ return a == b ? a : gcd_2(a > b ? a - b : a, b > a ? b - a :b); } // 最小公倍数 lcm(a, b) = a * b / gcd(a, b) 辗转相除法： 以及辗转相减法： 质数 试除法判定质数 O(log n) 试除法判定质数 bool is_prime(int x) // { if (x 试除法分解质因数 最大 O(log n) —— 模板题 AcWing 867. 分解质因数 void divide(int x) { for (int i = 2; i 1) cout 朴素筛法 O(nln n) int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i 埃氏筛法 O(n log log n) 和朴素区别？？？ void get_primes1(){ for(int i=2;i 线性筛法 —— 模板题 AcWing 868. 筛质数 线性只会被其最小质因子筛掉 Eratosthenes 筛法利用的原理是 任意整数 x 的倍数 2x，3x，… 等都不是质数 。 但是即便如此也会有重复标记的现象，例如12既会被2又会被3标记，在标记2的倍数时，12=6∗2 ，在标记3的倍数时，12=4∗3 ，根本原因是没有找到唯一产生12的方式。 线性筛法 假设 i 是合数 t 的最大因数，t显然可能不唯一（例如 30 和 45 最大因数都是 15）。但是仔细想一想，必然有 t = i * p(p为小于 i 的质数) 。 p为什么比 i 小？因为 i 是 t 的最大因数。 为什么 p 一定是质数？因为如果 p 是合数，那么 i 就一定不是 t 的最大因数，因为 p可以再拆成若干素数相乘，这些素数再与 i 相乘会使因数更大。 既然如此，我们只需要把所有小于 i 的质数 p 都挨个乘一次好了。可是，真相真的是这样的嘛？ 其实不是的，一不小心就忘记了最初的条件。我们要满足 i 是 t 的最大因数。如果 p 大于 i 的最小质因数，那 i 还是 t 的最大因数嘛？显然不是，任何一个合数都能唯一分解为有限个质数的乘积，除去这其中最小的质因数，其他的都乘起来就是最大因数 i 。所以我们不能让 p 大于 i 的最小质因数。 int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 // st[i] i 为质数则false, 否则 true void get_primes(int n) { for (int i = 2; i 约数 完全平方数的约数个数为奇数个，非完全平方数的约束个数为偶数个。 M-灯泡开关 试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数 vector get_divisors(int x) { vector res; for (int i = 1; i 约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和 如果 `N = p1^c1 * p2^c2 * ... *pk^ck` **约数个数**： `(c1 + 1) * (c2 + 1) * ... * (ck + 1)` **约数之和**： `(p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)` int范围内最大的约数个数 为：1536 欧拉函数 求欧拉函数 —— 模板题 AcWing 873. 欧拉函数 int phi(int x) { int res = x; for (int i = 2; i 1) res = res / x * (x - 1); return res; } 筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数 int primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i 快速幂 求 m^k mod p，时间复杂度 O(logk)。 int qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k&1) res = res * t % p; t = t * t % p; k >>= 1; } return res; } 欧几里得算法 求欧拉函数 —— 模板题 AcWing 873. 欧拉函数 int phi(int x) { int res = x; for (int i = 2; i 1) res = res / x * (x - 1); return res; } 筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数 int primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i 扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法 // 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int &x, int &y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 高斯消元 高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组 // a[N][N]是增广矩阵 int gauss() { int c, r; for (c = 0, r = 0; c fabs(a[t][c])) t = i; if (fabs(a[t][c]) = c; i -- ) a[r][i] /= a[r][c]; // 将当前行的首位变成1 for (int i = r + 1; i eps) for (int j = n; j >= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i >= 0; i -- ) for (int j = i + 1; j 求组合数 递归法求组合数 —— 模板题 AcWing 885. 求组合数 I // c[a][b] 表示从a个苹果中选b个的方案数 const int N = 1010; LL c[N][N]; const int mod = 1e9 + 7; for (int i = 0; i 通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i Lucas定理 —— 模板题 AcWing 887. 求组合数 III 若p是质数，则对于任意整数 1 >= 1; } return res; } int C(int a, int b, int p) // 通过定理求组合数C(a, b) { if (a 分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV 当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用： 1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i mul(vector a, int b) // 高精度乘低精度模板 { vector c; int t = 0; for (int i = 0; i res; res.push_back(1); for (int i = 0; i 卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列 给定n个0和n个1，它们按照某种顺序排成长度为2n的序列， 容斥原理 博弈论 NIM游戏 —— 模板题 AcWing 891. Nim游戏 给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。 我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。 所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。 NIM博弈不存在平局，只有先手必胜和先手必败两种情况。 定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0 公平组合游戏ICG 若一个游戏满足： 由两名玩家交替行动； 在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关； 不能行动的玩家判负； 则称该游戏为一个公平组合游戏。 NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。 有向图游戏 给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。 Mex运算 设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即： mex(S) = min{x}, x属于自然数，且x不属于S SG函数 在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即： SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。 有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏 设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm) 定理 有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。 其他知识点 乘积结尾0的数量 阶乘后的零 给定一个整数 n ，返回 n! 结果中尾随零的数量。 提示 n! = n (n - 1) (n - 2) ... 3 2 1 示例 1： 输入：n = 3 输出：0 解释：3! = 6 ，不含尾随 0 示例 2： 输入：n = 5 输出：1 解释：5! = 120 ，有一个尾随 0 示例 3： 输入：n = 0 输出：0 提示： 0 解： 解析：阶乘后的零 暴力：O(n) class Solution { public: int trailingZeroes(int n) { int ans = 0; for (int i = 5; i 优化：O(log(n)) 规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。 最终 5 的个数就是 n / 5 + n / 25 + n / 125 ... 写程序的话，如果直接按照上边的式子计算，分母可能会造成溢出。所以算 n / 25 的时候，我们先把 n 更新，n = n / 5，然后再计算 n / 5 即可。后边的同理。 //巧妙的数学问题： //阶乘尾部的0都来自于2*5所得，又因为2因子数量肯定远小于5因子数量，所以转化为了1-n中统计因子5的总个数 //比如：n=130 数字5统计因子5一次，25统计因子5两次， 125统计因子5三次， 130统计因子5一次 //结论：n/5=n1 得到一次因子5的数的个数 n1/5=n2 得到两次因子5的个数（因为在第一次n1中已经统计过一次了，所以这里再统计一次即可，直接+上） 示例： 实际上就是计算1-n之中有多少个5的因数。以130为例： 第一次除以5时得到26，表明存在26个包含 [一] 个因数5的数； 第二次除以5得到5，表明存在5个包含 [二] 个因数5的数(这些数字的一个因数5已经在第一次运算的时候统计了)； 第三次除以5得到1，表明存在1个包含 [三] 个因数5的数(这些数字的两个因数5已经在前两次运算的时候统计了)； 得到从1-n中所有5的因数的个数 class Solution { public: int trailingZeroes(int n) { int ans = 0; while (n) { n /= 5; ans += n; } return ans; } }; 递归： class Solution { public: int trailingZeroes(int n) { return n ? n / 5 + trailingZeroes(n / 5) : 0; } }; 拓展： 阶乘函数后 K 个零 f(x) 是 x! 末尾是 0 的数量。回想一下 x! = 1 2 3 ... x，且 0! = 1 。 例如， f(3) = 0 ，因为 3! = 6 的末尾没有 0 ；而 f(11) = 2 ，因为 11!= 39916800 末端有 2 个 0 。 给定 k，找出返回能满足 f(x) = k 的非负整数 x 的数量。 示例 1： 输入：k = 0 输出：5 解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。 示例 2： 输入：k = 5 输出：0 解释：没有匹配到这样的 x!，符合 k = 5 的条件。 示例 3: 输入: k = 3 输出: 5 提示: 0 解： class Solution { public: int preimageSizeFZF(int k) { long l = k - 1,r = k * 10L + 1; while(l + 1 > 1,t = f(m); if(t == k) return 5; else if(t 完全平方数 判断： LC-有效的完全平方数 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。 进阶：不要 使用任何内置的库函数，如? sqrt 。 提示： 1 // // 1. 内置函数 sqrt(int num) // 2. 暴力 // 3. 二分 bool isPerfectSquare(int num) { int left = 0, right = num; while (left num) { right = mid - 1; } else { return true; } } return false; } // 4. 平方和性质 bool isPerfectSquare(int num) { int num1 = 1; while(num > 0) { num -= num1; num1 += 2; } return num == 0; } // 5. 牛顿 bool isPerfectSquare(int num) { double x0 = num; while (true) { double x1 = (x0 + num / x0) / 2; if (x0 - x1 参考：n^2=1+3+5+...+(2n-1) 动态中位数 数学解题 完全平方数 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 示例 2： 输入：n = 13 输出：2 解释：13 = 4 + 9 提示： 1 解： 常规：动态规划 class Solution { public: int numSquares(int n) { vector f(n + 1); for (int i = 1; i 数学 四平方和定理 这道题如果知道数学定理之后，相当于告诉你： 任何正整数都可以拆分成不超过4个数的平方和 ---> 答案只可能是1,2,3,4 如果一个数最少可以拆成4个数的平方和，则这个数还满足 n = (4^a)*(8b+7) ---> 因此可以先看这个数是否满足上述公式，如果不满足，答案就是1,2,3了 如果这个数本来就是某个数的平方，那么答案就是1，否则答案就只剩2,3了 如果答案是2，即n=a^2+b^2，那么我们可以枚举a，来验证，如果验证通过则答案是2 只能是3 class Solution { public: // 判断是否为完全平方数 bool isPerfectSquare(int x) { int y = sqrt(x); return y * y == x; } // 判断是否能表示为 4^k*(8m+7) bool checkAnswer4(int x) { while (x % 4 == 0) { x /= 4; } return x % 8 == 7; } int numSquares(int n) { if (isPerfectSquare(n)) { return 1; } if (checkAnswer4(n)) { return 4; } for (int i = 1; i * i 打表 数据过多，不予显示。 笔记 n！ 有多少个2 floor(n/2) + floor(n/(2^2)) + floor(n/2^3)+ …… 用于求高精度里面的 组合 数快速计算 可省去出发运算 以及 溢出 -^: 5.1 筛质数 5.2 分解质因数 5.3 快速幂 5.4 约数个数 5.5 欧拉函数 5.6 同余 5.7 矩阵乘法 5.8 组合计数 5.9 高斯消元 5.10 容斥原理 5.11 概率与数学期望 5.12 博弈论 --- 5.1 莫比乌斯反演 5.2 积性函数 5.3 BSGS 5.4 FFT 5.5 生成函数 5.6 Burnside引理和Polya定理 5.7 斯特林数 5.8 线性基 Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-08-28 13:01:39 "},"01_数据结构与算法笔记/01_学习笔记/04_数据结构进阶.html":{"url":"01_数据结构与算法笔记/01_学习笔记/04_数据结构进阶.html","title":"1.4 数据结构进阶","keywords":"","body":"包括并查集、树状数组、线段树、可持久化数据结构、平衡树、AC自动机等内容 1 并查集 用于 在O(1)的时间复杂度内 将两个集合合并，以及询问两个元素是否在一个集合当中 基本介绍 用树维护每一个集合 - 基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，`p[x]`表示`x`的父节点 - Q1:如何判断树根： `if(p[x]==x)` - Q2:如何求x的集合编号 `while(p[x]!=x) x= p[x];` - Q3:如何合并两个集合(加条边即可) `px`是`x`的集合编号，`py`是`y`的集合编号。可通过`p[px]=py`，使`px`集合加到`py`集合中。 - 按树深度(按秩)合并：把矮的树 合并到 高的树上，见类版本 - 按树节点数合并： - **路径压缩**：在find时同时对x节点到根节点经过的所有节点 进行路径压缩，即把经过的所有节点的父节点都设置为根节点。 `int find(int x) { if(p[x]!=x) p[x]=find(p[x]); return p[x];}` - Q4:维护其他信息 - 每个集合元素个数size - 每个节点到根节点深度 基本(路径压缩) int p[N]; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } for (int i = 1; i 维护大小 int p[N], size[N]; int find(int x){ if (p[x] != x) p[x] = find(p[x]); return p[x]; } for (int i = 1; i 维护距离 int p[N], d[N]; int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } for (int i = 1; i 基本并查集 M-省数 --dfs，bfs，djset D-处理含限制条件的好友请求 按公因数计算最大组件大小 哈希并查集 D-字符串分组 2 树状数组 树状数组和线段树具有相似的功能，但他俩毕竟还有一些区别：树状数组能有的操作，线段树一定有；线段树有的操作，树状数组不一定有。但是树状数组的代码要比线段树短，思维更清晰，速度也更快，在解决一些单点修改的问题时，树状数组是不二之选。 介绍 查询和修改复杂度都为log(n)，主要用于数组的单点修改&&区间求和. 从索引1开始使用，在循环中 query操作为for(;x;...) 即需要满足 x>0 继续循环。 性质： 每个结点t[x]保存以x为根的子树中叶结点值的和 每个结点覆盖的长度为lowbit(x)，即 t[i]管理了 i的二进制最低位的2^{0的个数}. 则有i为奇数时，只管理自己一个原始元素。 i为偶数时，至少管理两个，根据其最低位的0的个数。 t[x]结点的父结点为t[x + lowbit(x)]，是修改时的路径 t[x]节点的前节点(包含区间不重复)为t[x - lowbit(x)],是询问时的路径 树的深度为log2n+1 树状数组 O(n)原地建树 O(nlgn)预处理 O(nlgn)查询 空间O(n) 建树 首先当前位置x之前的x-1个位置已经全部建立完成 考虑如何建立x位置的树状数组 根据树状数组的定义，下标x位置存储的是x值的二进制表达式中最低位的1所包含的前缀和 那么我们只需把该段前缀和全部加到x位置的值即可。 // 初始 ： tr[i] = a[i] tr[1] = tr[1] = a[1] tr[2] = tr[1] + tr[2] = a[1] + a[2] tr[3] = tr[3] = a[3] tr[4] = tr[2] + tr[3] + tr[4] = a[1] + a[2] + a[3] + a[4] tr[5] = tr[5] = a[5] tr[6] = tr[5] + tr[6] = a[5] + a[6] tr[7] = tr[7] = a[7] tr[8] = tr[8] = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] 以下为原地建树代码 // 原地 O(n) 建树状数组 // 若 tr[i] = a[i] 为初始数组 for (int x = 1; x = x - lowbit(x) + 1; i -= lowbit(i)) // i = x - 1 tr[x] += tr[i]; 初级：(用于求区间和、区间异或) 单点修改，单点查询 int t[N]; // 1-n // 区间和 void add(int x,int k){ for(;x 应用 高级：(用于求逆序对、区间最大值（还可以用单调队列(见基础部分单调队列)）) 区间修改，单点查询 引入差分数组，用树状数组维护b的前缀和，即a[]每个元素的增量 [l,r]+d \\ \\ \\ \\ add(l,d) \\ \\ \\ \\ add(r+1,-d) 查询a[x] \\ \\ \\ \\ ans = a[x]+ask(x) void add(int x,int k){ for(;x 区间修改，区间查询 int t1[maxn],t2[maxn]; void add1(int x,int k){ for(;x 二维树状数组 二维树状数组总结及模板 #786 (Div. 3). Desktop Rearrangement 一维树状数组 对每个位置进行编号即可 二维树状数组 待更新 可以动态维护序列前缀和的数据结构 超快速排序 离散+树状数组法 逆序对问题 // 准备部分 #define fir(i,a,b) for (int i=a;i0;i-=lowbit(i)){ans+=t[i];} return ans;} // 运用部分 memset(t,0,sizeof(t)); // 清空t fir(i,0,n-1){ //读入原始数据 cin>>nodes[i].v; nodes[i].order=i; } sort(nodes,nodes+n); //排序 fir(i,0,n-1){ // 离散化为0~ n-1 va[nodes[i].order]=i; } LL ans = 0; fir(i,0,n-1){ add(va[i]+1,n); // 按原顺序，依次加入数组。注意加1 ans+= i+1-query(va[i]+1); // //树状数组求逆序对个数的方法 (i+1)为已经加入t中的个数，其中query的为小于等于当前值的个数。则剩余的为大于当前值，即构成逆序对的个数。 } M-奇数码问题 注意当要同时使用多个树状数组时，最好封装成BIT结构进行使用。 二维偏序问题 见刷题笔记部分。 参考： Video:完全理解并深入应用树状数组 | 支持多种动态维护区间操作 Article:树状数组 Article:数据结构之树状数组 算法学习笔记(20): 二维偏序 区间最大 树状数组求区间最大值： （不能再把已填充的数修改为更小的数，可更改为一个更大的数！？ 若涉及自由更改，可用线段树, 不要再用树状数组了 血的教训...） 树状数组求区间最大值(转载) 直接照搬求区间合的方法显然是不行的。 因为区间合中，要查询[x,y]的区间合，是求出[1,x-1]的合与[1,y]的合，然后相减就得出了[x,y]区间的合。 而区间最值是没有这个性质的，所以只能够换一个思路。 设query(x,y)，表示[x，y]区间的最大值 因为h[y]表示的是[y,y-lowbit(y)+1]的最大值。 所以，可以这样求解： 若y-lowbit(y) > x ，则query(x,y) = max( h[y] , query(x, y-lowbit(y)) ); 若y-lowbit(y) 这个递归求解是可以求出解的，且可以证明这样求解的时间复杂度是O（(logn)^2） int query(int x, int y) { int ans = 0; while (y >= x) { ans = max(a[y], ans); y --; for (; y-lowbit(y) >= x; y -= lowbit(y)) ans = max(h[y], ans); } return ans; } 时间复杂度的证明：（换成二进制来看） 因为y经过Logn次变换以后，其与x不同的最高位至少下降了1位，所以最多进行(logn)^2次变换 举例： y = 1010000 x = 1000001 1010000 => 1001111 => 1001110 =>1001100 =>1001000 =>1000111 => 1000110 => 1000100 => 1000011 = > 1000010 =>1000001 =>1000000 //#include \"stdafx.h\" #include using namespace std; const int N=1e6; int a[N],h[N];//h[x]:h[x]储存的是[x，x-lowbit(x)+1]中每个数的最大值 int n,m; int lowbit(int x) { return x&(-x); } void update(int x) { int lx=x; while(x=x) { ans=max(a[y],ans); // 注意是 a[y] 不是h[y] y--; for(;y-lowbit(y)>=x;y-=lowbit(y)) { ans=max(h[y],ans); } } return ans; } int main() { int x,y; cin>>n>>m; for(int i=1;i>a[i]; update(i); } while(m--) { cin>>x>>y; cout 例：最长递增子序列 II 给你一个整数数组 nums 和一个整数 k 。 找到 nums 中满足以下要求的最长子序列： 1.子序列 严格递增 2.子序列中相邻元素的差值 不超过 k 。 请你返回满足上述要求的 最长子序列 的长度。 子序列 是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。 示例 1： 输入：nums = [4,2,1,4,3,4,5,8,15], k = 3 输出：5 解释： 满足要求的最长子序列是 [1,3,4,5,8] 。 子序列长度为 5 ，所以我们返回 5 。 注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。 示例 2： 输入：nums = [7,4,5,1,8,12,4,7], k = 5 输出：4 解释： 满足要求的最长子序列是 [4,5,8,12] 。 子序列长度为 4 ，所以我们返回 4 。 示例 3： 输入：nums = [1,5], k = 1 输出：1 解释： 满足要求的最长子序列是 [1] 。 子序列长度为 1 ，所以我们返回 1 。 提示： 1 动态规则 + 树状数组优化区间最大 const int N = 1e5 + 10; int a[N], h[N]; int lowbit(int x){ return x & (-x);} void update(int x){ int lx = x; while(x = x){ ans = max(a[y], ans), y --; // a[y], 非 h[y] for(; y - lowbit(y) >= x; y -= lowbit(y)) ans = max(h[y], ans); // >, >= 都能过 } return ans; } class Solution { public: int lengthOfLIS(vector& nums, int k) { memset(h, 0, sizeof h), memset(a, 0, sizeof a); for(auto& v : nums) a[v] = max(a[v], query(max(1, v - k), v - 1) + 1), update(v); return query(1, N - 1); } }; 极简线段树代码 见原题。 同理：预算内的最多机器人数目 你有 n 个机器人，给你两个下标从 0 开始的整数数组 chargeTimes 和 runningCosts ，两者长度都为 n 。第 i 个机器人充电时间为 chargeTimes[i] 单位时间，花费 runningCosts[i] 单位时间运行。再给你一个整数 budget 。 运行 k 个机器人 总开销 是 max(chargeTimes) + k sum(runningCosts) ，其中 max(chargeTimes) 是这 k 个机器人中最大充电时间，sum(runningCosts) 是这 k 个机器人的运行时间之和。 请你返回在 不超过 budget 的前提下，你 最多 可以 连续 运行的机器人数目为多少。 示例 1： 输入：chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25 输出：3 解释： 可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。 选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 sum(2,1,3) = 6 + 3 6 = 24 ，小于 25 。 可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。 示例 2： 输入：chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19 输出：0 解释：即使运行任何一个单个机器人，还是会超出 budget，所以我们返回 0 。 提示： chargeTimes.length == runningCosts.length == n 1 10^4 1 解： 双指针+单调队列参考题解。 二分 + 预处理前缀和 + 区间最大 class Solution { static const int N = 100010; typedef long long LL; LL pre[N]; int a[N], h[N]; int lowbit(int x){ return x & (-x);} void update(int x){ int lx = x; while(x = x){ ans = max(a[y], ans), y --; for(; y - lowbit(y) >= x; y -= lowbit(y)) ans = max(h[y], ans); } return ans; } bool check(int mid, LL bud, int n){ for(int i = 1; i + mid - 1 & ch, vector& run, long long bud) { int n = ch.size(); for(int i = 0; i > 1; if(check(mid, bud, n)){ l = mid; }else{ r = mid - 1; } } return l; } }; 3 S-T表 O(nlgn)预处理 O(1)查询 空间 O(nlgn) 解决区间最值RMQ(Range Max/Min Query)问题 d[i][j]维护一段起点为i,长度为2^j区间的最值：[i,i+2^j-1], d[5,3] = min(d[5,2],d[9,2]); 4 线段树 线段树是算法竞赛中常用的用来维护 区间信息 的数据结构 又叫 线段错误树(Segment (error) tree) 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。(摘自百度百科) 应用 线段树是一种完全二叉树,支持操作: 单点修改, 区间查询 区间修改, 单点查询 区间修改, 区间查询 对于求前缀和的问题： 针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）： 数组不变，求区间和：「前缀和」、「树状数组」、「线段树」 多次修改某个数，求区间和：「树状数组」、「线段树」 多次整体修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间的数据范围） 多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间的数据范围） 这样看来，「线段树」能解决的问题是最多的，那我们是不是无论什么情况都写「线段树」呢？ 答案并不是，而且恰好相反，只有在我们遇到第 4 类问题，不得不写「线段树」的时候，我们才考虑线段树。 因为「线段树」代码很长，而且常数很大，实际表现不算很好。我们只有在不得不用的时候才考虑「线段树」。 总结一下，我们应该按这样的优先级进行考虑： 简单求区间和，用「前缀和」 多次将某个区间变成同一个数，用「线段树」 其他情况，用「树状数组」 基本操作 push up(int u)//传入节点编号，用子节点信息来算父节点信息 build() //将一段区间初始化为一颗线段树 modify() //修改操作,修改某一个点或者某一个区间（懒标记） - 单点 - 区间 pushdown query() //查询某一段区间的信息 pushdown(u) //用u 的信息更新 u子结点的信息 - 懒标记：给以当前节点为根的子树中的每一个节点(不包含根节点),添加标记lazy 除了最后一层，是 满二叉树 满二叉树：可用一维数组存储 整棵树 编号 是x ： 父节点 下取整 x / 2，即x >> 1 左节点 2 x x x + 1 x 开空间 ： 开 4 * n 的空间 最多 需要 (n - 1) + n + 2 n = 4 n -1 空间 假设有编号从1到n的n个点，每个点都存了一些信息，用[L,R]表示下标从L到R的这些点。 线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是O(log2(n)). 线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为 少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。 由此看出，用线段树统计的东西，必须符合区间加法，否则，不可能通过分成的子区间来得到[L,R]的统计结果。 符合区间加法的例子： 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和 最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD ); 最大值——总最大值=max(左区间最大值，右区间最大值) 不符合区间加法的例子： 众数——只知道左右区间的众数，没法求总区间的众数 01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零 一个问题，只要能化成对一些连续点的修改和统计问题，基本就可以用线段树来解决了 //一般使用结构体来存储线段树,空间大小开四倍 struct Node{ int l,r; //维护的区间 int v; //维护的信息... } tree[N*4]; 基本操作代码： struct Node { int l, r; // TODO: 需要维护的信息和懒标记 }tr[N * 4]; void pushup(Node& u, Node& l, Node& r){ // TODO: 利用左右儿子信息维护当前节点的信息 } void pushup(int u){ pushup(tr[u], tr[u > 1; build(u = l && tr[u].r > 1; if (l mid) update(u = l && tr[u].r > 1; if(r mid) return query(u 一个demo: 区间修改：加 以及 置1置0 struct Node { int l, r; // TODO: 需要维护的信息和懒标记 int val, lazy = - 1; // 区间加 版本 // LL sum, add; }tr[N * 4]; void pushup(Node& u, Node& l, Node& r){ // TODO: 利用左右儿子信息维护当前节点的信息 u.val = l.val + r.val; } void pushup(int u){ pushup(tr[u], tr[u > 1; build(u = l && tr[u].r > 1; if (l mid) update(u = l && tr[u].r > 1; if(r mid) return query(u 类： struct SegTree{ SegTree(int n){ build(1, 1, n);} struct Node { int l, r; // TODO: 需要维护的信息和懒标记 }tr[N * 4]; void pushup(Node& u, Node& l, Node& r){ // TODO: 利用左右儿子信息维护当前节点的信息 } void pushup(int u){ pushup(tr[u], tr[u > 1; build(u = l && tr[u].r > 1; if (l mid) update(u = l && tr[u].r > 1; if(r mid) return query(u 例题 单点修改、区间查询 最大值最大数 //线段树的建树： //build void build(int u,int l,int r){ //构建节点u，其维护的是区间[l,r] tr[u]={l,r}; if(l==r) return ; //已经是叶子节点 int mid=l+r>>1; build(u=l&&tree[u].r> 1; if(l>1; if(x 前缀和 void build(int u, int l, int r){ if(l == r) tr[u] = {l, r, a[l]}; else{ tr[u] = {l, r}; int mid = l + r >> 1; build(u > 1; if (x = l && tr[u].r > 1; if(r mid) return query(u 最大连续子段和你能回答这些问题吗 struct Node { int l, r; int sum, lmax, rmax, tmax; }tr[N * 4]; void pushup(Node &u, Node &l, Node &r) { u.sum = l.sum + r.sum; u.lmax = max(l.lmax, l.sum + r.lmax); u.rmax = max(r.rmax, r.sum + l.rmax); u.tmax = max(max(l.tmax, r.tmax), l.rmax + r.lmax); } void pushup(int u) { pushup(tr[u], tr[u > 1; build(u > 1; if (x = l && tr[u].r > 1; if (r mid) return query(u 区间修改、区间查询 区间修改需要进行懒标记 区间最大公约数 给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一： 1.C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。 2.Q l r，表示询问 A[l],A[l+1],…,A[r] 的最大公约数(GCD)。 对于每个询问，输出一个整数表示答案。 通过差分数组 将区间修改转化为单点修改 a[]为原数组, b[]为差分数组: b[i]=a[i]−a[i−1] a[i]=b[1]+b[2]+…+b[i] a[]的区间[L,R]加 d 等价于: b[]中 b[l]+d,b[r+1]−d 利用最大公约数的性质: - gcd(a1,a2,a3…an)=gcd(a1,a2−a1,a3−a2…an−an−1) 综上, 线段树维护信息: 差分数组的前缀和, 区间的最大公约数. (所有信息都是关于差分数组的) 对于查询区间[L,R]: ans=gcd(aL,aL+1−aL…aR−aR−1)=gcd(差分数组前缀和,gcd(bL+1,bL+2…bR) 一个简单的整数问题2 给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一： 1.C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。 2.Q l r，表示询问数列中第 l∼r 个数的和。 对于每个询问，输出一个整数表示答案。 解： 提供三种解法 用树状数组或线段树均可 树状数组 线段树 题目涉及区间修改, 需要pushdown()操作 pushdown: 用当前结点的信息更新子结点的信息 puhdown操作对应懒标记, 每次对区间[L,R]修改操作时, 当递归到的子树区间[l,r] 属于[L,R]时, 不再向下递归修改, 而是直接将修改信息标记在该区间, 下一次需要从当前区间分裂时, 将懒标记向下传递 分块 难点 1.树状数组方法：注意对两个树的原地建树 和 更新方式。 2.线段树中懒标记的实现。 具体代码： 树状数组 由于是区间加，可以用差分数组维护。 其他区间操作可能需要用到线段树了。 用树状数组完成 O(logn) 时间复杂度的区间查询(O(logn)) + 区间修改O(logn) 分析见上： 因此只需维护两个树状数组即可 一个是差分数组d[i]的树状数组tr[i]，还有一个是i*d[i]的树状数组tri[i] #include #include #include #include #include #include using namespace std; const int N = 100010; typedef long long LL; int n, m; int w[N]; LL tr[N], tri[N]; int lowbit(int x){return x & -x;} void add(LL t[], int x, int k) { for( ; x > n >> m; for(int i = 1; i = x - lowbit(x) + 1; i -= lowbit(i)){ tr[x] += tr[i], tri[x] += tri[i]; } } char op[2]; int l, r, d; while(m --){ scanf(\"%s%d%d\", op, &l, &r); if(*op == 'C'){ scanf(\"%d\", &d); add(tr, l, d), add(tr, r + 1, - d); add(tri, l, l * d), add(tri, r + 1,(r + 1) * (- d)); }else{ printf(\"%lld\\n\", get(r) - get(l - 1)); } } return 0; } 线段树 O(mlogn) #include #include #include #include #include #include using namespace std; const int N = 100010; typedef long long LL; int n, m; int w[N]; struct Node { int l, r; LL sum, lazy; }tr[N * 4]; void pushup(Node& u, Node& l, Node& r){ u.sum = l.sum + r.sum; } void pushup(int u){ pushup(tr[u], tr[u > 1; build(u = l && tr[u].r > 1; if (l mid) update(u = l && tr[u].r > 1; if(r mid) return query(u > n >> m; for(int i = 1; i 分块 O(m√n) 分块算法是一种优雅的暴力。 详情见本章下文。 分块 + 懒标记 #include #include #include #include using namespace std; typedef long long LL; const int N = 1e5 + 10, M = 350; int n, m, len; LL sum[M], lazy[M]; //sum：块的总和；lazy：块的懒标记 int w[N]; int get(int i) { return i / len; } void modify(int l, int r, int d) { if (get(l) == get(r)) //段内直接暴力 { for (int i = l; i 二叉搜索树染色 一个节点数组，无相同节点。初始时，所有节点均为蓝色。现在按顺序其进行若干次操作， ops[i] = [type, x, y] 表示第 i 次操作为： type 等于 0 时，将节点值范围在 [x, y] 的节点均染蓝 type 等于 1 时，将节点值范围在 [x, y] 的节点均染红 请返回完成所有染色后，该节点数组中红色节点的数量。 注意： 题目保证对于每个操作的 x、y 值定出现在二叉搜索树节点中 数据： 1 倒序...逆向思考方式 每个点的颜色只取决于最后一次包含该点的操作。用 set 维护所有颜色待确定的点，倒序处理询问，每次利用 lower_bound 方法从 set 中取出所有在询问范围内的点染色后删掉。因为每个点只会被删掉一次，所以总体复杂度 O((n+q)logn)，其中 n 是节点数量，q 是询问数量。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { set st; void dfs(TreeNode *node) { if (node == nullptr) return; st.insert(node->val); dfs(node->left); dfs(node->right); } public: int getNumber(TreeNode* root, vector>& ops) { dfs(root); int ans = 0; for (int i = (int) ops.size() - 1; i >= 0; i--) { while (true) { auto it = st.lower_bound(ops[i][1]); if (it == st.end() || (*it) > ops[i][2]) break; st.erase(it); if (ops[i][0]) ans++; } } return ans; } }; 离散化 + 线段树(需要懒标记) const int N = 100010; class Solution { struct Node { int l, r; // 需要维护的信息和懒标记 int val, lazy = - 1; }tr[N * 4]; void pushup(Node& u, Node& l, Node& r){ // 利用左右儿子信息维护当前节点的信息 u.val = l.val + r.val; } void pushup(int u){ pushup(tr[u], tr[u > 1; build(u = l && tr[u].r > 1; if (l mid) update(u = l && tr[u].r > 1; if(r mid) return query(u nums; void dfs(TreeNode* root){ if(root == nullptr) return; nums.push_back(root->val); dfs(root->left); dfs(root->right); } int find(int x){ return lower_bound(nums.begin(), nums.end(), x) - nums.begin() + 1; } public: int getNumber(TreeNode* root, vector>& ops) { dfs(root); sort(nums.begin(), nums.end()); build(1, 1, nums.size()); for(auto o:ops){ int l = find(o[1]), r = find(o[2]); update(1, l, r, o[0]); } return query(1, 1, nums.size()).val; } }; 珂朵莉树 区间染色 + 单点查询 珂朵莉 珂朵莉树（Chtholly Tree）起源于CF896C，一种数据结构，可以较快地实现： 区间加 区间赋值 求区间第k大值 求区间n次方和 class Solution { public: int getNumber(TreeNode* root, vector>& ops) { const int N = 1e9 + 1; map seg; seg[0] = 1, seg[N] = 0; auto Cut = [&](int i) -> void { if (i N) return; if (!seg.count(i)) { auto it = prev(seg.lower_bound(i)); auto [x, y] = *it; seg[i] = y; } }; for (auto &op: ops) { int t = op[0] + 1, x = op[1], y = op[2]; Cut(x), Cut(y + 1); auto it = next(seg.lower_bound(x)); while (it->first 0) { auto it = seg.lower_bound(x); if (it->second == prev(it)->second) { seg.erase(it); } } } int ans = 0; auto dfs = [&](auto &&dfs, TreeNode* root) -> void { int v = root -> val; auto it = prev(seg.upper_bound(v)); if (it -> second == 2) { ans ++; } if (root -> left) dfs(dfs, root->left); if (root -> right) dfs(dfs, root->right); }; dfs(dfs, root); return ans; } }; 题集 难 维护序列 亚特兰蒂斯 @@LC:奇妙序列 需要同时维护+和x的懒标记 请你实现三个 API append，addAll 和 multAll 来实现奇妙序列。 请实现 Fancy 类 ： Fancy() 初始化一个空序列对象。 void append(val) 将整数 val 添加在序列末尾。 void addAll(inc) 将所有序列中的现有数值都增加 inc 。 void multAll(m) 将序列中的所有现有数值都乘以整数 m 。 int getIndex(idx) 得到下标为 idx 处的数值（下标从 0 开始），并将结果对 109 + 7 取余。如果下标大于等于序列的长度，请返回 -1 。 提示： 1 @@包含每个查询的最小区间 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。 再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。 Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。 Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。 Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。 示例 2： 输入：intervals = [ [2,3],[2,5],[1,8],[20,25] ], queries = [2,19,5,22] 输出：[2,-1,4,6] 解释：查询处理如下： Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。 Query = 19：不存在包含 19 的区间，答案为 -1 。 Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。 Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。 提示： 1 解法： 1.优先队列 2.并查集 3.离线 4.线段树 动态开点线段树 引入 在普通的线段树中，我们一般要开 4 N 的数组以避免越界。然而，在一些题目中，空间限制并不允许我们这样做。而且 并不知道原始的值，不方便进行离散化处理。 这个时候，就需要使用动态开点线段树。 你知道正常的线段树一般都是用二倍标记法去标记儿子的序号。 然后在线段树那一篇里面我证过，这样子至少需要四倍空间才不会出现RE。 但在某些特殊的情况下（比如权值线段树），你需要维护的范围可能非常大，如果真的要全部建树建出来，可能空间就爆了。 然后这个时候利用一个类似线段树懒标记的思想，如果一个节点需要使用，那么我们才建立这个节点，反之就不用。 从实现上来讲，就是初始的时候只建立一个根节点代表整个区间。 然后当查询或者修改某个区间的时候我们才向下递归建树。 而且不同于原来的二倍标记法，现在是以直接记录每一个节点的左右儿子的编号来建立线段树。 作用 ​ 一般有两种： 1.节约空间，所以在需要时再建儿子。只开一条链，类似可持久化线段树。 2.运用可持久化线段树的时候（此文章不会提及）。 动态开点线段树 我们来观察一下普通线段树的左儿子和右儿子的表示方法： 左儿子：p 右儿子：p 这样，虽然我们可以直接算出左右儿子，比较方便，但是，这样也浪费了大量的空间。 在学习二叉树的时候，二叉树还有哪种存储方法呢？ 链式储存法，即对一个节点建立左右儿子指针，指向它的左右儿子。这样，建立新节点时，就不会浪费多余的空间。 这样一来，没有了空间的浪费，我们所需要的空间就大大减少了。对于动态开点二叉树，我们只需要开 2 N 的数组就可以了。 实现 动态开点线段树的实现和普通线段树差别不大，只是需要在使用节点时判断当前节点是否存在，如果不存在要建立新节点。 模板： 动态开点 不能再build 也不再像之前 tr[u].l ,tr[u].r， 而是通过参数传递。l,r 表示维护区间，L，R为查询和更新区间。 lson和rson表示左右子节点。 注意tot赋值，在pushdown中处理。 动态开点数量 = q * log(N) ,q 为查询次数，N 为数据范围。 // 动态开点 const int N = 3000010; // N = log(10 ^ 9) * 10 ^ 5 = 3 * 10^ 6 int root, tot = 1; struct Node { int lson, rson; // TODO: 需要维护的信息和懒标记 int v, lazy; Node():lson(0), rson(0), v(0), lazy(0){} }tr[N]; void pushup(Node& u, Node& l, Node& r){ // TODO: 利用左右儿子信息维护当前节点的信息 } void pushup(int u){ pushup(tr[u], tr[tr[u].lson], tr[tr[u].rson]); } void pushdown(int u, int l, int r, int m) { // TODO: 将懒标记下传 // if(tr[u].lazy == *) return; if(! tr[u].lson) tr[u].lson = ++ tot; // !!! if(! tr[u].rson) tr[u].rson = ++ tot; auto &root = tr[u], &left = tr[tr[u].lson], &right = tr[tr[u].rson]; // 置空 if(tr[u].lazy){ // left: m - l + 1 , right : r - m } } void update(int& u, int l, int r, int L, int R, int val) { if(r R) return ; else if (l >= L && r > 1; pushdown(u, l, r, mid); update(tr[u].lson, l, mid, L, R, val); update(tr[u].rson, mid + 1, r, L, R, val); pushup(u); } } Node query(int u, int l, int r, int L, int R){ if(r R) return Node(); else if(l >= L && r > 1; pushdown(u, l, r, mid); if(r mid) return query(tr[u].rson, mid + 1, r, L, R); else { Node res; auto left = query(tr[u].lson, l, mid, L, R); auto right = query(tr[u].rson, mid + 1, r, L, R); pushup(res, left, right); return res; } } } // root = 1; memset(tr, 0, sizeof tr); update(root, 1, 1e9, L, R, 1); query(root, 1, 1e9, L, R); 例题： Range 模块 const int N = 3000010; // log(10 ^ 9) * 10 ^ 4 = 3 * 10 ^ 5; 暂时还有问题 ，不对 struct Node { int lson, rson; int v, lazy0, lazy1; // TODO: 需要维护的信息和懒标记 Node(){} Node(int ls, int rs, int v, int l0, int l1):lson(ls), rson(rs), v(v), lazy0(l0), lazy1(l1){} }tr[N R) return ; else if (l >= L && r > 1; pushdown(u, l, r, mid); if (l mid) update(tr[u].rson, mid + 1, r, L, R, val); pushup(u); } } Node query(int u, int l, int r, int L, int R){ if(r R) return Node(0,0,1,0,0); else if(l >= L && r > 1; pushdown(u, l, r, mid); if(r mid) return query(tr[u].rson, mid + 1, r, L, R); // else { Node res; auto left = query(tr[u].lson, l, mid, L, R); // auto right = query(tr[u].rson, mid + 1, r, L, R); // pushup(res, left, right); return res; } } } class RangeModule { public: RangeModule() { root = 1; memset(tr, 0, sizeof tr); } void addRange(int left, int right) { update(root, 0, 1e9, left, right - 1, 1); } bool queryRange(int left, int right) { return query(root, 0, 1e9, left, right - 1).v; } void removeRange(int left, int right) { update(root, 0, 1e9, left, right - 1, 0); } }; /** * Your RangeModule object will be instantiated and called as such: * RangeModule* obj = new RangeModule(); * obj->addRange(left,right); * bool param_2 = obj->queryRange(left,right); * obj->removeRange(left,right); */ ★★★★★统计区间中的整数数目 给你区间的 空 集，请你设计并实现满足要求的数据结构： 新增：添加一个区间到这个区间集合中。 统计：计算出现在 至少一个 区间中的整数个数。 实现 CountIntervals 类： CountIntervals() 使用区间的空集初始化对象 void add(int left, int right) 添加区间 [left, right] 到区间集合之中。 int count() 返回出现在 至少一个 区间中的整数个数。 注意：区间 [left, right] 表示满足 left 解： 3种方法： 区间合并处理 动态开点线段树 + 懒标记 动态开点线段树-简洁版： 具体： 一：区间合并处理 求区间并集模板题。用一个 set 有序地维护所有不相交的区间，当加入区间 [left, right] 时，通过 lower_bound 快速找到第一个右端点大等于 left - 1 的区间，然后不断用接下来的区间和 [left, right] 合并，直到当前区间的左端点大于 right + 1。由于每个区间只会加入以及离开 set 一次，复杂度 O(nlog n) 其中对端点+-1的考虑： 为了把虽然不相交但是连续的区间也合并，比如 [1,3], [4, 6] 可以合并成 [1, 6]。当然对于本题而言这样的合并不需要。直接用 left 和 right 判断也可以，但作为模板的角度合并可能更合适一点。 注意： 区间[L, R] ，极限情况能与[.., L - 1], [R + 1, ..] 合并。 class CountIntervals { typedef pair PII; int ans = 0; set st; public: CountIntervals() { } void add(int left, int right) { int L = left, R = right; auto it = st.lower_bound(PII(left - 1, -2e9)); while (it != st.end()) { if (it->second > right + 1) break; L = min(L, it->second); // 不断扩大当前正在合并的新区间范围 R = max(R, it->first); ans -= it->first - it->second + 1; // 被合并的去掉 最后在新的区间中再添加 st.erase(it++); // 移除该区间! } ans += R - L + 1; st.insert(PII(R, L)); // first为 右端点， second为左端点 } int count() { return ans; } }; 二、动态开点线段树 + 懒标记 由于区间范围过大，需要使用动态开点。 懒标记本题其实是不需要的。 const int N = 3000010; // N = log(10 ^ 9) * 10 ^ 5 = 3 * 10^ 6 struct Node { int lson, rson; int v, lazy; // TODO: 需要维护的信息和懒标记 Node():lson(0), rson(0), v(0), lazy(0){} }tr[N]; int root, tot = 1; void pushup(Node& u, Node& l, Node& r){ // TODO: 利用左右儿子信息维护当前节点的信息 u.v = l.v + r.v; } void pushup(int u){ pushup(tr[u], tr[tr[u].lson], tr[tr[u].rson]); } void pushdown(int u, int l, int r, int m) { // TODO: 将懒标记下传 // if(tr[u].lazy == *) return; if(! tr[u].lson) tr[u].lson = ++ tot; // !!! 动态开点特有 if(! tr[u].rson) tr[u].rson = ++ tot; auto &root = tr[u], &left = tr[tr[u].lson], &right = tr[tr[u].rson]; // 置空 if(tr[u].lazy){ left.v = root.lazy * (m - l + 1); right.v = root.lazy * (r - m); left.lazy = root.lazy; right.lazy = root.lazy; root.lazy = 0; } } void update(int& u, int l, int r, int L, int R, int val) { // if(! u) u = ++ tot; if(r R) return ; // 动态开点特有 else if (l >= L && r > 1; pushdown(u, l, r, mid); // 动态开点 if (l mid) update(tr[u].rson, mid + 1, r, L, R, val); pushup(u); } } Node query(int u, int l, int r, int L, int R){ if(r R) return Node(); // 动态开点特有 else if(l >= L && r > 1; pushdown(u, l, r, mid); // 动态开点 if(r mid) return query(tr[u].rson, mid + 1, r, L, R); // else { Node res; auto left = query(tr[u].lson, l, mid, L, R); // auto right = query(tr[u].rson, mid + 1, r, L, R); // pushup(res, left, right); return res; } } } class CountIntervals { public: CountIntervals() { root = 1; // memset(tr, 0, sizeof tr); // } void add(int left, int right) { update(root, 1, 1e9, left, right, 1); } int count() { return query(root, 1, 1e9, 1, 1e9).v; } }; /** * Your CountIntervals object will be instantiated and called as such: * CountIntervals* obj = new CountIntervals(); * obj->add(left,right); * int param_2 = obj->count(); */ 三、动态开点线段树-简洁版： 1.tql。指针形式开点。 2.默认维护[1, 1e9],根据需要建立左右子节点。 class CountIntervals { CountIntervals *left = nullptr, *right = nullptr; int l, r, sum = 0; public: CountIntervals() : l(1), r(1e9) {} CountIntervals(int l, int r) : l(l), r(r) {} void add(int L, int R) { // 为方便区分变量名，将递归中始终不变的入参改为大写（视作常量） if (sum == r - l + 1) return; // 当前节点已被完整覆盖，无需执行任何操作 if (L add(L, R); if (mid add(L, R); sum = left->sum + right->sum; } int count() { return sum; } }; 其他题： 矩形面积 II 参考方法： 1.扫描线 2.离散化+线段树 3.动态开点线段树 我的日程安排表I 维护区间最值并对区间进行加减更新，暴力维护，差分数组 我的日程安排表 II维护区间最值并对区间进行加减更新，暴力维护，差分数组 我的日程安排表 III维护区间最值并对区间进行加减更新，差分数组 区域和检索数组可修改 维护区间和并对区间进行覆盖更新 参考： 动态开点线段树 动态开点线段树 浅谈动态开点线段树 5 可持久化数据结构(可持久化树) 「历史」浅谈权值线段树到可持久化树 学习笔记：可持久化线段树（可持久化树）：静态 + 动态 前置知识： 1.线段树 2.树状数组 3.权值线段树：相当于将线段树当成一个桶，其中的每一个点所代表的区间相当于一段值域。维护的值为这段值域中的一些信息。 4.可持久化概念： 可持久化实质上就是存储该数据结构所有的历史状态，以达到高效的处理某些信息的目的。 即可用不同版本的n棵权值线段树组成一棵可持久化树 静态第k小数 第k小数 给定长度为 N 的整数序列 A，下标为 1∼N。 现在要执行 M 次操作，其中第 i 次操作为给出三个整数 li,ri,ki，求 A[li],A[li+1],…,A[ri] (即 A 的下标区间 [li,ri])中第 ki 小的数是多少。 输入格式 第一行包含两个整数 N 和 M。 第二行包含 N 个整数，表示整数序列 A。 接下来 M 行，每行包含三个整数 li,ri,ki，用以描述第 i 次操作。 输出格式 对于每次操作输出一个结果，表示在该次操作中，第 k 小的数的数值。 每个结果占一行。 数据范围 N≤105,M≤104,|A[i]|≤109 输入样例： 7 3 1 5 2 6 3 7 4 2 5 3 4 4 1 1 7 3 输出样例： 5 6 3 解： 法1.可持久化树 我们可以建立一颗权值线段树，每个点存储的信息为该值域区间存在的数的个数。 因为线段树的性质，所以每个点的左子树的值域区间 所以我们先看左子树区间有多少个数，记为cntleft 。 如果ki 我们发现可以用前缀和来维护： 只要用预处理大法分别以[1,li]和[1,ri]的数建立权值线段树，每个点的值对位相减即可。 关键性质 发现以[1,x]和[1,x+1]区间内的数所建立的权值线段树的差异仅在一条链上：（A[x+1]的次数+1）。 也就是不超过log2n个点。我们可以考虑动态开点： 与上一个权值线段树没有差异的地方直接指引过去 有差异，单独新增一个点 这样即可预处理出1,x所有的权值线段树了。 时间复杂度O(nlog2n)，空间复杂度O(2n+nlog2n)。 注意：由于值域很大，我们需要离散化一下。 #include #include #include using namespace std; const int N = 100005; //d 为离散化数组 int n, m, len, a[N], d[N]; //T[i] 为 [1, i] 区间的权值线段树的根节点 int T[N], tot = 0; //线段树的每个点 struct SegTree{ int l, r, v; }t[N * 20]; //建树 int build(int l, int r){ int p = ++tot, mid = (l + r) >> 1; if(l > 1; t[p].l = t[pre].l, t[p].r = t[pre].r, t[p].v = t[pre].v + 1; if(l > 1; if(k 带注释： #include #include #include using namespace std; const int N = 1e6 + 5; // int n, m, len, a[N], d[N]; // int T[N], tot = 0; struct SegTree{ int l, r, v; }t[N * 20]; // int build(int l, int r){ int p = ++ tot, mid = l + r >> 1; if(l > 1; t[p].l = t[pre].l, t[p].r = t[pre].r, t[p].v = t[pre].v + 1; // 先把替代节点的信息继承下来 更改v即可 // 根据具体位置 进行更新整条链的各节点信息 如在左链上，创建新的左链，并把当前节点的l指向它。 // cout > 1; if(k 法2：树状数组 + 整体二分 #include #include #include #include #include using namespace std; const int N = 100010, M = 50010; int n, m; struct A { int id, x; }a[N]; struct Q { int id; int l, r, k; }q[M]; int f[N], ans[M]; inline bool cmp(const A &p, const A &q) { return p.x r) return; if (L == R) { for (int i = l; i > 1; for (int i = L; i (t = query(q[j].r) - query(q[j].l - 1))) { q[j].k -= t; j--; } if (i [美团T4：中位数] 现在给定一个序列。 若其长度为奇数，那么其中位数是将序列从小到大排序后位于正中间位置的数； 若其长度为偶数，那么其中位数是将序列从小到大排序后位于中间的两个数的平均值。 现在给你一个长度为 n 的序列，求所有长度为奇数的区间的中位数之和为多少。 第一行n，表示有n个数。下一行有n个数。 其中：1 解： 法1：可持久化树(可持久化线段树) 若为任意k次询问,则不方便使用该方法。需要单独排序[l,r],共用 knlog(n) 若为本题所述 n^2 次询问，为 n^2*log(n)，与可持久化树相当。 法2：树状数组+二分 若为任意k次询问,为 k log^2(n)，比普通排序好，比可持久化树差。 若为本题所述 n^2 次询问，为 n^2*log^2(n) 比可持久化树和有限队列差。 法3：有限队列 若为任意k次询问,为 k log(n) 若为本题所述 n^2 次询问，为 n^2*log(n) long long res = 0; for (int i = 1; i down; priority_queue, greater> up; for (int j = i; j up.top()) up.push(a[j]); else down.push(a[j]); if (up.size() > down.size() + 1) down.push(up.top()), up.pop(); if (down.size() > up.size()) { up.push(down.top()), down.pop(); } if (!((j - i) & 1)) { res += up.top(); } } } cout 动态第k小数 Dynamic Rankings 给定长度为NN的序列AA，有MM次询问： 给定li,ri,ki ，求在[li,ri] 区间内第ki 小的数是多少。 给定xi,vali ，将A[xi] 的值改为vali 。 N 解决方案：可持久化树 + 树状数组思路优化 注：这道题也有树套树和整体二分的做法，这里讲解的是可持久化树 + 树状数组思路优化。 #include #include #include using namespace std; //P为最多可能的线段树点数 const int N = 100005, P = N * 441, L = 20; //操作序列 struct Ops{ int i, j, k; }op[N]; //线段树 struct SegTree{ int l, r, v; }t[P]; //d数组为离散化数组 int n, m, len = 0, a[N], d[N > 1; t[p].v = 0; if(l > 1; t[p].l = t[pre].l, t[p].r = t[pre].r, t[p].v = t[pre].v + v; if(l > 1, sum = 0; //前缀和 for(int i = 1; i 6 AC自动机 以下为进阶 7 分块 分块是有一种优雅的暴力 分块的基本思想是，通过对原数据的适当划分，并在划分后的每一个块上预处理部分信息，从而较一般的暴力算法取得更优的时间复杂度。 分块的时间复杂度主要取决于分块的块长，一般可以通过均值不等式求出某个问题下的最优块长，以及相应的时间复杂度。 分块是一种很灵活的思想，相较于树状数组和线段树，分块的优点是通用性更好，可以维护很多树状数组和线段树无法维护的信息。 当然，分块的缺点是渐进意义的复杂度，相较于线段树和树状数组不够好。 不过在大多数问题上，分块仍然是解决这些问题的一个不错选择。 基本思想 分块算法实质上是一种是通过分成多块后在每块上打标记以实现快速区间修改，区间查询的一种算法。其均摊时间复杂度为 O(√ n) 分块算法相较于各种树形数据结构，具有简便易写，方便调试等多种优点。在同等数据规模下，如 1e5 ，其时间效率并不会低太多，在考试时反而是一种有力的得分方法。 但是若是数据量到1s/5e5以上，基本上就会T… 分块的实质 分块其实是一种树形结构，它是一种只有三层的树，形态如下： 案例： 问题引入： 给出一个非负整数序列A，元素个数为N（N 在查询过程中元素可能发生改变（插入、删除等），就称为在线查询，反之叫离线查询。上面的问题就是在线查询。 如果直接暴力做法来做，在每次添加或删除元素之后就要用O(n)的时间复杂度来移动序列元素，效率将及其低下。这种解决方法有很多，这里介绍最容易理解的一种——分块思想。 分块就是将有序元素分为若干块。比如可以把{1, 2, 4, 9, 12, 34, 56, 78, 87}分为3块{1, 2, 4}、{9, 12, 34}、{56, 78, 87}。一般为了高效率，对有N个元素的有序序列来说除了最后一块以外，每个块中元素的个数都是√(N)（取下界）个，块数就是√(N)（取上界）个。比如11个数，可以分为√(N)（取下界）即3个，一共分为√(N)（取上界）即4块，块内元素分别有3、3、3、2个。 现在利用分块法解决问题。题目中因为说明N 【例】数据范围为0 ~ 8，则可以分为3块，0号块负责0 ~ 2，1号块负责3 ~ 5，2号块负责6 ~ 8.现在假设有0，1，3，4，4，5，8，此时block数组和table数组情况如下： block[0] = 2，0号块有0，1两个元素 block[1] = 4，1号块有3，4，4，5这四个元素 block[2] = 1，2号块只有8这1个元素 table[0] = table[1] = table[3] = table[5] = table[8] = 1 都只有1个数 但是table[4] = 2，因为有两个4 然后找第K大的数，假设K是5，sum表示当前已经累计存在的数的个数，初始为0 遍历到0号块时，sum + block[0] = 0 + 2 = 2 5，所以第K大的数在1号块内。 sum = 2，接下来遍历1号块内每个元素，即3，4，4，5 遍历到元素3时，sum = sum + table[3] = 3 4，因此找到4，即为第K大的数 例题： 一个简单的整数问题2 题解见 线段树懒标记 部分的四种题解。 常用板子 下面给出几种分块常用板子： 1.区间加法，单点查询 2.区间加法，区间求和 3.区间加法，区间查小于X的个数 4.区间加乘，单点查值 5.区间异或，区间求值 练习题： UVA - 12003 - Array Transformer UVA - 11990 Dynamic Inversion SPOJ - Give Away Codeforces - Till I Collapse Codeforces - Destiny Codeforces - Holes Codeforces - XOR and Favorite Number Codeforces - Powerful array SPOJ - DQUERY 参考： 分块思想 浅谈分块思想 块状链表 略 莫队 基础 HH的项链 查询每个区间段内数字的种类数。 解：提供四种解法： 需要采用离散算法的有(即先对查询进行一定操作，如按某种规则排序) 1.树状数组 2.线段树 3.莫队(排序规则稍微不同) hjt算法可支持在线计算 (即如果要求在线查询时只有该方法在该数据级下可用) 4.hjt树 1.离线+树状数组 注意编号区间太大，不能用t[i]的i代表编号。而是用i表示查询的区间断电。 否则需要把查询的端点和编号进行离散化。同时再用以下代码中类似ls数组的思想进行更新树状数组。 只不过能使ls的数组开小点。由100w到50w以下。 #include #include #include #include #include #include #include using namespace std; const int N = 100010, M = 200010; #define fir(i, a, b) for (int i = a;i = b;i --) #define read(x) scanf(\"%d\", &x) #define read2(x, y) scanf(\"%d %d\", &x, &y) #define readn(x, a, b) fir(i, a, b) scanf(\"%d\", &x[i]) int n, m; int a[N]; int ans[M]; unordered_map mp; // 不如直接数组快 // int mp[1000010]; int t[N]; // 1-n int lowbit(int x){return x & -x;} void add(int x,int k) { for( ; x > n; readn(a, 1, n); cin >> m; fir(i, 1, m){ read2(q[i].l, q[i].r); q[i].idx = i; } sort(q + 1, q + m + 1); for(int i = 1, j = 1; i 2.离线+线段树 #include #include #include #include #include #include #include using namespace std; const int N = 100010, M = 200010; #define fir(i, a, b) for (int i = a;i = b;i --) #define read(x) scanf(\"%d\", &x) #define read2(x, y) scanf(\"%d %d\", &x, &y) #define readn(x, a, b) fir(i, a, b) scanf(\"%d\", &x[i]) int n, m; int a[N]; int ans[M]; unordered_map mp; // 不如直接数组快 // int mp[1000010]; struct Node { int l, r; int cnt; }tr[N * 4]; void pushup(Node& u, Node& l, Node& r){ u.cnt = l.cnt + r.cnt; } void pushup(int u){ pushup(tr[u], tr[u > 1; build(u = l && tr[u].r > 1; if (l mid) update(u = l && tr[u].r > 1; if(l mid) update(u = l && tr[u].r > 1; if(r mid) return query(u = l && tr[u].r > 1; if(r mid) return query(u > n; readn(a, 1, n); cin >> m; fir(i, 1, m){ read2(q[i].l, q[i].r); q[i].idx = i; } sort(q + 1, q + m + 1); build(1, 1, n); for(int i = 1, j = 1; i 3.离线 + 莫队 #include #include #include #include #include #include #include using namespace std; #define fir(i, a, b) for (int i = a;i = b;i --) #define read(x) scanf(\"%d\", &x) #define read2(x, y) scanf(\"%d %d\", &x, &y) #define readn(x, a, b) fir(i, a, b) scanf(\"%d\", &x[i]) const int N = 50010, M = 200010, S = 1000010; int n, m, len; int a[N], ans[M]; int cnt[S]; int get(int x) {return x / len;} struct Query{ int l, r, idx; bool operator > n; readn(a, 1, n); cin >> m; fir(i, 1, m){ read2(q[i].l, q[i].r); q[i].idx = i; } len = max(1, (int)sqrt((double)n * n / m)); sort(q + 1, q + m + 1); for(int k = 1, i = 0, j = 1, res = 0; k r) del(a[i --], res); while(j l) add(a[-- j], res); ans[idx] = res; } fir(i, 1, m) printf(\"%d\\n\", ans[i]); return 0; } 4.(在线)hjt树 核心： ne数组:ne数组记录a[i]右边离a[i]最近且等于a[i]的下标(即:a[i]下一次出现的位置), 如果不存在,则令ne[i]=n+1 (数组最后一位下标加1) 建立过程 然后再对值域1,n+1建立权值线段树,然后再将ne数组元素一个个插入 查询 a数组区间[l,r]内不同数的个数即为ne数组区间[l,r]中大于等于r+1的数的个数 例如: 对于a数组: 1 2 2 2 1 3 2 3 3 1 4 1 其ne数组为:5 3 4 7 10 8 13 9 13 12 13 13 [3,7]区间内不同数的个数就是ne数组[3,7]区间([4 7 10 8 13])中大于等于8的数的个数:3 // 参考：https://www.acwing.com/solution/content/69639/ 以下两题为同题。 蓝桥杯：字串分值和 字符串的总引力 字符串的 引力 定义为：字符串中 不同 字符的数量。 例如，\"abbca\" 的引力为 3 ，因为其中有 3 个不同字符 'a'、'b' 和 'c' 。 给你一个字符串 s ，返回 其所有子字符串的总引力 。 子字符串 定义为：字符串中的一个连续字符序列。 示例 1： 输入：s = \"abbca\" 输出：28 解释：\"abbca\" 的子字符串有： -长度为 1 的子字符串：\"a\"、\"b\"、\"b\"、\"c\"、\"a\" 的引力分别为 1、1、1、1、1，总和为 5 。 -长度为 2 的子字符串：\"ab\"、\"bb\"、\"bc\"、\"ca\" 的引力分别为 2、1、2、2 ，总和为 7 。 -长度为 3 的子字符串：\"abb\"、\"bbc\"、\"bca\" 的引力分别为 2、2、3 ，总和为 7 。 -长度为 4 的子字符串：\"abbc\"、\"bbca\" 的引力分别为 3、3 ，总和为 6 。 -长度为 5 的子字符串：\"abbca\" 的引力为 3 ，总和为 3 。 引力总和为 5 + 7 + 7 + 6 + 3 = 28 。 示例 2： 输入：s = \"code\" 输出：20 解释：\"code\" 的子字符串有： -长度为 1 的子字符串：\"c\"、\"o\"、\"d\"、\"e\" 的引力分别为 1、1、1、1 ，总和为 4 。 -长度为 2 的子字符串：\"co\"、\"od\"、\"de\" 的引力分别为 2、2、2 ，总和为 6 。 -长度为 3 的子字符串：\"cod\"、\"ode\" 的引力分别为 3、3 ，总和为 6 。 -长度为 4 的子字符串：\"code\" 的引力为 4 ，总和为 4 。 引力总和为 4 + 6 + 6 + 4 = 20 。 提示： 1 解：区别于项链，本题查询量更大，但也更有规律。则需要使用数学思想。 法1： class Solution { public: long long appealSum(string s) { long ans = 0L, sum_g = 0L; vector pos(26, -1); for (int i = 0; i 法2：dp dp记录每个下标元素作为子序列尾部的总引力 哈希表记录每个元素出现的最大下标 当前下标为i,上一个元素下标为j时, 子序列起始下标在[0, j]之间时引力不变, [j + 1, i]之间时引力 + 1 所以dp的转移方程 dp[i + 1] = dp[i] + i - j class Solution: def appealSum(self, s: str) -> int: l = len(s) dp = [0 for i in range(l + 1)] d = {} for i, n in enumerate(s): dp[i + 1] = dp[i] + i - d.get(n, -1) #当不存在j时,j为-1 d[n] = i return sum(dp) 法3：计算贡献 字符在哪些子串中有贡献呢？ 子串左边界取值范围 [last + 1, i] 子串右边界 取值范围 [i, n - 1] 根据乘法原则，这样的子串共 (i - last) * (n - i) 个 对于每个子串，如果一个子字符串包含多个相同字符（比如 a），那么不妨规定， 只有最左侧的 a 将对答案做出贡献，这样相同的字符就只被统计了一次。这样，设字母 a 在字符串出现的情况为 ...a....a....a...，那么： 第 1 个 a 可以做出贡献的子串范围为：[...a....a....a...] 第 2 个 a 可以做出贡献的子串范围为：...a[....a....a...] 第 3 个 a 可以做出贡献的子串范围为：...a....a[....a...] class Solution { public: long long appealSum(string s) { vector lasts(26, -1); long long res = 0; for(int i = 0; i 类似题有： 828. 统计子串中的唯一字符 907. 子数组的最小值之和 1498. 满足条件的子序列数目 2104. 子数组范围和 带修改的莫队 数颜色 回滚莫队 历史研究 树上莫队 树上计数 二次离线莫队 二次离线莫队 参考： 莫队算法专题 莫队算法——从入门到黑题 平衡树 Splay 树套树 树链剖分 动态树 Dancing Links 左偏树 后缀数组 参考： SA-IS学习笔记 后缀数组 最详细讲解 后缀自动机SAM 参考： SAM绘制工具 写个后缀自动机（一定要赞） 史上最通俗的后缀自动机详解 点分治和点分树 CDQ分治 仙人掌 Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-11-06 11:52:23 "},"01_数据结构与算法笔记/01_学习笔记/05_动态规划.html":{"url":"01_数据结构与算法笔记/01_学习笔记/05_动态规划.html","title":"1.5 动态规划","keywords":"","body":"动态规划 包括线性DP(数字三角形模型、最长上升子序列模型、编辑距离)、背包模型(01背包、完全背包、多重背包、分组背包、混合背包...)、状态机、状态压缩DP、区间DP(石子合并..)、树形DP、数位DP、单调队列优化DP、斜率优化DP等内容 【学习笔记】动态规划—各种 DP 优化 ★★★★★ 什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ 0 动态规划 传统dp:关键词：状态表示、状态转移、最优子结构、重叠子问题、后效性 DP问题一般是求若干有限集合中的最值问题，并且此类问题存在子问题重叠（Overlap-subproblems），如果通过暴力枚举每种可能解决问题，那么将会有大量重复的计算；如果从集合角度来分析DP问题，每次枚举一个集合并且利用子问题重叠特性，将子问题的解存储下来，可以大大提高效率； DP问题的核心是状态集合 f(i) 的定义，在状态及转移计算中，划分子集的依据：寻找最后一个不同点，即处理最后一个子集的选择。 最优子结构 无后效性 一个最优策略的子策略必然也是最优的。 动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划应用于子问题重叠的情况： 要去刻画最优解的结构特征； 尝试递归地定义最优解的值（就是我们常说的考虑从 i - 1 转移到 i）； 计算最优解； 利用计算出的信息构造一个最优解。 动态规划原理 两个要素： 最优子结构 具有最优子结构也可能是适合用贪心的方法求解。 注意要确保我们考察了最优解中用到的所有子问题。 证明问题最优解的第一个组成部分是做出一个选择； 对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择； 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间； 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。 要保持子问题空间尽量简单，只在必要时扩展。 最优子结构的不同体现在两个方面： 原问题的最优解中涉及多少个子问题； 确定最优解使用哪些子问题时，需要考察多少种选择。 子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。 经典问题： 无权最短路径： 具有最优子结构性质。 无权最长（简单）路径： 此问题不具有，是 NPC 的。区别在于，要保证子问题无关，即同一个原问题的一个子问题的解不影响另一个子问题的解。相关：求解一个子问题时用到了某些资源，导致这些资源在求解其他子问题时不可用。 子问题重叠 子问题空间要足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。 重构最优解 存表记录最优分割的位置，就不用重新按照代价来重构。 百科： 原理 动态规划问世以来，在经济管理、生产调度、工程技术和最优控制等方面得到了广泛的应用。例如最短路线、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划方法比用其它方法求解更为方便 [3] 。 虽然动态规划主要用于求解以时间划分阶段的动态过程的优化问题，但是一些与时间无关的静态规划(如线性规划、非线性规划)，只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解 [3] 。 概念引入 在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法 [4] 。 基本思想 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式 [5] 。 基本概念 多阶段决策问题 如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题 [6] 。 各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果 [6] 。 动态规划问题中的术语 阶段把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的 [6] 。 状态状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点 [6] 。 无后效性我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性 [6] 。 决策：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史 [6] 。 决策变量的范围称为允许决策集合 [6] 。 策略由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合 [6] 。 允许策略集合中达到最优效果的策略称为最优策略 [6] 。 给定k阶段状态变量x(k)的值后，如果这一阶段的决策变量一经确定，第k+1阶段的状态变量x(k+1)也就完全确定，即x(k+1)的值随x(k)和第k阶段的决策u(k)的值变化而变化，那么可以把这一关系看成(x(k)，u(k))与x(k+1)确定的对应关系，用x(k+1)=Tk(x(k),u(k))表示。这是从k阶段到k+1阶段的状态转移规律，称为状态转移方程 [6] 。 最优化原理：作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略” [6] 。 最优性原理实际上是要求问题的最优策略的子策略也是最优 [6] 。 基本结构 多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法 [7] 。 适用条件 任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性 [8] 。 最优化原理（最优子结构性质） 最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质 [8] 。 无后效性 将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性 [8] 。 子问题的重叠性 动态规划算法的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间 [8] 。 分类 动态规划的数学模型。根据决策过程的演变是确定性的还是随机性的。可分为确定性决策过程和随机性决策过程。另外。也可按时间参量是离散的或是连续的变量。分为离散决策过程和连续决策过程。组合起来就有离散确定性．离散随机性．连续确定性．连续随机性四种决策过程模型 [9] 。 对于确定性的决策过程。问题中下一段的状态已由当前段的状态及决策完全确定。对于随机性决策过程。它与确定性决策过程的区别在于下一段的状态并不能由当前段的状态及决策完全确定。而是按某种概率分布来决定下一段的状态。这种概率分布是由当前段的状态和决策完全确定 [9] 。 局限性编辑 播报 动态规划对于解决多阶段决策问题的效果是明显的，但是动态规划也有一定的局限性。首先，它没有统一的处理方法，必须根据问题的各种性质并结合一定的技巧来处理；另外当变量的维数增大时，总的计算量及存贮量急剧增大。 两种形式 动态规划与分治方法相似，都是通过组合子问题的解来求解原问题。 动态规划是分治方法的特例，应用于子问题重叠的情况。在这种情况下，分治算法会反复求解这些重叠的子问题。而动态规划算法对每个子问题只求解一次，将其解保存下来，而无需每次都计算。 动态规划的实现有两种形式：递推形式和递归形式。 递推形式 通常采用自底往上的方法。 缺点 有时候状态之间的依赖关系不明显。 可能会计算到无用状态。 递归形式（记忆化搜索） 在分治算法的基础上，把计算过的子问题的解保存下来，再次处理这个子问题时直接输出保存下来的解。 优点 不用重新考虑状态之间的依赖关系，在分治代码的基础上简单改动即可。 只有需要用到某个状态才会计算，不会计算无用状态。 缺点 无用状态不多或没有时，比递推开销大，运行慢。 两种实现形式的选择 有些题目只能用记忆化搜索，有些题目只能用递推。 有些题目这两种形式都可以用，选择方法如下： 当无用状态多的时候，用记忆化搜索。 当无用状态不多，依赖关系明显的时候，用递推。 以上两种都不是的时候，优先选择记忆化搜索。 闫氏DP分析法 从集合角度考虑DP问题，又称闫氏分析法，包含以下两步： 状态表示——集合以及属性(Max/Min/数量/存在性)； 状态计算——集合的划分。一个重要的划分依据：“最后一步”；集合划分原则：可重但不漏。 1 线性DP 0 引入 斐波那契 爬楼梯模型 1.基础 2.见下题 统计打字方案数 Alice 在给 Bob 用手机打字。数字到字母的 对应 如下图所示。 为了 打出 一个字母，Alice 需要 按 对应字母 i 次，i 是该字母在这个按键上所处的位置。 比方说，为了按出字母 's' ，Alice 需要按 '7' 四次。类似的， Alice 需要按 '5' 两次得到字母 'k' 。 注意，数字 '0' 和 '1' 不映射到任何字母，所以 Alice 不 使用它们。 但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 按键的字符串信息 。 比方说，Alice 发出的信息为 \"bob\" ，Bob 将收到字符串 \"2266622\" 。 给你一个字符串 pressedKeys ，表示 Bob 收到的字符串，请你返回 Alice 总共可能发出多少种文字信息 。 由于答案可能很大，将它对 109 + 7 取余 后返回。 示例 1： 输入：pressedKeys = \"22233\" 输出：8 解释： Alice 可能发出的文字信息包括： \"aaadd\", \"abdd\", \"badd\", \"cdd\", \"aaae\", \"abe\", \"bae\" 和 \"ce\" 。 由于总共有 8 种可能的信息，所以我们返回 8 。 示例 2： 输入：pressedKeys = \"222222222222222222222222222222222222\" 输出：82876089 解释： 总共有 2082876103 种 Alice 可能发出的文字信息。 由于我们需要将答案对 109 + 7 取余，所以我们返回 2082876103 % (109 + 7) = 82876089 。 提示： 1 解： class Solution { const int MOD = 1000000007; public: int countTexts(string pressedKeys) { int n = pressedKeys.size(); vector f(n + 1), g(n + 1); f[0] = g[0] = 1; for (int i = 1; i 组合数计算 常用于数位dp，见数位dp部分。 const int N = 55; LL f[55][55]; void init(){ f[0][0] = 1; for(int i = 1; i 同时用c(n, 0) + c(n, 1) + ... c(n, n - 1) + c(n, n) = 2 ^ n; #786 (Div. 3)Infinite Replacement 其中，在计算长度为n的ori = \"aaaa...aa\",每个a均可用 s = tar (不含a) 替换时的方案数时 可用组合数公式，或直接采用 上式 计算即可。 string ori, tar; cin >> ori >> tar; if(tar == \"a\") cout 0) cout 有效括号问题 最长有效括号 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 输入：s = \"(()\" 输出：2 解释：最长有效括号子串是 \"()\" 示例 2： 输入：s = \")()())\" 输出：4 解释：最长有效括号子串是 \"()()\" 示例 3： 输入：s = \"\" 输出：0 提示： 0 dp class Solution { public: int longestValidParentheses(string s) { int maxans = 0, n = s.length(); vector dp(n, 0); for (int i = 1; i = 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') { dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = max(maxans, dp[i]); } } return maxans; } }; 栈 class Solution { public: int longestValidParentheses(string s) { int left = 0, right = 0, maxlength = 0; for (int i = 0; i left) { left = right = 0; } } left = right = 0; for (int i = (int)s.length() - 1; i >= 0; i--) { if (s[i] == '(') { left++; } else { right++; } if (left == right) { maxlength = max(maxlength, 2 * left); } else if (left > right) { left = right = 0; } } return maxlength; } }; 检查是否有合法括号字符串路径 一个括号字符串是一个 非空 且只包含 '(' 和 ')' 的字符串。如果下面 任意 条件为 真 ，那么这个括号字符串就是 合法的 。 字符串是 () 。 字符串可以表示为 AB（A 连接 B），A 和 B 都是合法括号序列。 字符串可以表示为 (A) ，其中 A 是合法括号序列。 给你一个 m x n 的括号网格图矩阵 grid 。网格图中一个 合法括号路径 是满足以下所有条件的一条路径： 路径开始于左上角格子 (0, 0) 。 路径结束于右下角格子 (m - 1, n - 1) 。 路径每次只会向 下 或者向 右 移动。 路径经过的格子组成的括号字符串是 合法 的。 如果网格图中存在一条 合法括号路径 ，请返回 true ，否则返回 false 。 提示： m == grid.length n == grid[i].length 1 解： const int N = 105; bool dp[N][N][N]; class Solution { public: bool hasValidPath(vector>& grid) { memset(dp, 0, sizeof dp); int n = grid.size(), m = grid[0].size(); if(grid[0][0] != '(') return false; dp[1][1][1] = true; for(int i = 1; i = 0) { dp[i][j][k + s] |= dp[i - 1][j][k]; dp[i][j][k + s] |= dp[i][j - 1][k]; } } } } return dp[n][m][0]; } }; 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [5,4,-1,7,8] 输出：23 提示： 1 class Solution { public: int maxSubArray(vector& nums) { int pre = 0, maxAns = nums[0]; for (const auto &x: nums) { pre = max(pre + x, x); maxAns = max(maxAns, pre); } return maxAns; } }; 在此题上进行拓展： TLE最大波动的子字符串 字符串的 波动 定义为子字符串中出现次数 最多 的字符次数与出现次数 最少 的字符次数之差。 给你一个字符串 s ，它只包含小写英文字母。请你返回 s 里所有 子字符串的 最大波动 值。 子字符串 是一个字符串的一段连续字符序列。 示例 1： 输入：s = \"aababbb\" 输出：3 解释： 所有可能的波动值和它们对应的子字符串如以下所示： 波动值为 0 的子字符串：\"a\" ，\"aa\" ，\"ab\" ，\"abab\" ，\"aababb\" ，\"ba\" ，\"b\" ，\"bb\" 和 \"bbb\" 。 波动值为 1 的子字符串：\"aab\" ，\"aba\" ，\"abb\" ，\"aabab\" ，\"ababb\" ，\"aababbb\" 和 \"bab\" 。 波动值为 2 的子字符串：\"aaba\" ，\"ababbb\" ，\"abbb\" 和 \"babb\" 。 波动值为 3 的子字符串 \"babbb\" 。 所以，最大可能波动值为 3 。 示例 2： 输入：s = \"abcde\" 输出：0 解释： s 中没有字母出现超过 1 次，所以 s 中每个子字符串的波动值都是 0 。 提示： 1 解： class Solution { public: int largestVariance(string &s) { int ans = 0; for (char a = 'a'; a 1 数字三角形模型 此类问题中： 状态表示 集合：从(1,1)移动到(i,j)的所有路线 属性：最大/大小 状态计算 状态计算：集合划分->最后一步移动方向 注意： 对于求最大值或最小值，注意初始化值。以及边界的初始值和处理。 摘花生 求最大值，初始化为0即可。 最低通行费 求最小值，初始化为0x3f3f3f3f 注意对于首行首列的处理 方格取数 走两次 与前两题相比，本题“共走两次”，且每一个数最多只能选一次。可根据前述速录，分两次分开来求，再判断两次是否到达相同格子。减去重复格子即可。 维度压缩 四维表示：f[i1,j1,i2,j2]:表示从(1,1)分别走到(i1,j1),(i2,j2)的路径上能取到的数的最大值。 根据“最后一步”可划分为四种情况。每次均可向右向下组合。 三维表示：关键在于 如果在(i,j)重合,必定有两者所走步数相等，此时i1+j1==i2+j2==k（是重合的必要条件); 设两次路径一起走，所走步数为k，则有第一次走到了(i1,k-i1),第二次走到(i2,k-i2); 此时设f[k,i1,i2]为从(1,1)分别走到(i1,k-i1),(i2,k-i1)代路径上能取到的最大值。 此时最后一步也是四种情况即，下下f[k-1,i1-1,i2-1],下右f[k-1,i1-1,i2],右下f[k-1,i1,i2-1],右右f[k-1,i1,i2]; 拓展：k取方格数。方法是费用流中的最大流。动态规划题变成了图论？其实动态规划包含于图论，90%DP都能转化为最短路问题。 类似lc:摘樱桃 II2 最长上升子序列 (LIS)Longest Increasing Subsequence 此类问题中： 状态表示 集合：所有以a[i]为结尾的严格单调上升子序列 属性：最大 状态计算 状态计算：集合划分->最后一个不同的点 最长上升子序列LIS 动态规划：O(n2) 状态表示：f[i]表示从第一个数字开始算，以w[i]结尾的最大的上升序列。(以w[i]结尾的所有上升序列中属性为最大值的那一个) 状态计算（集合划分）：j∈(0,1,2,..,i-1), 在w[i] > w[j]时，f[i] = max(f[i], f[j] + 1)。 有一个边界，若前面没有比i小的，f[i]为1（自己为结尾）。最后在找f[i]的最大值。 cin >> n; for (int i = 0; i > w[i]; int mx = 1; // 找出所计算的f[i]之中的最大值，边算边找 for (int i = 0; i w[j]) f[i] = max(f[i], f[j] + 1); // 前一个小于自己的数结尾的最大上升子序列加上自己，即+1 } mx = max(mx, f[i]); } (动态规划 + 二分) O(nlogn) 状态表示：f[i]表示长度为i的最长上升子序列，末尾最小的数字。(长度为i的最长上升子序列所有结尾中，结尾最小min的) 即长度为i的子序列末尾最小元素是什么。 状态计算：对于每一个w[i], 如果大于f[cnt-1] (下标从0开始，cnt长度的最长上升子序列，末尾最小的数字)，那就cnt+1，使得最长上升序列长度+1，当前末尾最小元素为w[i]。 若w[i]小于等于f[cnt-1],说明不会更新当前的长度，但之前末尾的最小元素要发生变化，找到第一个 大于或等于 (这里不能是大于) w[i]，更新以那时候末尾的最小元素。 f[i]一定以一个单调递增的数组，所以可以用二分法来找第一个大于或等于w[i]的数字。 cin >> n; for (int i = 0 ; i > w[i]; f[cnt++] = w[0]; // cnt 比已有的大1!!! for (int i = 1; i f[cnt-1]) f[cnt++] = w[i]; else { int l = 0, r = cnt - 1; while (l > 1; if (f[mid] >= w[i]) r = mid; else l = mid + 1; } f[r] = w[i]; // 用w[i]替换第一个大于或等于w[i]的数字 } } // stl版本 cin >> n; for (int i = 0 ; i > w[i]; vector f; f.push_back(w[0]); for (int i = 1; i f.back()) f.push_back(w[i]); else *lower_bound(f.begin(), f.end(), w[i]) = w[i]; } cout 拓展： 最长数对链class Solution { public: int findLongestChain(vector>& pairs) { sort(pairs.begin(), pairs.end()); vector arr; for (auto p : pairs) { int x = p[0], y = p[1]; if (arr.size() == 0 || x > arr.back()) { arr.emplace_back(y); } else { int idx = lower_bound(arr.begin(), arr.end(), x) - arr.begin(); arr[idx] = min(arr[idx], y); // 注意 不是直接更新为 y ! } } return arr.size(); } }; 怪盗基德的滑翔翼 双向LIS 取最大 登山 双向LIS 取和 -1即可 友好城市 排序后LIS妙啊 注意每个城市还是可以连多个城市的 最大上升子序列和 - 最长公共上升子序列LCS - 拦截导弹(贪心) 1.贪心 如何证明两个数相等？A>=B A 2.贪心流程 从前往后扫描每个数，对于每个数： 情况1：如果现有的子序列的结尾都小于当前数，则创建新子序列。 情况2：将当前数放到结尾大于等于它的最小的子序列后面。 3.？？？反链实现？？？Dilworth原理 贪心 #include #include #include using namespace std; const int N = 1010; int n; int h[N], f[N], q[N]; int main() { string line; getline(cin, line); stringstream ssin(line); while (ssin >> h[n]) n ++ ; int res = 0, cnt = 0; for (int i = 0; i 二分 + 贪心 第一问：反向不严格递增的最大上升子序列 第二问：对于每个数，二分查找可以插入的序列，找到以大于等于当前数结尾的最小值，在其后插入，其实就是更新其结尾值（更新后原来序列还是单调的，因为当前数小于等于后面的数，且大于前面的数）；对于查找不到的，一定会在当前所有序列末尾新增一个序列（查找不到意味着所有的数都小于当前数），该序列结尾值就是当前值。 关于维护当前的序列：我们每次操作都是查找能不能放，放不了就新开一个序列。放得了意味着，存在大于等于当前值的数，放不了意味着所有的数都小于当前数；我们每次把新开的都放在已有的序列后，这样就保证了我们可以维护一个单调递增的数组. #include #include using namespace std; const int N = 1e5 + 10; int a[N], q[N], f[N]; int main() { int n = 1; while (~scanf(\"%d\", a + n)) n ++; n --; int len = 0; q[0] = -1; for (int i = n; i; i -- ) { int l = 0, r = len; while (l > 1; if (q[mid] > a[i]) r = mid - 1; else l = mid; } len = max(len, r + 1); q[r + 1] = a[i]; } int cnt = 0; f[0] = -1; for (int i = 1; i > 1; if (f[mid] >= a[i]) r = mid; else l = mid + 1; } if (f[r] 导弹防御系统(dfs) DFS,迭代加深,剪枝,贪心 搜索顺序分为两个阶段： 从前往后枚举每颗导弹属于某个上升子序列，还是下降子序列； 如果属于上升子序列，则枚举属于哪个上升子序列（包括新开一个上升子序列）；如果属于下降子序列，可以类似处理。 Hard：俄罗斯套娃信封问题 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 注意：不允许旋转信封。 示例 1： 输入：envelopes = [ [5,4],[6,4],[6,7],[2,3] ] 输出：3 解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。 示例 2： 输入：envelopes = [ [1,1],[1,1],[1,1] ] 输出：1 提示： 1 class Solution { public: int maxEnvelopes(vector>& envelopes) { sort(envelopes.begin(), envelopes.end(), [](const vector& a, const vector& b){ return a[0] b[1]); }); // 太妙了 因为w相同时，h降序，则为了维护递增ans序列， 同一个w的只能选一个 int n = envelopes.size(); vector ans; ans.push_back(envelopes[0][1]); for(int i = 1; i ans.back()) ans.push_back(t); else{ *lower_bound(ans.begin(), ans.end(), t) = t; } } return ans.size(); } }; LCP-打地鼠 勇者面前有一个大小为 3*3 的打地鼠游戏机，地鼠将随机出现在各个位置，moles[i] = [t,x,y] 表示在第 t 秒会有地鼠出现在 (x,y) 位置上，并于第 t+1 秒该地鼠消失。 勇者有一把可敲打地鼠的锤子，初始时刻（即第 0 秒）锤子位于正中间的格子 (1,1)，锤子的使用规则如下： 锤子每经过 1 秒可以往上、下、左、右中的一个方向移动一格，也可以不移动 锤子只可敲击所在格子的地鼠，敲击不耗时 请返回勇者最多能够敲击多少只地鼠。 注意： 输入用例保证在相同时间相同位置最多仅有一只地鼠 示例 1： 输入： moles = [ [1,1,0],[2,0,1],[4,2,2] ] 输出： 2 解释： 第 0 秒，锤子位于 (1,1) 第 1 秒，锤子移动至 (1,0) 并敲击地鼠 第 2 秒，锤子移动至 (2,0) 第 3 秒，锤子移动至 (2,1) 第 4 秒，锤子移动至 (2,2) 并敲击地鼠 因此勇者最多可敲击 2 只地鼠 示例 2： 输入：moles = [ [2,0,2],[5,2,0],[4,1,0],[1,2,1],[3,0,2] ] 输出：3 解释： 第 0 秒，锤子位于 (1,1) 第 1 秒，锤子移动至 (2,1) 并敲击地鼠 第 2 秒，锤子移动至 (1,1) 第 3 秒，锤子移动至 (1,0) 第 4 秒，锤子在 (1,0) 不移动并敲击地鼠 第 5 秒，锤子移动至 (2,0) 并敲击地鼠 因此勇者最多可敲击 3 只地鼠 示例 3： 输入：moles = [ [0,1,0],[0,0,1] ] 输出：0 解释： 第 0 秒，锤子初始位于 (1,1)，此时并不能敲击 (1,0)、(0,1) 位置处的地鼠 提示： 1 状态机dp 构建状态： 每一个地鼠都可以选择打和不打，有两种状态； 那么我们可以维护dp[i][0]和dp[i][1]; dp[i][0]表示前i只地鼠里面，第i只地鼠不打的情况下可以获得的最大分数 dp[i][1]表示前i只地鼠里面，第i只地鼠打的情况下可以获得的最大分数 状态的转移： 为了方便转移，我们需要对地鼠的顺序按出现时间排序，因为我们不可能先打后来出现的地鼠再打前面出现的地鼠。 很明显：dp[i][0]=Max(dp[i-1][0],dp[i-1][1]);因为我们不打第i只，所以不需要考虑第i只能否到达； 假如j LIS dp[i] = max(dp[i], dp[j] + 1) where (0 地图是 3 x 3 ，最远距离是 (0, 0) 到 (2, 2) ，因此最多只需要 4 秒。此外，在「相同时间相同位置最多仅有一只地鼠」，因此在某一秒，地图最多有 9 只地鼠。 考虑足够大的 i，是否有必要扫描 [1, i) 整个区间？答案是否定的，我们只需要扫描区间 [i - 45, i) 这个区间，因为 [i - 45, i) 这一区间的 dp 值必然大于 [0, i - 45) 这一区间的值。 为什么是 i 之前的 45 个元素呢，因为与 cur = moles[i - 1] 同一时间出现的可能还有 8 只地鼠（这些可以不扫描，忽略之），我们需要考虑的其实是 cur 前 4 秒的 36 只地鼠（最坏的情况下）。 using vec_t = vector; class Solution { public: int getMaximumNumber(vector>& moles) { int n = moles.size(), res = 0; vec_t dp(n + 1, 0); sort(begin(moles), end(moles)); for (int i = 1; i 3 最长公共子序列 最长公共子序列 给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。 如果两个字符相等，就可以直接转移到f[i-1][j-1]，不相等的话，两个字符一定有一个可以抛弃，可以对f[i-1][j],f[i][j-1]两种状态取max来转移。 如果两个相等那么状态f[i][j]=f[i-1][j-1]+1这个好理解因为是在f[i-1][j-1]的前提上多了一组匹配成功的,如果两个不相等,又因为我们要找最大匹配数量所以每个状态一定存的是当前最多的匹配数量，那么如何转移呢？ 主要看f[i-1][j]和f[i][j-1]的比较，因为a[i]和b[j]一定不相等了,但a[i]或者b[j]可能在之前出现了和它们相等的数使得 他们配对成功,那么我们转移配对成功的就是当前f[i][j]的最大情况的转移了,当然也有可能a[i],b[j]在此之前都没有 成功配对，总之就是从两种状态中挑取最大的配对数进行状态转移 理解为四种情况a[i]和b[j] 1：相等 2：不相等，a[i]和bx匹配x在j之前 3：不相等，b[j]和ax匹配x在i之前 4：不相等，两数都没有匹配 f[i][j]=max(f[i-1][j],f[i][j-1])包含了2，3，4 转移过来的就是前面状态的最大值 #include using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { cin >> n >> m >> a + 1 >> b + 1; for (int i = 1; i 4 最长公共上升子序列 最长公共上升子序列 状态表示： f[i][j]代表所有a[1 ~ i]和b[1 ~ j]中以b[j]结尾的公共上升子序列的集合； f[i][j]的值等于该集合的子序列中长度的最大值； 状态计算（对应集合划分）： 首先依据公共子序列中是否包含a[i]，将f[i][j]所代表的集合划分成两个不重不漏的子集： 不包含a[i]的子集，最大值是f[i - 1][j]； 包含a[i]的子集，将这个子集继续划分，依据是子序列的倒数第二个元素在b[]中是哪个数： 子序列只包含b[j]一个数，长度是1； 子序列的倒数第二个数是b[1]的集合，最大长度是f[i - 1][1] + 1； … 子序列的倒数第二个数是b[j - 1]的集合，最大长度是f[i - 1][j - 1] + 1； 如果直接按上述思路实现，需要三重循环： for (int i = 1; i b[k]) maxv = max(maxv, f[i - 1][k] + 1); f[i][j] = max(f[i][j], maxv); } } } 然后我们发现每次循环求得的maxv是满足a[i] > b[k]的f[i - 1][k] + 1的前缀最大值。 因此可以直接将maxv提到第一层循环外面，减少重复计算，此时只剩下两重循环。 最终答案枚举子序列结尾取最大值即可。 时间复杂度 代码中一共两重循环，因此时间复杂度是 O(n2) C++ 代码 #include #include #include using namespace std; const int N = 3010; int n; int a[N], b[N]; int f[N][N]; int main() { scanf(\"%d\", &n); for (int i = 1; i b[j]) maxv = max(maxv, f[i - 1][j] + 1); } } int res = 0; for (int i = 1; i 5 编辑距离 PNC:相似性检测 最短编辑距离 给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有： 删除–将字符串 A 中的某个字符删除。 插入–在字符串 A 的某个位置插入某个字符。 替换–将字符串 A 中的某个字符替换为另一个字符。 现在请你求出，将 A 变为 B 至少需要进行多少次操作。 1.状态表示 ：f[i][j] 集合：将a[1~i]变成b[1~j]的操作方式 属性：min` 2.状态计算 ：从最后一步考虑 有三种操作，所以有三个子集 ok子集划分完了 考虑状态转移的时候 先考虑如果我没有进行这个操作应该是什么状态 然后考虑你进行这一步操作之后会对你下一个状态造成什么影响 然后再加上之前状态表示中你决策出来的那个DP属性 这样就可以自然而然地搞出来转移方程啦 1)删除操作：把a[i]删掉之后a[1~i]和b[1~j]匹配 所以之前要先做到a[1~(i-1)]和b[1~j]匹配 f[i-1][j] + 1 2)插入操作：插入之后a[i]与b[j]完全匹配，所以插入的就是b[j] 那填之前a[1~i]和b[1~(j-1)]匹配 f[i][j-1] + 1 3)替换操作：把a[i]改成b[j]之后想要a[1~i]与b[1~j]匹配 那么修改这一位之前，a[1~(i-1)]应该与b[1~(j-1)]匹配 f[i-1][j-1] + 1 但是如果本来a[i]与b[j]这一位上就相等，那么不用改，即 f[i-1][j-1] + 0 好的那么f[i][j]就由以上三个可能状态转移过来，取个min 细节问题：初始化怎么搞 先考虑有哪些初始化嘛 1.你看看在for遍历的时候需要用到的但是你事先没有的 （往往就是什么0啊1啊之类的）就要预处理 2.如果要找min的话别忘了INF 要找有负数的max的话别忘了-INF ok对应的： 1.f[0][i]如果a初始长度就是0，那么只能用插入操作让它变成b f[i][0]同样地，如果b的长度是0，那么a只能用删除操作让它变成b 2.f[i][j] = INF //虽说这里没有用到，但是把考虑到的边界都写上还是保险 #include #include using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { scanf(\"%d%s\", &n, a + 1); scanf(\"%d%s\", &m, b + 1); for (int i = 0; i 更简洁版本 #include #include using namespace std; int n1, n2; const int N = 1010; int dp[N][N]; // 至少比相应长度多开一个空间 int main() { string s1, s2; cin >> n1 >> s1; cin >> n2 >> s2; // 初始化技巧！！！ for(int i = 0; i 6 字符串组合问题 给定三个字符串A，B，C；判断C能否由AB中的字符组成，同时这个组合后的字符顺序必须是A，B中原来的顺序，不能逆序；例如：A：mnl，B：xyz；如果C为mnxylz，就符合题意；如果C为mxnzly，就不符合题意，原因是z与y顺序不是B中顺序。 DP求解：定义dp[i][j]表示A中前i个字符与B中前j个字符是否能组成C中的前(i+j)个字符，如果能标记true，如果不能标记false； 有了这个定义，我们就可以找出状态转移方程了，初始状态dp[0][0] = 1： dp[i][j] = 1 如果 dp[i-1][j] == 1 && C[i+j-1] == A[i-1] dp[i][j] = 1 如果 dp[i][j-1] == 1 && C[i+j-1] == B[j-1] #include #include using namespace std; char A[1001], B[1001], C[2001]; int dp[1001][1001]; // dp[i][j] 表示A前i个字符与B前j个字符是否能构成C前i+j个字符 int main() { memset(dp,0,sizeof dp); scanf(\"%s %s %s\", A, B, C); int lenA = strlen(A); int lenB = strlen(B); dp[0][0] = 1; for(int i = 0; i 0 && (dp[i-1][j] == 1) && (C[i+j-1] == A[i-1])) { dp[i][j] = 1; } if(j > 0 && (dp[i][j-1] == 1) && (C[i+j-1] == B[j-1])) { dp[i][j] = 1; } } } printf(\"%s\\n\",dp[lenA][lenB] ? \"yes\" : \"no\"); return 0; } 7 前缀DP Maximum Number of Points with Cost You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix. To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score. However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows r and r + 1 (where 0 = 0. -x for x eg. | 1 | 2 | 3 | |---|---|---| |1 | 5 | 1 | |3 | 1 | 1 | Input: points = [ [1,2,3],[1,5,1],[3,1,1] ] Output: 9 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0). You add 3 + 5 + 3 = 11 to your score. However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score. Your final score is 11 - 2 = 9. 解： 转移方程： f[i][j] = min{k}(f[i - 1][k] - abs(j - k) + p[i][j]); k j ( f[i - 1][k] - k ) + j + p[i][j] // 从上行的右侧转移而来 // 即分别维护左右侧的最大值 然后用于转移即可。 // 同样的进行拓展，如果加上条件，即只允许abs(i,j) class Solution { public: long long maxPoints(vector>& points) { int m = points.size(); int n = points[0].size(); vector f(n); for (int i = 0; i g(n); long long best = LLONG_MIN; // 正序遍历 ！！！从上行的左边转移而来 for (int j = 0; j = 0; --j) { best = max(best, f[j] - j); g[j] = max(g[j], best + points[i][j] + j); } f = move(g); // 节省了空间！！！ } return *max_element(f.begin(), f.end()); } }; 或者用二维数组滚动： class Solution { public: long long maxPoints(vector>& points) { int m = points.size(); int n = points[0].size(); long long f[2][n]; memset(f, 0, sizeof f); for(int i = 0; i = 0; --j) { best = max(best, f[(i - 1) & 1][j] - j); f[i & 1][j] = max(f[i & 1][j] , best + points[i][j] + j); } } long long res = LLONG_MIN; for(int i = 0; i 以及用线段树法，详情见原题提交记录。需要维护最大值，并用到懒标记。 8 最短路DP 规定时间内到达终点的最小花费 一个国家有 n 个城市，城市编号为 0 到 n - 1 ，题目保证 所有城市 都由双向道路 连接在一起 。道路由二维整数数组 edges 表示，其中 edges[i] = [xi, yi, timei] 表示城市 xi 和 yi 之间有一条双向道路，耗费时间为 timei 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。 每次经过一个城市时，你需要付通行费。通行费用一个长度为 n 且下标从 0 开始的整数数组 passingFees 表示，其中 passingFees[j] 是你经过城市 j 需要支付的费用。 一开始，你在城市 0 ，你想要在 maxTime 分钟以内 （包含 maxTime 分钟）到达城市 n - 1 。旅行的 费用 为你经过的所有城市 通行费之和 （包括 起点和终点城市的通行费）。 给你 maxTime，edges 和 passingFees ，请你返回完成旅行的 最小费用 ，如果无法在 maxTime 分钟以内完成旅行，请你返回 -1 。 \r ![](./assets/规定时间内到达终点的最小花费00.png)\r \r ![](./assets/规定时间内到达终点的最小花费01.png)\r \r \r **解：**\r \r ![](./assets/规定时间内到达终点的最小花费.png)\r \r \r ```c++ \r class Solution {\r static constexpr int INF = INT_MAX/2;\r public:\r int minCost(int maxTime, vector>& edges, vector& passingFees) {\r int n = passingFees.size();\r int ans= INF;\r vector> f(maxTime+1,vector(n,INF));\r //初始化\r f[0][0] = passingFees[0];\r for(int t =1;t给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。\r 字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。\r 例如，\"ace\" 是 \"abcde\" 的一个子序列，但 \"aec\" 不是。\r 示例 1：\r 输入：s = \"abc\"\r 输出：7\r 解释：7 个不同的子序列分别是 \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", 以及 \"abc\"。\r 示例 2：\r 输入：s = \"aba\"\r 输出：6\r 解释：6 个不同的子序列分别是 \"a\", \"b\", \"ab\", \"ba\", \"aa\" 以及 \"aba\"。\r 示例 3：\r 输入：s = \"aaa\"\r 输出：3\r 解释：3 个不同的子序列分别是 \"a\", \"aa\" 以及 \"aaa\"。\r 提示：\r 1 class Solution { public: int distinctSubseqII(string s) { vector dp(26); int mod = 1e9 + 7; for(auto c:s){ dp[c - 'a'] = accumulate(dp.begin(),dp.end(),1ll) % mod; } return accumulate(dp.begin(),dp.end(),0ll) % mod; } }; 2 背包DP Article:dd大牛的背包九讲-背包问题汇总 背包模型一般求解 最大值、最小值 方案数 具体方案： 最短路问题，即记录转移过程，不能再用状态压缩了？而且如果输出要求字典序最小的方案，则需要对i的遍历顺序变化！！？？ 初始化汇总： 背包问题中 体积至多是 j ，恰好是 j ，至少是 j 的初始化问题的研究 学背包问题的过程 1、一开始学背包问题时遇到的大多数的状态表示是：从前i个物品中选，且总体积不超过j的问题。 2、慢慢地在提高课中，就有出现状态表示是：从前i个物品中选，且总体积恰好是j的问题。例如 AcWing 1023. 买书 ，求的是恰好是j的总方案数问题。 3、同时还出现了状态表示是：从前i个物品中选，且总体积至少是j的问题。例如 AcWing 1020. 潜水员 ，求的是总体积至少是j的最小价值 可以观察到，他们的分析方法以及状态转移方程都是一样的，唯独是初始化有很大的不同 求方案数初始化总结 二维情况 1、体积至多j，f[0][i] = 1, 0 一维情况 1、体积至多j，f[i] = 1, 0 求最大值最小值初始化总结 二维情况 1、体积至多j，f[i,k] = 0，0 潜水员 一维情况 1、体积至多j，f[i] = 0, 0 总结 至多，恰好，至少 这三种状态转移方程都是一样的， 不同的是状态的定义域不同（前两者在负数上没有定义，后者有）和初始边界的不同了。 以后考虑dp问题不能计算状态方程对了，也要确定好状态的初始边界和定义域，一包万无一失。 01背包问题(滚动数组) 每个物品最多只能放一次。 完全背包问题(优化成二维,以及滚动数组) 每种物品可以放无限多次。(空间优化为1维后，只有完全背包是正序遍历) 多重背包问题(倍增优化NVlogS成01背包、单调队列优化) 每种物品有一个固定的次数上限。 混合三种背包问题 将前面三种简单的问题叠加成较复杂的问题。 二维费用的背包问题 一个简单的常见扩展。 分组的背包问题 每组里面只能选一种。后两节的基础。 有依赖的背包问题 另一种给物品的选取加上限制的方法。 泛化物品 我自己关于背包问题的思考成果，有一点抽象。 背包问题问法的变化 试图触类旁通、举一反三。 for 物品 i for 体积 j for 决策 k或s 1. 01背包问题 有N件物品和一个容量为V的背包。第i件物品的费用是v[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 f[i][j]=max{f[i-1][j],f[i-1][j-v[i]]+w[i]} “将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为f[i-1][j]；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为j-v[i]的背包中”，此时能获得的最大价值就是f[i-1][j-v[i]]再加上通过放入第i件物品获得的价值w[i]。 优化 以上时间和空间复杂度均为O(N*V) 可把空间优化为O(V) for i=1..N for j=V..0 // ！！！ f[j]=max{f[j],f[j-v[i]]+w[i]}; 说明： 其中的f[v]=max{f[v],f[v-c[i]]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]}，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 关于初始化： “恰好装满背包”时的最优解 要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞ 小于容量的最优解 初始化时应该将f[0..V]全部设为0 2. 完全背包问题 有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 通过 其中s为体积限制下该物品的最大数量。 即优化过程为： f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w , f[i-1,j-2*v]+2*w , f[i-1,j-3*v]+3*w , .....) f[i , j-v]= max( f[i-1,j-v] , f[i-1,j-2*v] + w , f[i-1,j-3*v]+2*w , .....) 由上两式，可得出如下递推关系： f[i][j]=max(f[i][j-v]+w , f[i-1][j]) 因此，可将 f[i][j]=max{f[i-1][j-k*v[i]]+k*w[i] | 0 for(int i = 1 ; i 对时间复杂度进行优化，为 f[i][j]=max{f[i-1][j], f[i][j-v[i]]+w[i]} //？？？不是f[i][j - v[i]] + w[i]?? 具体代码为： for(int i = 1 ; i =0) // 注意第二部分 ： f[i][j-v[i]] f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); } cout 滚动数组优化后代码为 f[j] = max(f[j], f[j-v[i]] + w[i]); 具体代码为： for(int i = 1 ; i 对比01背包： f[i][j]=max{f[i-1][j], f[i-1][j-v[i]]+w[i]} 具体代码为： for(int i = 1 ; i =0) // 注意第二部分 ： f[i-1][j-v[i]] f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]); } 优化后为...见上，需倒序v 综上： 滚动优化前 两者相差一点： f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]); //01背包 f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]); //完全背包问题 滚动优化后 两者代码相同: f[j] = max(f[j],f[j-v[i]]+w[i]); //01背包 倒序啊！ f[j] = max(f[j],f[j-v[i]]+w[i]); //完全背包问题 分组倍增优化 完全背包也能进行分组倍增优化，每种物品的最大数量为j/v[i],但优化后复杂度不如单调队列优化，所有暂不用该优化。此优化可用于多重背包问题中。见下文。 D:数位成本和为目标值的最大数字 给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数： 给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。 总成本必须恰好等于 target 。 添加的数位中没有数字 0 。 由于答案可能会很大，请你以字符串形式返回。 如果按照上述要求无法得到任何整数，请你返回 \"0\" 。 示例 1： 输入：cost = [4,3,2,5,6,7,2,5,5], target = 9 输出：\"7772\" 解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 \"7772\" 的代价为 23+ 31 = 9 。 \"977\" 也是满足要求的数字，但 \"7772\" 是较大的数字。 数字 成本 1 -> 4 2 -> 3 3 -> 2 4 -> 5 5 -> 6 6 -> 7 7 -> 2 8 -> 5 9 -> 5 示例 2： 输入：cost = [7,6,5,5,5,6,8,7,8], target = 12 输出：\"85\" 解释：添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。\"85\" 的成本为 7 + 5 = 12 。 示例 3： 输入：cost = [2,4,6,2,4,6,4,4,4], target = 5 输出：\"0\" 解释：总成本是 target 的条件下，无法生成任何整数。 示例 4： 输入：cost = [6,10,15,40,40,40,40,40,40], target = 47 输出：\"32211\" 提示： cost.length == 9 1 解： 比较经典的完全背包，需要注意几个点： ①因为i遍历的顺序是从小到大，就保证了整数的高位一定大于等于整数的低位，也就保证了整数最大； ②为了保证我们dp[j]中的数位的cost相加一定等于j，而没有小于j的情况，我们特地用字符串\"#\"来表示无法得到的目标值，这样我们在进行状态转移的时候，就不会进行不合法的转移； ③而为了得到我们的目标值，进行正确的状态转移，我们又需要把dp[0]初始化为“”,因为对于任何cost的值来说，加上0都是刚好花费cost得到的目标字符串，正好是合法的情况。 class Solution { public: string largestNumber(vector& cost, int target) { cost.insert(cost.begin(), 0); unordered_map cost_digit; for (int digit = 1; digit dp(target + 1, \"0\"); dp[0] = \"\"; for (int co = 1; co = 0 && dp[co - c] != \"0\") dp[co] = max_a_b(dp[co], dp[co - c] + to_string(d)); return dp[target]; } //---------------- 根据题意，返回大的字符串 ----------------------// string max_a_b(string a, string b) { if (a.size() > b.size()) return a; else if (b.size() > a.size()) return b; return max(a, b); } }; 3. 多重背包问题 方法： 暴力 转化成01背包 分组倍增优化 转化成01背包 最大长度的队列优化，即滑动窗口最大值，模型为单调队列(难) 分组倍增优化(二进制优化) 对于每种物品，均执行： 对于i种物品，最多用s个。此时把s拆分成logs组，1，2，4，...2^logs,每组选或不选，最终能凑成选择0~s个的任意值。将原始物品删除，用新的物品代替其体积和价值。转化为01背包。 将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。 分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出. 这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为O(V*Σlog n[i])的01背包问题. 未优化代码： for (int i = 1; i 优化过程： 对比 在完全背包中,通过两个状态转移方程： f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w , f[i-1,j-2v]+2w , f[i-1,j-3v]+3w, .....) f[i , j-v]= max( f[i-1,j-v] , f[i-1,j-2v] + w, f[i-1,j-2v]+2w , .....) 通过上述比较，可以得到 f[ i ][ j ] = max(f[ i - 1 ][ j ],f[ i ][ j - v ] + w)。 再来看下多重背包, f[i , j ] = max( f[i-1,j] ,f[i-1,j-v]+w ,f[i-1,j-2v]+2w ,..... f[i-1,j-Sv]+Sw, ) f[i , j-v]= max( f[i-1,j-v] ,f[i-1,j-2v]+w, ..... f[i-1,j-Sv]+(S-1)w, f[i-1,j-(S+1)v]+Sw ) 二进制优化，它为什么正确，为什么合理，凭什么可以这样分？？ 优化后代码： int cnt = 0; //分组的组别 for(int i = 1;i > a >> b >> s; int k = 1; // 组别里面的个数 while(k0) { cnt ++ ; v[cnt] = a*s; w[cnt] = b*s; } } n = cnt ; //枚举次数正式由个数变成组别数 //01背包一维优化 for(int i = 1;i = v[i];j --) f[j] = max(f[j],f[j-v[i]] + w[i]); 解析： 二进制优化，它为什么正确，为什么合理，凭什么可以这样分？？ 二进制优化，它为什么正确，为什么合理，凭什么可以这样分？？ 我们首先确认三点： （1）我们知道转化成01背包的基本思路就是：判断每件物品我是取了你好呢还是不取你好。 （2）我们知道任意一个实数可以由二进制数来表示，也就是2^0~2^k其中一项或几项的和。 （3）这里多重背包问的就是每件物品取多少件可以获得最大价值。 分析： 如果直接遍历转化为01背包问题，是每次都拿一个来问，取了好还是不取好。那么根据数据范围，这样的时间复杂度是O(n^3),也就是1e+9，这样是毫无疑问是会TLE的。 假如10个取7个好，那么在实际的遍历过程中在第7个以后经过状态转移方程其实已经是选择“不取”好了。现在，用二进制思想将其分堆，分成k+1个分别有2^k个的堆，然后拿这一堆一堆去问，我是取了好呢，还是不取好呢，经过dp选择之后，结果和拿一个一个来问的结果是完全一样的，因为dp选择的是最优结果，而根据第二点任意一个实数都可以用二进制来表示，如果最终选出来10个取7个是最优的在分堆的选择过程中分成了2^0=1,2^1=2,2^2=4,10 - 7 = 3 这四堆，然后去问四次，也就是拿去走dp状态转移方程，走的结果是第一堆1个，取了比不取好，第二堆2个，取了比不取好，第三堆四个，取了比不取好，第四堆8个，取了还不如不取，最后依旧是取了1+2+4=7个。 Tip:参考博客 如果仍然不是很能理解的话，取这样一个例子:要求在一堆苹果选出n个苹果。我们传统的思维是一个一个地去选，选够n个苹果就停止。这样选择的次数就是n次 二进制优化思维就是：现在给出一堆苹果和10个箱子，选出n个苹果。将这一堆苹果分别按照1,2,4,8,16,.....512分到10个箱子里，那么由于任何一个数字x ∈[1,1024] 都可以从这10个箱子里的苹果数量表示出来，但是这样选择的次数就是 ≤10次 。 这样利用二进制优化，时间复杂度就从O(n^3)降到O(n^2logS)。 单调队列优化 多重背包III 关键词： 单调队列、斜率优化 for (int i = 0; i > v >> w >> s; memcpy(g, f, sizeof f); for (int j = 0; j 多重背包问题 III 有 n(0 多重背包的原始状态转移方程 f(i,j)=max(f(i−1,j),f(i−1,j−v)+w,⋯,f(i−1,j−sv)+sw) 考虑用完全背包的优化方式来优化这个方程 f(i,j−v)=max(f(i−1,j−v),f(i−1,j−2v)+w,⋯,f(i−1,j−(s+1)v)+(s)w) 写出这个公式好像并不是那么管用 因为 完全背包 是一口气把所有体积全部用掉，即 max(a,b,c,d)=max(a,max(b,c,d)) 然而 多重背包 对于每个物品的个数是有限制的，导致我们最终的等式是如下样子： max(a,b,c,d)≠max(a,max(b,c,d,e)) 但是，我们可以把这个式子 继续 推导下去，直到背包体积被用到不能再用为止 其中 r=j mod vi ，也可以理解为 完全背包 下把当前物品 选到不能再选 后，剩下的 余数 得到 f(i,r)=f(i−1,r) 后，我们再利用 完全背包优化思路 往回倒推一遍 会惊奇的发现一个 滑动窗口求最大值 的模型，具体如下： 为了方便大家观察，我们把 f(i−1,j)改写成 fj 可能看上去还是有点复杂，为了再方便大家观察，我们去掉 ww，然后把数组展开成一条链 具体如下图： 于是通过该 滑动窗口 ，我们就能在 线性 的时间里求出 i 阶段里，所有满足 j≡rmod(v) 的 f(i,j) 滑动窗口 求 最大值 的实现，只需利用 队列 在队头维护一个 最大值 的 单调递减 的 单调队列 即可 为了更新所有 i 阶段里的状态 f(i,j) ，我们只需再额外枚举所有的 余数 rr 即可 不要忘记，滑动窗口内部比较最大值的时候，有一个在之前为了方便观察，被我删掉的偏移量 w 要记得加上再比较 具体就是 当前下标 和该 最大值的下标 之间差了 xx 个 vv，那么就要加上 xx 个 ww 在上面公式里，还是比较容易看出的吧，就不做额外的推导了。 详情见下文： Article:多重背包问题 III【单调队列优化+图示】 4. 混合背包 混合背包问题 5. 二维费用的背包问题 空间优化后同一维费用，每个费用均采取倒序方式。 6. 分组背包 有 N 组物品和一个容量是 V 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。 每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。si为第i组的物品种类数量。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 for (int i = 1; i = 0; j -- ) // 2 遍历 for (int k = 0; k 7. 有依赖的背包问题 金明的预算方案 一共有 N 个物品和 M 元钱 物品之间可能存在 依赖关系，对于第 i 个物品，价格为 vi，价值为 wi，依赖的父物品为 pi 每个物品只能被购买一次 依赖关系：只有购买了父物品后，才能购买子物品 （若 pi=0 表示该物品为 主件） 求一种 购买方案，使得 总花费 不超过 M，且 总价值 最大 解： 转化成分组背包。 #include #include #include #include #define v first #define w second using namespace std; typedef pair PII; const int N = 60, M = 32010; int n, m; PII master[N]; vector servent[N]; int f[M]; int main() { cin >> m >> n; for (int i = 1; i > v >> p >> q; p *= v; if (!q) master[i] = {v, p}; else servent[q].push_back({v, p}); } for (int i = 1; i = 0; u -- ) { for (int j = 0; j > k & 1) { v += servent[i][k].v; w += servent[i][k].w; } if (u >= v) f[u] = max(f[u], f[u - v] + w); } } cout 有依赖的背包问题 类似树形dp，用递归思路解决 有 N 个物品和一个容量是 V 的背包。 物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。 如下图所示： 如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。 每件物品的编号是 i，体积是 vi，价值是 wi，依赖的父节点编号是 pi。物品的下标范围是 1…N。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行有两个整数 N，V，用空格隔开，分别表示物品个数和背包容量。 接下来有 N 行数据，每行数据表示一个物品。 第 i 行有三个整数 vi,wi,pi，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。 如果 pi=−1，表示根节点。 数据保证所有物品构成一棵树。 输出格式 输出一个整数，表示最大价值。 数据范围 1≤N,V≤100 1≤vi,wi≤100 父节点编号范围： 内部结点：1≤pi≤N; 根节点 pi=−1; 输入样例 5 7 2 3 -1 2 2 1 3 5 1 4 7 2 3 6 2 输出样例： 11 解： Article：有依赖的背包问题【有依赖背包DP+子物品体积集合划分】 另：解： dfs在遍历到 x 结点时，先考虑一定选上根节点 x ，因此初始化 f[x][v[x] ~ m] = w[x] 在分组背包部分： j 的范围 [ m , v[x] ] 小于v[x]则没有意义因为连根结点都放不下； k 的范围 [ 0 , j-v[x] ]，当大于j-v[x]时分给该子树的容量过多，剩余的容量连根节点的物品都放不下了； #include #include #include using namespace std; const int N = 110; int n, m; int v[N], w[N]; int h[N], e[N], ne[N], idx; int f[N][N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs(int u) { for(int i = v[u]; i = v[u]; -- j){ //j的范围为v[x]~m, 小于v[x]无法选择以x为子树的物品 for(int k = 0; k = v[u]; -- j) f[u][j] = f[u][j - v[u]] + w[u]; // 防止重复。。。 //for(int j = 0; j > n >> m; memset(h, -1, sizeof h); int root; for(int i = 1; i > v[i] >> w[i] >> p; if(p == -1) root = i; else add(p, i); } dfs(root); cout 8. 背包方案数、输出方案 注意 恰好 和 不高于/不低于 等约束条件。 恰好 题目：机器分配 总公司拥有M台 相同 的高效设备，准备分给下属的N个分公司。 各分公司若获得这些设备，可以为国家提供一定的盈利。盈利与分配的设备数量有关。 问：如何分配这M台设备才能使国家得到的盈利最大？ 求出最大盈利值，并输出分配方案。 分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数M。 解：Article:机器分配【分组背包+背包DP输出方案dfs—拓扑图分析】 题目：整数划分 一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。 我们将这样的一种表示称为正整数 n 的一种划分。 现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。 输入格式 共一行，包含一个整数 n。 输出格式 共一行，包含一个整数，表示总划分数量。 由于答案可能很大，输出结果请对 109+7 取模。 数据范围 1≤n≤1000 输入样例: 5 输出样例： 7 #include #include using namespace std; const int N = 1010, mod = 1e9 + 7; int n; int f[N]; int main() { cin >> n; f[0] = 1; for (int i = 1; i 非恰好 背包问题求方案数 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 109+7 的结果。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式 输出一个整数，表示 方案数 模 109+7 的结果。 数据范围 0 题目：背包问题求具体方案 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N。 解：Article:背包问题求具体方案【01背包 + 背包DP输出方案】 倒序求解、正序求路径 #include using namespace std; const int N = 1010; int n, m; int w[N], v[N]; int f[N][N]; int path[N], cnt; int main() { cin >> n >> m; for (int i = 1; i > v[i] >> w[i]; for (int i = n; i >= 1; -- i) { for (int j = 0; j = v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]); } } for (int i = 1, j = m; i = v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i]) { path[cnt ++ ] = i; j -= v[i]; } } for (int i = 0; i 射箭比赛中的最大得分 01背包+dfs回溯 584 ms class Solution { int v[13], w[13], path[13]; int f[15][100010]; int cnt = 0; public: vector maximumBobPoints(int numArr, vector& aliceA) { int n = aliceA.size(); for(int i = 0; i ans; for(int i = 1; i = v[i]) ? w[i]: 0) == f[i][j]){ path[i] = a; dfs(i - 1, j - a); return ; } } } }; 二进制枚举DP 代码真是太简洁了 class Solution { public: vector maximumBobPoints(int numArrows, vector& aliceArrows) { int n = aliceArrows.size(); vector x(1 > j) & 1)) j += 1; x[i] = x[i ^ (1 cy) { cy = y[i]; ci = i; } } vector b(n); for (int i = 0; i > i) & 1) b[i] = aliceArrows[i] + 1; b[0] += numArrows - x[ci]; return b; } }; 二进制枚举胜利的位置 class Solution { public: vector maximumBobPoints(int numArrows, vector& aliceArrows) { int n = aliceArrows.size(); int maxs = 0; vector ans; for(int i = 0; i tt(n, 0); // temp int sum = 0, t = 0; for(int j = 0; j > j & 1){ sum += aliceArrows[j] + 1; t += j; tt[j] = aliceArrows[j] + 1; } } if(sum maxs){ maxs = t; tt[0] += (numArrows - sum); ans = tt; } } return ans; } }; 目标和 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \"+2-1\" 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 示例 2： 输入：nums = [1], target = 1 输出：1 提示： 1 解： 回溯 背包求方案数 class Solution { public: int findTargetSumWays(vector& nums, int target) { int sum = 0; for (int& num : nums) { sum += num; } int diff = sum - target; if (diff dp(neg + 1); dp[0] = 1; for (int& num : nums) { for (int j = neg; j >= num; j--) { dp[j] += dp[j - num]; } } return dp[neg]; } }; 9. 问题转化成背包问题 1.问题描述： 类似转化题：一篇文章吃透背包问题！（细致引入+解题模板+例题分析+代码呈现） 网易2017：双核处理问题（0-1背包问题 一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。 输入描述: 输入包括两行： 第一行为整数n(1 ≤ n ≤ 50) 第二行为n个整数lengthi，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。 输出描述： 输出一个整数，表示最少需要处理的时间。 输入例子: 53072 3072 7168 3072 1024 输出例子: 9216 解答 题目要求是总的时间最少，CPU1使用时间T1，CPU2使用时间T2，T1+T2 = T(数组元素的和处以1Kb) ， T是固定的。 任务完成时间为max(T1,T2)。所以题目可以转换为将任务分两组在两个CPU上并行运行，使两个CPU的使用时间相差最小。T1 和T2 越接近T/2差值越小，设T1 const int maxn = 4194304 / 1024 * 55 + 5; int dp[maxn], a[55]; int main() { int n; while(scanf(\"%d\", &n) == 1) { int sum = 0; for(int i = 1; i = a[i]; --j) { dp[j] = max(dp[j], dp[j - a[i]] + a[i]); } } printf(\"%d\\n\", max(dp[sum/2], sum-dp[sum/2])*1024); } 可参考最后一块石头的重量 II 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x 解： 转换成01背包问题，求两堆石头的最小差值。由于石头总和为sum.则问题转换成了 背包最多装sum / 2的石头,stones数组里有一大堆石头。求如何装能装下最多重量石头。 class Solution { public: int lastStoneWeightII(vector& stones) { int len = stones.size(); int sum = accumulate(stones.begin(), stones.end(), 0); int mid = sum / 2; vector dp(mid + 1); for(int i = 1; i = stones[i - 1] ; j --) { if(j >= stones[i - 1]) { dp[j] = max(dp[j], dp[j - stones[i - 1]] + stones[i - 1]); } } } return sum - 2 * dp[mid]; } }; [美团T4：cpu调度的负载均衡]小团从某市场买到了一块3核CPU来应对他需要进行的高性能计算任务。小团一共有n个计算任务，编号分别为1到n。编号为i的任务需要运行ai秒。为了避免进程切换带来的开销，小团只能同时运行三个任务。也就是说，他需要将这n个任务分成三组，并分别分配到CPU的三个核心上。 现在他想知道完所有任务至少需要多少秒。 输入：7 5 4 6 6 8 3 7 输出：13 转化成二维费用的背包 注意t的取值。 以下代码还不完全对，还存在问题 #include #include #include using namespace std; const int N = 110, M = 1000; int a[N]; int dp[M][M]; int main(){ int n; cin >> n; int sum = 0; for(int i = 0; i > a[i], sum += a[i]; int t = sum / 3; // cout = 0; -- j){ for(int k = t; k >= 0; -- k){ if(a[i] 华子机试：平分糖果并输出方案 n堆糖果，每堆ni个，平均分给两个人。若能平均则输出方案之一，否则输出-1. 1 01背包+方案回溯 类似问题： 分割等和子集 879. 盈利计划 集团里有 n 名员工，他们可以完成各种各样的工作创造利润。 第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。 工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。 有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。 示例 1： 输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3] 输出：2 解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。 总的来说，有两种计划。 示例 2： 输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8] 输出：7 解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。 有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。 提示： 1 class Solution { public: int profitableSchemes(int n, int minProfit, vector& group, vector& profit) { vector> dp(n + 1, vector(minProfit + 1)); for (int i = 0; i = members; j--) { for (int k = minProfit; k >= 0; k--) { dp[j][k] = (dp[j][k] + dp[j - members][max(0, k - earn)]) % MOD; } } } return dp[n][minProfit]; } }; 整数拆分 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。 示例 1: 输入: n = 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 输入: n = 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 完全背包 物品：k个数 背包：和为n 背包质量：最大乘积 由于求乘积的最大值，因此k只需要为n/2+1,多于n/2+1后乘积会变小. 定义dp[i][j],表示由i个数组成和为j时，i个数的乘积最大 由于需要遍历每个2-n的每个值，因此将背包循环放大物品循环之前 由此可得转移方程为 dp[i][j]=max(dp[i-1][j],dp[i][j-i]*i); dp[i][j-i]*i表示第i个数放入背包多次，具体推导 dp[i][j]=max(dp[i-1][j],dp[i-1][j-i]*i,dp[i-1][j-2*i]*i^2,...,dp[i-1][j-k*i]*i^k,...); ... 将j-i带入上式， dp[i][j-i]=max(dp[i-1][j-i],dp[i-1][j-2*i]*i^2,...,dp[i-1][j-k*i]*i^(k-1),...); 因此， dp[i][j]=max(dp[i-1][j],dp[i][j-i]*i); 初始条件： i=2时,乘积的最大值为(j/2)*(j-j/2); class Solution { public: int integerBreak(int n) { vector> dp(n/2+2,vector(n+1,1)); if(n==3) return 2; for(int j=2;j O(n)的动态规划见官方解答 class Solution { public: int integerBreak(int n) { if (n dp(n + 1); dp[2] = 1; for (int i = 3; i 数学O(1) class Solution { public: int integerBreak(int n) { if (n 4) { ans *= 3; n -= 3; } return ans * n; } }; 目标和 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \"+2-1\" 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 示例 2： 输入：nums = [1], target = 1 输出：1 提示： 1 解： 1.dfs 2.dp 数据量小， 可dfs class Solution { int res; public: int findTargetSumWays(vector& nums, int target) { res=0; int n=nums.size(); dfs(nums,0,0,target); return res; } void dfs(vector& nums,int st,int sum,int target){ if(st==nums.size()&&sum==target){ res+=1; return; }else if(st==nums.size()){ return ; } dfs(nums,st+1,sum+nums[st],target); dfs(nums,st+1,sum-nums[st],target); } }; 问题转化 class Solution { public: int findTargetSumWays(vector& nums, int target) { int sum = 0; for (int& num : nums) { sum += num; } int diff = sum - target; if (diff > dp(n + 1, vector(neg + 1)); dp[0][0] = 1; for (int i = 1; i = num) { dp[i][j] += dp[i - 1][j - num]; } } } return dp[n][neg]; } }; 最接近目标价格的甜点成本 你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则： 必须选择 一种 冰激凌基料。 可以添加 一种或多种 配料，也可以不添加任何配料。 每种类型的配料 最多两份 。 给你以下三个输入： baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。 toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。 target ，一个整数，表示你制作甜点的目标价格。 你希望自己做的甜点总成本尽可能接近目标价格 target 。 返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。 示例 1： 输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10 输出：10 解释：考虑下面的方案组合（所有下标均从 0 开始）： 选择 1 号基料：成本 7 选择 1 份 0 号配料：成本 1 x 3 = 3 选择 0 份 1 号配料：成本 0 x 4 = 0 总成本：7 + 3 + 0 = 10 。 示例 2： 输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18 输出：17 解释：考虑下面的方案组合（所有下标均从 0 开始）： 选择 1 号基料：成本 3 选择 1 份 0 号配料：成本 1 x 4 = 4 选择 2 份 1 号配料：成本 2 x 5 = 10 选择 0 份 2 号配料：成本 0 x 100 = 0 总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。 示例 3： 输入：baseCosts = [3,10], toppingCosts = [2,5], target = 9 输出：8 解释：可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。 示例 4： 输入：baseCosts = [10], toppingCosts = [1], target = 1 输出：10 解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。 提示： n == baseCosts.length m == toppingCosts.length 1 解： 1.回溯 class Solution { public: int res=INT_MAX; int tar; int closestCost(vector& baseCosts, vector& toppingCosts, int target) { tar=target; for(auto base:baseCosts){ backtrack(0,base,toppingCosts); } return res; } void backtrack(int cur,int sum,vector & toppingCosts){ if(abs(sum-tar)tar || cur==toppingCosts.size()) return ; backtrack(cur+1,sum,toppingCosts); backtrack(cur+1,sum+toppingCosts[cur],toppingCosts); backtrack(cur+1,sum+2*toppingCosts[cur],toppingCosts); } }; 2.dfs+二分 见原题 3.背包 dp 转成01背包 两种写法：1.普通写法 2.bitset版本 1.普通版本 class Solution { public: int closestCost(vector& baseCosts, vector& toppingCosts, int target) { vector can(20001); for (int base : baseCosts) can[base] = true; toppingCosts.insert(toppingCosts.end(), toppingCosts.begin(), toppingCosts.end()); for (int topping : toppingCosts) { for (int i = 20000; i >= topping; --i) can[i] = can[i] || can[i - topping]; } int min_gap = INT_MAX, ans = 0; for (int i = 1; i 2. class Solution { public: int closestCost(vector& baseCosts, vector& toppingCosts, int target) { bitset f; for(auto x:baseCosts)f[x]=1; for(auto x:toppingCosts)f|=(f 3 状态机DP 1 大盗模型 线性 环形 树形 2 股票模型 无限制 给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 解： DP法 for (int i = 1; i 贪心即可 Article:股票买卖 II DP + 贪心 双解 （附贪心证明） #include using namespace std; const int N = 1e5 + 10, INF = 0x3f3f3f3f; int n; int w[N]; int main() { scanf(\"%d\", &n); for (int i = 1; i 0) res += w[i] - w[i - 1]; } printf(\"%d\\n\", res); return 0; } 有交易次数限制 2 次 买卖股票的最佳时机 III 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4： 输入：prices = [1] 输出：0 提示： 1 解： class Solution { public: int maxProfit(vector& prices) { // 因为只能交易 2 次，所以定义 2 组 buy 和 sell int fstbuy = INT_MIN, fstsell = 0; int secbuy = INT_MIN, secsell = 0; for (auto& p : prices){ fstbuy = max(fstbuy, -p); // 第一次买 -p fstsell = max(fstsell, fstbuy + p); // 第一次卖 fstbut + p secbuy = max(secbuy, fstsell - p); // 第一次卖了后现在买 fstsell - p secsell = max(secsell, secbuy + p); // 第二次买了后现在卖 secbuy + p } return secsell; } }; k次 给定一个长度为 N 的数组 w，数组的第 i 个元素 wi 表示第 i 天的股票 价格 一次买入一次卖出为一笔 合法的完整交易，且不能同时产生多笔交易（必须在再次购买前出售掉之前的股票） 设计一个方案，使得总 合法交易数 不超过 k 次，总利润最大 解： for (int i = 1; i > w[i]; memset(f, -0x3f, sizeof f); f[0][0][0] = 0; //初始状态f[0][0][0] for (int i = 1; i 循环数组版： for(int i = 1;i > a[i]; memset(f, -0x3f, sizeof f); f[0][0][0] = 0; for(int i = 1; i 有冷冻期 给定一个长度为 N 的数组 w，数组的第 i 个元素 wi 表示第 i 天的股票 价格 一次买入一次卖出为一笔 合法的交易，且不能同时产生多笔交易（必须在再次购买前出售掉之前的股票） 卖出股票后，无法在第二天买入股票（冷冻期为1天） 设计一个方案，使得总利润最大 解： 状态定义 1.可以定义两种状态 转移时注意冷冻期 最佳买卖股票时机含冷冻期 class Solution { public: int maxProfit(vector& prices) { vector> dp(prices.size(),vector(2,0)); dp[0][0]=0; dp[0][1]=-prices[0]; for(int i=1;i=2) dp[i][1]=max(dp[i-2][0]-prices[i],dp[i-1][1]); else dp[i][1]=max(dp[i-1][0]-prices[i],dp[i-1][1]); } return dp.back()[0]; } }; 2.定义三种状态 (按照定义：冷冻期 不能向 冷冻期转移) 初值设定： // f全局变量 为0，对第一天进行初始化 for(int i = 1; i > a[i]; f[1][0] = 0, f[1][1] = - a[1], f[1][2] = 0; for(int i = 2; i 或者 memset(f, -0x3f, sizeof f); f[0][0] = 0; // 对f[0][0] 初始化 第0天只可能是没有，其他方案为负，则阻止了进一步转移。 for (int i = 1; i 滚动数组 两种方式 用一维数组f，以及局部一维g,用完f = move(g) 用二维数组f, 不同阶段分别为f[i & 1][],f[(i - 1) & 1][] for(int i = 1; i > a[i]; memset(f, -0x3f, sizeof f); f[0][0] = 0; for(int i = 1; i 有手续费 买卖股票的最佳时机含手续费 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1： 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润:在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 示例 2： 输入：prices = [1,3,7,5,10,3], fee = 3 输出：6 提示： 1 104 1 104 0 解： 1.dp 滚动优化后： class Solution { public: int maxProfit(vector& prices, int fee) { int m=prices.size(); int dp0 = 0, dp1 = -prices[0]; for(int i=1;i 2.贪心 class Solution { public: int maxProfit(vector& prices, int fee) { //将手续费放在买入时进行计算 int n = prices.size(); int buy = prices[0] + fee; int profit = 0; for (int i = 1; i buy) { profit += prices[i] - buy; buy = prices[i]; } } return profit; } }; 3 不知道什么模型 jd：漂亮串 漂亮串：至少有两个\"red\"子串，例如 “redred\",而\"reedred\" 不是。 求长度为n，仅包含小写字母的字符串中，共有多少种不同的漂亮串？？？ 类似Falfa with Substring 或2022 牛客多校 第二场 E - Falfa with Substring 思路 1.枚举第一个red出现的位置，1-n，然后左半边是一个red都不出现的方案数 ，右半边是至少出现一个red的方案数，ans=Σ(26^(i-1)-dp[i-1])(dp[n-i-2]) i属于[1,n-5] 已经A了 dp数组的维护就是dp[i]=dp[i-1]26+(26^(i-3)-dp[i-3]) 就是考虑dp[i]比dp[i-1]多了哪些情况，思路已经很完整了，你照着写应该就能过了。 记录两个数组dp1，dp2，dp1[k]表示用k个字母至少出现一次red的串个数，dp2[k]表示用k个字母至少出现2次red的个数，最终答案就是dp2[n]。dp1，dp2更新想法是类似的，以dp1为例，考虑dp1[k]，red可出现在前k-1位，那么就是26dp1[k-1]，red也可以出现在最后三位，那么就是26^(k-3)，但是这两者加起来会有重复计算，需要减去dp1[k-3]，所以dp1转移方程为dp1[k] = dp1[k-1] 26 + 26^(k-3) - dp1[k-3]，同理，dp2转移方程为dp2[k] = dp2[k-1] * 26 + dp1[k-3] - dp2[k-3] 3.FFP +　容斥 代码 #include #include using ll = long long; const ll mod = 1e9+7; const int maxn = 1e6+7; ll dp[maxn][4][2]; int main(int argc, char *argv[]) { int n; std::cin >> n; ll ans = 1; for (int i = 0; i long result = dfs(n, 2, 0); System.out.println(result); static long max = 1000000007; static long[][][] record; public static long dfs(int n, int count, int pre) {//count 表示 red数量 ； pre表示red前缀有几个。 if (record[n][count][pre] != 0) { return record[n][count][pre]; } if (n == 0) { return count == 0 ? 1 : 0; } n--; long ans = 0; if (pre == 0) { ans += dfs(n, count, 0) * 25 + dfs(n, count, 1); } else if (pre == 1) { ans += dfs(n, count, 2) + dfs(n, count, 1) + dfs(n, count, 0) * 24; } else if (pre == 2) { if (count == 0) { ans += dfs(n, count, 1) + dfs(n, count, 0) * 25; } else { ans += dfs(n, count - 1, 0) + dfs(n, count, 1) + dfs(n, count, 0) * 24; } } ans %= max; record[n + 1][count][pre] = ans; return ans; } } t3考虑容斥，代码如下： mod = 10 ** 9 + 7 N = 2 * 10 ** 6 + 10 fac = [1] * N for i in range(2, N): fac[i] = fac[i - 1] * i % mod invfac = [1] * N invfac[N - 1] = pow(fac[N - 1], mod - 2, mod) for i in range(N - 1)[::-1]: invfac[i] = invfac[i + 1] * (i + 1) % mod def c(i, j): return fac[i] * invfac[j] * invfac[i - j] % mod n = 1000000 ans = 0 mx = n // 3 for i in range(2, mx + 1): if i % 2 == 0: ans += (i - 1) * c(i + n - 3 * i, i) * pow(26, n - 3 * i, mod) % mod else: ans -= (i - 1) * c(i + n - 3 * i, i) * pow(26, n - 3 * i, mod) % mod ans %= mod print(ans) def findCount(n): MOD = 10 ** 9 + 7 dp = [0 for i in range(7)] # 0red + xxx, 0red + xxr, 0red + xre, 1red + xxx, 1red + xxr, 1red + xre, 2red dp[0] = 1 for i in range(1, n + 1): new = [0 for i in range(7)] new[0] = dp[0] * 25 + dp[1] * 24 + dp[2] * 24 new[1] = dp[0] + dp[1] + dp[2] new[2] = dp[1] new[3] = dp[2] + dp[3] * 25 + dp[4] * 24 + dp[5] * 24 new[4] = dp[3] + dp[4] + dp[5] new[5] = dp[4] new[6] = dp[5] + dp[6] * 26 dp = new return dp[-1] % MOD # Python 没有数字大小限制 4 自动机DP 设计密码 题目 你现在需要设计一个密码 S，S 需要满足： S 的长度是 N； S 只包含小写英文字母； S 不包含子串 T； 例如：abc 和 abcde 是 abcde 的子串，abd 不是 abcde 的子串。 请问共有多少种不同的密码满足要求？ 由于答案会非常大，请输出答案模 109+7 的余数。 说人话： 修复DNA 有限字符集 为 {A,G,C,T} 题目给定 nn 个 模式串 Ti(1≤i≤n) 和 一个 主串 SS 每次可以修改 主串 中的一个字符 S[i] 要求进行最少次 修改操作，使得 主串S 中不存在 模式串 Ti(1≤i≤n) 的子串 求出该 操作次数 ，如果不行，输出 −1 5 状压DP 动态规划状态转移的两种理解方式： 我们遍历到现在这个状态时，一般往回看前一个状态，怎么到现如今的状态，其实也有另一种理解方式 我们到现在这个状态时，根据已知条件推断如何达到下一个状态，给下一个状态直接定义。 见二进制部分中的哈密顿路径 1 集合模型 D-数组的最大与和 给你一个长度为 n 的整数数组 nums 和一个整数 numSlots ，满足2 numSlots >= n 。总共有 numSlots 个篮子，编号为 1 到 numSlots 。 你需要把所有 n 个整数分到这些篮子中，且每个篮子 至多 有 2 个整数。一种分配方案的 与和 定义为每个数与它所在篮子编号的 按位与运算 结果之和。 比方说，将数字 [1, 3] 放入篮子 1 中，[4, 6] 放入篮子 2 中，这个方案的与和为 (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4 。 请你返回将 nums 中所有数放入 numSlots 个篮子中的最大与和。 示例 1： 输入：nums = [1,2,3,4,5,6], numSlots = 3 输出：9 解释：一个可行的方案是 [1, 4] 放入篮子 1 中，[2, 6] 放入篮子 2 中，[3, 5] 放入篮子 3 中。 最大与和为 (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9 。 示例 2： 输入：nums = [1,3,10,4,7,1], numSlots = 9 输出：24 解释：一个可行的方案是 [1, 1] 放入篮子 1 中，[3] 放入篮子 3 中，[4] 放入篮子 4 中，[7] 放入篮子 7 中，[10] 放入篮子 9 中。 最大与和为 (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。 注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。 提示： n == nums.length 1 numSlots 1 解： 提供六种解法 状态DP 三进制 最小费用最大流 模拟退火 贪心 KM 分别为： 状态DP 提示 1 转换一下：视作有 2⋅numSlots 个篮子，每个篮子至多可以放 1 个整数。 提示 2 数据范围很小，考虑状压 DP。 提示 3 以谁作为状态定义的对象呢？注意篮子编号是不能变的，而 nums 中元素的位置信息是不重要的。 class Solution { public: int maximumANDSum(vector &nums, int numSlots) { int ans = 0; vector f(1 = nums.size()) continue; for (int j = 0; j 三进制 提示1： 首先看到 numSlots≤9，可以考虑状态压缩。 提示2： 每个篮子最多放 2 个整数，那么，每个篮子最多有 3 种状态（0 个数，1 个数，2 个数）。那么，我们最多需要一个 9 位 三进制数， 就可以保存所有篮子的状态。 class Solution { public: int maximumANDSum(vector& nums, int s) { int n = nums.size(), M = 1; for(int i = 0; i 注意到，实际上 i 是可以由 mask 推出来的，设 mask 所表示的状态中共放入了 cnt 个整数，那么 i=n−1−cnt。 时间复杂度：O(m×3^m) class Solution { public: int maximumANDSum(vector& nums, int s) { int n = nums.size(), M = 1; for(int i = 0; i = 0) { for(int k = 1, t = j, w = 1; k 最小费用最大流 模拟退火 class Solution { public: int maximumANDSum(vector& nums, int numSlots) { int n = numSlots > 1) + 1); return sum;}; auto SA = [&]{ random_shuffle(begin(nums), end(nums)); int ret = check(); for(double T = 1e5; T > 1e-5; T *= 0.98){ int dOld = check(), i = rand() % n, j = rand() % n; swap(nums[i], nums[j]); int dNew = check(), dec = dOld - dNew; if (dec 退火 + 贪心 // KM class Solution { // 建图 void buildGraph(vector>& edges, vector& nums, int numSlots) { int n = nums.size(); edges = vector>(n,vector(2*numSlots)); for(int i=0; i>& edges) { int n = edges.size(), m = edges[0].size(); // 二分图两边的点数 vector match(m, -1); // match[i]为teacher[i]匹配的student编号 vector exNumber(n); // number期望 vector exSlot(m, 0); // slot的期望 for (int i = 0; i visNumber(n, false); vector visSlot(m, false); if (dfs(i, m, edges, match, visNumber, visSlot, exNumber, exSlot)) break; // 无法匹配降低期望 for (int j = 0; j >& edges, vector& match, vector& visNumber, vector& visSlot, vector& exNumber, vector& exSlot) { visNumber[i] = true; for (int j = 0; j & nums, int numSlots) { /* * 问题抽象为 “n个数字 - 2*numSlots个篮子” 的二分图最大匹配问题 ** 二分图中的点： *** n个数字：nums中需要被分配的n个数字 *** 2*numSlots个篮子：每个篮子最多可以放两个数字 ** 二分图中的边： *** 每个数字和每个篮子间都有一条边，边权为数字与篮子编号的 按位与运算 结果，表示把该数字放到该篮子时可获得的权值 */ // 建图（用n*2numSlots的邻接矩阵表示图。因为后续算法中只需要考虑边权而不需要考虑点权，故只需保存边权信息。） vector> edges; buildGraph(edges,nums,numSlots); // 计算（使用KM算法，计算最优匹配方案权值和） return KM(edges); } }; KM 板子 template class HungarianAlgorithm { // km public: int n; COST cost_fuc; std::vector matchx; // 左集合对应的匹配点 std::vector matchy; // 右集合对应的匹配点 std::vector pre; // 连接右集合的左点 std::vector visx; // 拜访数组 左 std::vector visy; // 拜访数组 右 std::vector lx; std::vector ly; std::vector slack; T inf; T res; std::queue q; int org_n; int org_m; HungarianAlgorithm(int _n, COST fuc, T baseValueType = int64_t(0)) :cost_fuc(fuc){ org_n = org_m = n = _n; inf = std::numeric_limits::max(); res = baseValueType; matchx = std::vector(n, -1); matchy = std::vector(n, -1); pre = std::vector(n); visx = std::vector(n); visy = std::vector(n); lx = std::vector(n, -inf); ly = std::vector(n); slack = std::vector(n); solve(); } bool check(int v) { visy[v] = true; if (matchy[v] != -1) { q.push(matchy[v]); visx[matchy[v]] = true; // in S return false; } // 找到新的未匹配点 更新匹配点 pre 数组记录着\"非匹配边\"上与之相连的点 while (v != -1) { matchy[v] = pre[v]; swap(v, matchx[pre[v]]); } return true; } void bfs(int i) { while (!q.empty()) { q.pop(); } q.push(i); visx[i] = true; while (true) { while (!q.empty()) { int u = q.front(); q.pop(); for (int v = 0; v = delta) { pre[v] = u; if (delta) { slack[v] = delta; } else if (check(v)) { // delta=0 代表有机会加入相等子图 找增广路 // 找到就return 重建交错树 return; } } } } } // 没有增广路 修改顶标 T a = inf; for (int j = 0; j 0) { res += g; } else { matchx[i] = -1; } } } T getR() { return res; } int getMatch(int idx, int SourseX = true) { return SourseX ? matchx[idx] : matchy[idx]; } }; template using __km = HungarianAlgorithm; class Solution { public: int maximumANDSum(vector& nums, int numSlots) { int n = numSlots > 1) + 1); }; HungarianAlgorithm km(n, cost, 0LL); return km.getR(); } }; D-两个数组最小的异或值之和 给你两个整数数组 nums1 和 nums2 ，它们长度都为 n 。 两个数组的 异或值之和 为 (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) （下标从 0 开始）。 比方说，[1,2,3] 和 [3,2,1] 的 异或值之和 等于 (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4 。 请你将 nums2 中的元素重新排列，使得 异或值之和 最小 。 请你返回重新排列之后的 异或值之和 。 示例 1： 输入：nums1 = [1,2], nums2 = [2,3] 输出：2 解释：将 nums2 重新排列得到 [3,2] 。 异或值之和为 (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2 。 示例 2： 输入：nums1 = [1,0,3], nums2 = [5,3,4] 输出：8 解释：将 nums2 重新排列得到 [5,4,3] 。 异或值之和为 (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8 。 提示： n == nums1.length n == nums2.length 1 解： 三种方法 1.普通dp 2.状压dp 3.模拟退火 4.KM算法求二分图的最小权匹配 普通DP const int N = 15; int dp[N][1& nums1, vector& nums2) { int n = nums1.size(); for (int i = 0; i > k) & 1) == 0) { // 第k个还未匹配 ，则可与第i个进行匹配 dp[i+1][j^(1 状压DP class Solution { public: int minimumXORSum(vector& nums1, vector& nums2) { int n = nums1.size(); vector f(1 模拟退火 class Solution { public: vector nums1, nums2; int n; int ans = INT_MAX; int energy() { int res = 0; for(int i = 0; i 1e-5; t *= 0.99) { int a = rand() % n, b = rand() % n; int ea = energy(); swap(nums2[a], nums2[b]); int eb = energy(); int dt = eb - ea; if(dt (double)rand() / RAND_MAX) continue; //恶化了，恶化的越大，越要回去 swap(nums2[a], nums2[b]); } } int minimumXORSum(vector& _nums1, vector& _nums2) { nums1 = _nums1; nums2 = _nums2; n = nums2.size(); for(int i = 0; i KM算法??? 求二分图的最小权匹配，将nums1和nums2中的每个元素之间都建边，边值为两者异或结果的相反数，然后跑KM算法求二分图的最大权匹配即可。 (最快????) class Solution { public: vector > wei; int n; vector visx, visy, linky, lx, ly; int xnum, ynum; int findPath(int now){ visx[now] = 1; for(int i=0;i (ynum,-1); ly = vector (ynum,0); lx = vector (xnum,-0x3f3f3f3f); for(int i=0;i (xnum,0); visy = vector (ynum,0); if(findPath(i)) break; int d = 0x3f3f3f3f ; for(int j=0;j -1) ans += -wei[linky[i]][i]; } return ans; } int minimumXORSum(vector& nums1, vector& nums2) { n = nums1.size(); xnum = n,ynum = n; wei = vector > (n,vector (n,0)); for(int i=0;i 2 棋盘模型 二进制 总结： 小国王 集合：f[i][j][k] 考虑前i层，共放置了 j个，且第i层是k的方案。 属性：方案的总数 sum 状态计算： f[i][j][k] = 玉米田 集合： 属性： 状态计算： 炮兵阵地 集合：f[i][j][k] 考虑前i层，且第i层状态为j,第i - 1 层状态是 k的方案。 属性：该方案能够放置棋子的最大个数 sum 状态计算：f[i][j][k] = max(f[i - 1][k][pre] + cntj) 其中pre是枚举的能够与k和j合法存在于三行中的所有状态 技巧： 预处理 符合单行摆放的状态 两行间进行转移的状态 以及某状态的摆放的数量 (如需要) 滚动数组 由于状态量较大，如炮兵，两个维度都是状态，如果再加一个状态，会MLE 原图的存储 玉米田 和 炮兵，对于不能放置的位置，该行的state的第j位设为1。 摆放的时候 用 if(!(g[i] & st)) 判断该行若摆放 st 是否可行。 以及答案获取的快速处理 状态定义： 小国王 在 n×n 的棋盘上放 k 个国王，国王可攻击相邻的 8 个格子，求使它们无法互相攻击的方案总数。 输入格式 共一行，包含两个整数 n 和 k。 输出格式 共一行，表示方案总数，若不能够放置则输出0。 数据范围 1≤n≤10, 0≤k≤n2 输入样例： 3 2 输出样例： 16 线性状压DP+滚动数组优化+目标状态优化 合法的棋盘状态 如上图所示，绿色方块为摆放国王的位置，红色方块为王的 攻击范围 只要任意王之间只要 不相邻，就是 合法的状态 合法的棋盘转移状态 如上图所示，绿色方块为摆放国王的位置，红色方块为王的 攻击范围 只要任意王的 纵坐标不相邻，就是 合法的转移状态 我们可以用 二进制 来表示当前的状态 // 略 const int N = 11, M = N * N; int n, m, k; long long f[N][M][1 ls; // legal state vector st[1 > 1); } int count(int state){ int res = 0; for(int i = 0; i > i & 1; return res; } int main() { cin >> n >> k; for(int i = 0; i = 0) f[i][j][cs] += f[i - 1][j - cnt[cs]][ts]; } } } } long long res = 0; for(auto state:ls) res += f[n][k][state]; cout // 把N设大一个值 //动态规划 f[0][0][0] = 1; for (int i = 1; i = 0) f[i][j][state] += f[i - 1][j - cnt[state]][pre_st]; //统计目标状态的所有方案数 cout 数组滚动优化： #include int main() { f[0][0][0] = 1; for (int i = 1; i = 0) f[i & 1][j][state] += f[(i - 1) & 1][j - cnt[state]][pre_st]; } LL res = 0; for (auto state: legal_state) res += f[n & 1][K][state]; cout 玉米田 农夫约翰的土地由 M×N 个小方格组成，现在他要在土地里种植玉米。 非常遗憾，部分土地是不育的，无法种植。 而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。 现在给定土地的大小，请你求出共有多少种种植方法。 土地上什么都不种也算一种方法。 输入格式 第 1 行包含两个整数 M 和 N。 第 2..M+1 行：每行包含 N 个整数 0 或 1，用来描述整个土地的状况，1 表示该块土地肥沃，0 表示该块土地不育。 输出格式 输出总种植方法对 108 取模后的值。 数据范围 1≤M,N≤12 输入样例： 2 3 1 1 1 0 1 0 输出样例： 9 解： 本题需要额外处理的，是给定的 01 矩阵里存在着的不能放置棋子的位置 我们用二进制存储的状态 state 中，使用 1 表示在该位置放置棋子，0 表示在该位置没有棋子 因此我们可以把矩阵每一层的状态也用二进制来压缩存储，且用 0 表示该位置能放棋子，1 表示不能放(与输入相反) 这样，只需把枚举的状态 state_cur 与这一层的状态 state_gi 做 & 运算 结果为0，表示 放置棋子 的位置没有与 不能放置棋子 的位置重叠，则该状态 合法 结果为1，表示 放置棋子 的位置与 不能放置棋子 的位置发生重叠，则该状态 不合法 具体如下图所示： const int N = 14, M = 1 ls; // legal state vector head[M]; bool check(int ls) { return !(ls & ls > n >> m; for (int i = 1; i > k, g[i] |= !k 滚动数组优化： f[0][0] = 1; for (int i = 1; i 炮兵阵地 给定一个 N×M 矩阵，矩阵中标有 H 字样的位置 不能 放置棋子，标有 P 字样的位置 可以 放置棋子 棋子的 攻击方向 为 上、下、左、右 四个方向， 攻击距离 为 2个格子 现在在该棋盘上放置棋子，使得棋子之前 不能被互相攻击 到，能够放置棋子的 最大个数 输入格式 第一行包含两个由空格分割开的正整数，分别表示 N 和 M； 接下来的 N 行，每一行含有连续的 M 个字符(P 或者 H)，中间没有空格。按顺序表示地图中每一行的数据。 输出格式 仅一行，包含一个整数 K，表示最多能摆放的炮兵部队的数量。 数据范围 N≤100,M≤10 输入样例： 5 4 PHPP PPHH PPPP PHPP PHHP 输出样例： 6 解： 在前两题里，我们只需压缩存储 当前层的状态 ，然后枚举 合法的上个阶段 的状态进行 转移 即可 但是本题的棋子攻击范围是 2，我们只压缩当前层一层状态后进行转移，是不能保证该次转移是 合法的 即不能排除第 i−2层摆放的棋子可以攻击到第 i 层棋子的 不合法 情况 而解决该问题的手段就是：压缩存储两层的信息，然后枚举合法的第 i−2 层状态进行转移即可。 g图的存储一样，一个state表示一行，其中每位的i为1表示 不能放。如果实际st放了，则 g[i] & st 为true,即if(!(g[i] & st)) 为false,符合题意。 #include #include using namespace std; const int N = 110, M = 1 state; vector head[M]; bool check(int st) //妙啊 { return !(st & st >> 1 || st & st >> 2); } int count(int st) { int res = 0; while (st) res += st & 1, st >>= 1; return res; } int main() { //input cin >> n >> m; for (int i = 1, j = 0; i > c; ++ j) //纯属为了压行 // g[i] |= (c == 'H') 目标状态优化 思路同前两题一样，这里不做额外阐述 for (int i = 1; i 三进制 用三种不同颜色为网格涂色 给你两个整数 m 和 n 。构造一个 m x n 的网格，其中每个单元格最开始是白色。请你用 红、绿、蓝 三种颜色为每个单元格涂色。所有单元格都需要被涂色。 涂色方案需要满足：不存在相邻两个单元格颜色相同的情况 。返回网格涂色的方法数。因为答案可能非常大， 返回 对 10^9 + 7 取余 的结果。 提示： 1 解： class Solution { public: int f[1005][255]; int mod = 1e9 + 7, M; bool check(int S) { int last = -1; for(int i = 0; i 6 区间DP 1 合并果子问题 任意合并(Huffman Tree) 任意两个堆合并 如果每轮合并的石子 可以是任意 的 两堆 石子，那么用到的就是经典的 Huffman Tree 的二叉堆模型 合并果子 共 n 堆果子，每堆 hi 个，现要经过 n−1 次合并，合成 1 堆，每次合并 2 堆。一次合并编号为 i ， j 的果子，消耗 hi+hj 的体力，并且将两堆的果子数相加。问最终消耗体力的总和为多少。 (贪心,哈夫曼树,堆,优先队列) O(nlogn) 使用小根堆维护所有果子，每次弹出堆顶的两堆果子，并将其合并，合并之后将两堆重量之和再次插入小根堆中。 每次操作会将果子的堆数减一，一共操作 n−1 次即可将所有果子合并成1堆。每次操作涉及到2次堆的删除操作和1次堆的插入操作，计算量是 O(logn) 。因此总时间复杂度是 O(nlogn) 。// 全入堆 后处理 int res = 0; while (heap.size() > 1) { int a = heap.top(); heap.pop(); int b = heap.top(); heap.pop(); res += a + b; heap.push(a + b); } 如果每轮合并的石子 可以是任意 的 n 堆 石子，那么用到的就是经典的 Huffman Tree 的 n 叉堆模型 荷马史诗 待？？ typedef long long LL; typedef pair PLI; const int N = 1e5 + 10; int n, m; priority_queue, greater> heap; int main() { cin >> n >> m; for (int i = 0; i > w; heap.push({w, 0}); } while ((n - 1) % (m - 1)) { heap.push({0ll, 0}); n++; } LL res = 0; while (heap.size() > 1) { LL sum = 0; int depth = 0; for (int i = 0; i 相邻两个堆合并 区间DP 技巧：对于环形可开二倍空间，通过使用区间的长度len限制在n，解决环形问题又不致重复使用。 相邻合并 环形石子合并 将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。 规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。 请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算： 选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。 选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。 解： 考虑如何设定 动态规划 的阶段，既可以表示出初始每个石子的费用，也可以表示出合并后整个堆的费用 不妨把当前合并的石子堆的大小作为DP的阶段 这样 len=1 表示初值，即每个堆只有一个石子； len=n 表示终值，即一个堆中有所有的石子 这种阶段设置方法保证了我们每次合并两个区间时，他们的所有子区间的合并费用都已经被计算出来了 阶段设定好后，考虑如何记录当前的状态，无外乎就两个参数： 石子堆的左端点 l 石子堆的右端点 r 闫氏DP分析法 在区间DP中，我们也常常省去 len 这一维的空间 因为 r−l+1=len，也就保证了在已知 l 和 r 的情况下，不会出现状态定义重复的情况 根据线性代数中方程的解的基本概念，我们就可以删掉 len 这一维不存在的约束 但为了方便读者理解，以及介绍区间DP的阶段是如何划分的，我还是写了出来 在考虑一下本题的 环形相邻 情况如何解决，方案有如下两种： 我们可以枚举环中分开的位置，将环还原成链，这样就需要枚举 nn 次，时间复杂度为 O(n4) 我们可以把链延长两倍，变成 2n 个堆，其中 i 和 i+n 是相同的两个堆，然后直接套 区间DP 模板，但对于 阶段 len 只枚举到 n，根据 状态的定义，最终可以得到所求的方案，时间复杂度为 O(n3) #include #include using namespace std; const int N = 210, M = N > w[i], w[i + n] = w[i]; // 从后面追加一份 //预处理前缀和（DP状态转移中会频繁的用到区间和） for (int i = 1; i 能量项链 求最终把所有石头融合成一个石头时，产生的最大能量值 问题转化： 本题可以把区间长度作为搜索的阶段来进行记忆话搜索，因此我们也可以采用 区间DP 的方式来处理 这题和 环形石子合并 十分相似，但又不尽相同 在 环形石子 中，每个石头只有单一的参数，而本题有两个参数，也就意味着我们需要在细节上做出改变 经过观察我们发现，合并两个石头 (a,b),(b,c) 的操作就像是矩阵乘法一样，合并完后就变成了 (a,c) 因此我们可以离散的来存储每个参数，具体如下所示： 这样 状态表示 就更新为：当前合并的石子堆的左端石头的左参数是 l，右端石头的右参数是 r 的方案 这样对应的 初始状态 本来应该是一个有着 二元属性 的石头，现在就变成了长度为 2 的区间 这样合并区间后，需要记录的新石头的参数也刚好是 区间的两端 对应的参数，如下图所示： 而且这里我们的转移方程也要修改为 fl,r=max(fl,k+fk,r+El,r) 以往的 区间DP 我们是把区间 [a,b]拆分为 [a,k]和[k+1,b] 因为 同一个石子 只会被合并到 一个石子堆 里 但本题合并魔法石时，分割点 kk 要被分到 左侧石子堆的右端点 和 右侧石子堆的左端点 中 因此，参数 k 要作为两个区间的共同端点来使用，即 [a,k] 和 [k,b] 此外我们原来只需要合并 n 个石头，这样转换后就要合并 n+1 个石头了 具体分析如下所示： #include #include using namespace std; const int N = 110, M = N 加分二叉树 给定一个含有 n 个结点的二叉树的 中序遍历 序列中每个节点的 权值 定义一棵 子树 的 分数 为 左子树的分数×右子树的分数+根节点的权值左子树的分数×右子树的分数+根节点的权值 额外规定 空树 的 分数 为 1 求一种满足该 中序遍历 的建树方案，使得整棵树的 分数 最大 输入格式 第 1 行：一个整数 n，为节点个数。  第 2 行：n 个用空格隔开的整数，为每个节点的分数（0 解： 状态表示：f[i][j] 表示中序遍历是 w[i ~ j] 的所有二叉树的得分的最大值。 状态计算：f[i][j] = max(f[i][k - 1] f[k + 1][j] + w[k])，即将f[i][j]表示的二叉树集合按根节点分类，则根节点在 k 时的最大得分即为 f[i][k - 1] f[k + 1][j] + w[k]，则f[i][j]即为遍历 k 所取到的最大值。 在计算每个状态的过程中，记录每个区间的最大值所对应的根节点编号。 那么最后就可以通过DFS求出最大加分二叉树的前序遍历了。 状态总数是 O(n2) ，计算每个状态需要 O(n)的计算量，因此总时间复杂度是 O(n3)。 解： 二叉树节点 向下投影，映射成的数组序列就是 中序遍历序列，入下图所示 这也是诱使我们本题采用 区间DP 的一大原因之一（但这篇题解采用 记忆化搜索 思想分析） 借助上图直观的表象，我们发现可以任意的选择 中序遍历 的某一段区间便可生成多棵子树（枚举根节点） 于是我们就会想到 分治 的思想，枚举好根节点后，递归的处理左右区间生成的 最大分数子树 回溯后，利用计算好的子树的分数 相乘，再加上根结点的 权值，就可以得出该方案的 最大分数 而直接递归 搜索 的时间复杂度是 O(n!) （每次枚举当前区间的根结点，然后递归处理左右区间） n×(n−1)×⋯×1=n! （每次向下层递归时，会确定一个根节点，因此每次少 1） 因为在这个递归中，有相当大的计算是去处理的 相同的区间 因此我们不妨采用 记忆化搜索 的形式优化掉这些 重复的搜索 考虑用数组 f[l,r] 记录以 l 为左端点，r 为右端点的区间，生成的树的最大分数 这样就会 剪枝 掉相当大的冗余 搜索分支 记忆化搜索 #include #include #include using namespace std; const int N = 35, INF = 0x3f3f3f3f; int n; int w[N]; int f[N][N], g[N][N]; int dp(int l, int r) { if (~f[l][r]) return f[l][r]; //记忆化搜索 if (l == r) return g[l][r] = l, f[l][r] = w[l]; //题设只有一个节点时，分数就是权值 if (l > r) return f[l][r] = 1; //题设空子树的分数为1 int score = -INF; for (int root = l, t; root score) score = t, g[l][r] = root; return f[l][r] = score; } void dfs(int l, int r) { if (l > r) return; cout > n; for (int i = 1; i > w[i]; memset(f, -1, sizeof f); cout 区间DP #include #include #include #include using namespace std; typedef pair PII; const int N = 50; int n; int w[N]; unsigned f[N][N]; int root[N][N]; void dfs(int l, int r) { if (l > r) return; int k = root[l][r]; printf(\"%d \", k); dfs(l, k - 1); dfs(k + 1, r); } int main() { scanf(\"%d\", &n); for (int i = 1; i 凸多边形的划分 给定一个具有 N 个顶点的凸多边形，将顶点从 1 至 N 标号，每个顶点的权值都是一个正整数。 将这个凸多边形划分成 N−2 个互不相交的三角形，对于每个三角形，其三个顶点的权值相乘都可得到一个权值乘积，试求所有三角形的顶点权值乘积之和至少为多少。 输入格式 第一行包含整数 N，表示顶点数量。 第二行包含 N 个整数，依次为顶点 1 至顶点 N 的权值。 输出格式 输出仅一行，为所有三角形的顶点权值乘积之和的最小值。 数据范围 N≤50, 数据保证所有顶点的权值都小于109 输入样例： 5 121 122 123 245 231 输出样例： 12214884 解： 回归本题，本题是一个给定的 凸多边形 求 三角剖分 的最小费用方案 很显然一个 凸多边形的剖分方案 并不唯一： 在 选定 多边形中 两个点 后，找出 三角形 的 第三个点 的方案有 n−2 个 然后还要分别 划分 他的 左右两块区域 因此我们就会想到用 记忆化搜索 或者 区间DP 来进行处理 区间DP 高精度加法 乘法 #include #include using namespace std; typedef long long LL; const int N = 55; int n; int w[N]; vector f[N][N]; bool cmp(vector &a, vector &b) { if (a.size() != b.size()) return a.size() = 0; i -- ) if (a[i] != b[i]) return a[i] add(vector a, vector b) { vector c; int t = 0; for (int i = 0; i mul(vector a, LL b) { vector c; LL t = 0; for (int i = 0; i = 0; i -- ) printf(\"%d\", res[i]); puts(\"\"); return 0; } 7 树形DP 换根DP 树的直径问题 以下同步在 基本数据结构中 的树 不带边权(边权为1) 步骤: 任取一点，求距其最远点u(u一定为某条直径的一个端点) 再求距u最远点v，u与v即为所求 方法： bfs，dfs 见正文 详细证明：力扣官方解答：「算法导论习题解答 9-1 带边权 且边权可为正也可为负 方法： 树形dp 求挂到某个点的两条边的最大值 和 次大值，即所有向子树或父树延伸的最大深度 和 次大深度，但两者不能在同一棵延伸树上。 用dfs搜深度 树的最长路径int dfs(int u, int f){ // 记录 出发节点 f 防止重复遍历 int dist = 0; int d1 = 0, d2 = 0; for(int i = h[u]; ~ i; i = ne[i]){ int j = e[i]; if(j == f) continue; int d = dfs(j, u) + w[i]; dist = max(dist, d); if(d >= d1) d2 = d1, d1 = d; else if(d > d2) d2 = d; } ans = max(ans, d1 + d2); return dist; } 换根DP 树的中心 边权为1时，和LC：最小高度树一样 给定一棵树，树中包含 n 个结点（编号1~n）和 n−1 条无向边，每条边都有一个权值。 请你在树中找到一个点，使得该点到树中其他结点的最远距离最近。 输入格式 第一行包含整数 n。 接下来 n−1 行，每行包含三个整数 ai,bi,ci，表示点 ai 和 bi 之间存在一条权值为 ci 的边。 输出格式 输出一个整数，表示所求点到树中其他结点的最远距离。 数据范围 1≤n≤10000, 1≤ai,bi≤n, 1≤ci≤105 输入样例： 5 2 1 1 3 2 1 4 3 1 5 1 1 输出样例： 2 解： 这个问题是 树形DP 中的一类 经典模型，常被称作 换根DP 同样，先来想一下如何暴力求解该问题：先 枚举 目标节点，然后求解该节点到其他节点的 最远距离 时间复杂度为 O(n2)O(n2)，对于本题的 数据规模，十分极限，经测试只能过 6/106/10 考虑如何优化求解该问题的方法 思考一下：在确定树的 拓扑结构 后单独求一个节点的 最远距离 时，会在该树上去比较哪些 路径 呢？ 1.从当前节点往下，直到子树中某个节点的最长路径 2.从当前节点往上走到其父节点，再从其父节点出发且不回到该节点的最长路径 此处就要引入 换根DP 的思想了 换根DP 一般分为三个步骤： 指定任意一个根节点 一次dfs遍历，统计出当前子树内的节点对当前节点的贡献 一次dfs遍历，统计出当前节点的父节点对当前节点的贡献，然后合并统计答案 那么我们就要先 dfs 一遍，预处理出当前子树对于根的最大贡献（距离）和 次大贡献（距离） 处理 次大贡献（距离） 的原因是： 如果 当前节点 是其 父节点子树 的 最大路径 上的点，则 父节点子树 的 最大贡献 不能算作对该节点的贡献 因为我们的路径是 简单路径，不能 走回头路 然后我们再 dfs 一遍，求解出每个节点的父节点对他的贡献（即每个节点往上能到的最远路径 两者比较，取一个 max 即可 时间复杂度 为 T(2n)=O(n) 更具体来说： 首先分析题目，其实是要我们把每一个点到其他点的最长距离求出来，再求一个其中最短的就可以了，我们来分析一下每一个点可以再树上怎么走，其实就是向上和向下走 我们用 d1[u],d2[u],up[u],p1[u],p2[u]分别存一下需要的信息，这些数据存的是： d1[u]：存下u节点向下走的最长路径的长度 d2[u]：存下u节点向下走的第二长的路径的长度 p1[u]：存下u节点向下走的最长路径是从哪一个节点下去的 p2[u]：存下u节点向下走的第二长的路径是从哪一个节点走下去的 up[u]：存下u节点向上走的最长路径的长度 向下走是很容易的，dfs就可以了，那怎么向上走呢？其实向上走就是求一个点的父节点的不走该节点的最长路径，其实我们知道了每一个节点向下走的长度就可以知道向上的最长路径了，一个子节点 j 的向上最长路径就是 它的父节点 u 的最长向上路径和最长向下路径取最大值，如果向下最长路径经过了 j 就改为第二长的向下路径，对应代码： if(p1[u]==j)up[j]=max(up[u],d2[u])+w[i]; else up[j]=max(up[u],d1[u])+w[i]; #include #include #include using namespace std; const int N = 10010, M = N = d1[u]) //更新一下最长和第二长的路径，并记录下从该路径是从哪一个点下去的 { d2[u] = d1[u], p2[u] = p1[u]; d1[u] = d1[j] + w[i], p1[u] = j; } else if (d1[j] + w[i] > d2[u]) { d2[u] = d1[j] + w[i], p2[u] = j; } } // if (d1[u] == -INF) d1[u] = d2[u] = 0; //特判叶子结点 } void dfs_up(int u, int father) { for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; if (p1[u] == j) up[j] = w[i] + max(up[u], d2[u]); //son_u = j，则用次大更新 else up[j] = w[i] + max(up[u], d1[u]); //son_u != j，则用最大更新 dfs_up(j, u); // ！注意位置啊 } } int main() { memset(h, -1, sizeof h); scanf(\"%d\", &n); for (int i = 1; i 另代码：LC：最小高度树 即求边权为1时，类似树的直径问题。 解：三种方法 dfs bfs class Solution { int h[N], e[M], ne[M], idx; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } int findLongestNode(int u, vector& p){ int n = p.size(); queue q; q.push(u); vector vis(n); vis[u] = true; int node = -1; while(q.size()){ int t = q.front(); q.pop(); node = t; // 用于保存出队列的点 最后出队列 即距离u最远 for(int i = h[t]; i != -1; i = ne[i]){ int j = e[i]; if(!vis[j]){ vis[j] = true; p[j] = t; q.push(j); } } } return node; } public: vector findMinHeightTrees(int n, vector>& edges) { memset(h, -1, sizeof h); if(n == 1) return {0}; idx = 0; for(int i = 0; i p(n, -1); int x = findLongestNode(0, p); /* 找到与节点 0 最远的节点 x */ int y = findLongestNode(x, p); /* 找到与节点 x 最远的节点 y */ vector path; /* 求出节点 x 到节点 y 的路径 */ p[x] = -1; while(y != -1){ path.emplace_back(y); y = p[y]; } int m = path.size(); if(m & 1) return {path[m >> 1]}; else return {path[(m >> 1) - 1], path[m >> 1]}; } }; topsort 利用了topsort的原理，代码还是有不同的。。 class Solution { int h[N], e[M], ne[M], id[N], idx; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } public: vector findMinHeightTrees(int n, vector>& edges) { memset(h, -1, sizeof h); memset(id, 0, sizeof id); if(n == 1) return {0}; idx = 0; for(int i = 0; i q; vector ans; for(int i = 0; i 2){ int sz = q.size(); remainNodes -= sz; for(int k = 1; k 树形dp + 递归dfs 二叉树中的最大路径和 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 示例 1： 输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6 示例 2： 输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42 提示： 树中节点数目范围是 [1, 3 * 104] -1000 解： 区别于树的直径，不用连到端点。 // 思路:思路其实并不复杂，最大值的情况只有四种，一种是当前根节点，一种是当前根节点和左子树一侧最大值(包含左子树),一种是当前根节点和右子树一侧最大值(包括右子树)以及当前根节点和左右子树一侧最大值(包含左右节点)。 // 实现的时候有一些trick:可以让dfs的返回值为包含当前结点一侧的最大值，同时维护一个全局变量ans记录四种情况的最大值，最终返回ans。这其实是树形dp模型的入门题。 class Solution { int ans = -1001; public: int maxPathSum(TreeNode* root) { dfs(root); return ans; } // 返回值为包含根结点的 一侧 最大值 int dfs(TreeNode*& root){ if(root == nullptr){ return 0; } int l_max = dfs(root->left); int r_max = dfs(root->right); int res = max({root->val,root->val+l_max,root->val+r_max}); ans = max(ans,max(res,root->val + l_max + r_max)); return res; } }; 树形DP + 背包 二叉苹果树 给定一棵含有 n 个结点的树，树根编号为 1，且树上的每条边有一个边权 w_edgej 要求我们只保留树中的 m 条边，使得 树根 所在的 连通块 的所有边 边权之和 最大 解： 这题的题面其实就是 有依赖的背包 模型，不同的是把 物品价值 分给了 边 而不是 点 不过，对于一棵树来说，任意节点的入边（连向父节点的边） 都是 唯一 的 所以 边权 和 点权 在确定树的 根节点 以后，是可以视作一个东西的（入边价值 视作 该点价值） 常用的 有依赖的背包DP 集合划分方案有两个： 子物品体积集合划分 O(N×V×V) AcWing 10. 有依赖的背包问题【有依赖背包DP+子物品体积集合划分】 分组背包集合划分 O(N×2^k×V) AcWing 487. 金明的预算方案【有依赖背包DP+分组背包集合划分】 对于本题来说，分组背包集合划分 会超时，因此采用 体积集合划分方案 #include #include using namespace std; const int N = 110, M = N = 0; j -- ) for (int k = 0; k 树形DP + 状态机 战略游戏 给定一棵包含 nn 个结点的 树，以及 树 上的 n−1n−1 条边 我们需要在这 nn 个结点中，选择一定数量的结点放上 哨兵 最终要求，树中任意 n−1n−1 条边的左右两端，至少有一个结点上放置了 哨兵 求解一个 方案，该方案满足上述要求，且放置的哨兵数量 最少，输出该 方案 放置的 哨兵数量 树形DP+状态机模型，类似于 树形 打家劫舍。 类似的题目还有：没有上司的舞会 Ural 大学有 N 名职员，编号为 1∼N。 他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。 每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。 现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。 在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。 皇宫看守？？ 给定一个含有 n 个结点的 树 每个结点有一个 权值 wi 表示在第 i 个点上放置 哨兵 的 花费 对于每个 哨兵 来说，他可以 观察 当前结点，以及所有与当前点 相连 的 相邻结点 求解一种放置哨兵的 方案，使得每个 结点 都被 观察 到，且方案的 花费 最小 解： 本题的要求相对于 战略游戏 ，稍稍增加了一些 难度，原因如下： 如果只是要求 每条边 被 观察 到，那么我们在处理 父节点 时，枚举到一个 子节点 就可以直接进行讨论 父节点 放置 哨兵，所有子节点都 可放可不放 哨兵 父节点 不放 哨兵，所有子节点 都要放置 哨兵 但是在本题的 要求 中，每条边 变成了 每个点 就会出现如下三种情况： 父节点 放置 哨兵，所有子节点都 可放可不放 哨兵 父节点 不放 哨兵，但是他至少有一个 子节点 放置哨兵，观察住了他 父节点 不放 哨兵，但 父节点 的 父节点 放置哨兵观察，则 子节点 可放可不放 哨兵 这样每个结点就有 三种情况 要转移，简略状态机模型如下： 1.被父节点观察 （0） 2.被子节点观察 （1） 3.被自己来观察 （2） 状态表示 #include #include using namespace std; /* 状态机 + 树形Dp问题 状态表示: f(i, 0)：第i号结点被他的父结点安排的守卫看住的方案数 f(i, 1)：第i号结点被他的子结点安排的守卫看住的方案数 f(i, 2)：第i号结点自己安排守卫看住的方案数 状态计算:(j是i的子结点) f(i, 0) = sum{min(f(j,1), f(j,2))} i是被他父结点看住的，那他的子结点要么自己看自己，要么被自己的子结点看住 f(i, 1) = min{w(k) + f(k, 2) - sum{min(f(j,1), f(j,2))}} i如果是被子结点看住的，那么就要枚举他是被哪个子结点看住的所有方案，对所有方案求最小值 这里的sum不包括j==k的情况，因此需要手动额外减去 f(i, 2) = sum{min(f(j,0), f(j,1), f(j,2))} + w(u) i是被自己看住的，那他的子结点可以被父结点看住，可以自己看自己，也可以被自己的子结点看住 */ const int N = 1510; int n; int h[N], w[N], e[N], ne[N], idx; int f[N][3]; bool st[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } void dfs(int u) { f[u][0] = 0; f[u][1] = 1e9; //f[u][1]求最小值，初始化为最大值 f[u][2] = w[u];//初始化放置自己的代价 for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; dfs(j); f[u][0] += min(f[j][1], f[j][2]); f[u][2] += min(min(f[j][0], f[j][1]), f[j][2]); } for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; //f[u][0]中记录了sum{min(f(j,1), f(j,2))}，再从中减去对应的贡献即可得到remain ver f[u][1] = min(f[u][1], f[u][0] + f[j][2] - min(f[j][1], f[j][2])); } } int main() { memset(h, -1, sizeof h); cin >> n; for (int i = 1; i > id >> cost >> cnt; cout > ver; add(id, ver); st[ver] = true; } } int root = 1; while (st[root]) ++root; dfs(root); printf(\"%d\\n\", min(f[root][1], f[root][2])); return 0; } 美团2019：切割树 给你一棵含有 n 个结点的树，编号为 0∼n−1，这 n 个结点都被染成了黑色或白色。 显然，对于一棵树而言，我们每去掉一条边就能把树分成两部分。 现在，要求你把这棵树切开，使得每一个连通块内只有一个白色结点。 问共有多少种切开的方式满足以上条件，如果被删除的边集不同，我们则认为两种方式不同，反之，认为相同。 请输出对 1000000007 取模后的结果。 输入格式 第一行仅包含一个正整数 n，表示树的结点数量。 第二行包含 n−1 个数字，第 i 个数字表示第 i 个结点的根，我们认为 0 号结点是整棵树的根，第 i 个数字不超过 i，即第 i 个结点的根一定是编号小于 i 的结点。 第三行包含 n 个数字，第 i 个数字表示第 i−1 个结点的颜色，0 表示白色，1 表示黑色。 输出格式 输出一个整数表示对 1000000007 取模后的结果。 数据范围 1≤n≤105 输入样例1： 3 0 0 1 0 0 输出样例1： 2 输入样例2： 10 0 0 1 2 0 5 1 2 3 1 0 0 1 0 0 1 1 0 1 输出样例2： 3 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 233; const ll mod = 1000000007; int e[maxn * 2], h[maxn], pre[maxn * 2], c[maxn], cnt; void add(int u, int v) { e[cnt] = v; pre[cnt] = h[u]; h[u] = cnt++; } ll ksm(ll n, ll k) { ll res = 1; while(k) { if(k & 1) res = (res * n) % mod; n = (n * n) % mod; k >>= 1; } return res; } ll f[maxn][2], vis[maxn]; void dfs(int x, int fa) { vis[x] = 1; if(c[x] == 0) { f[x][0] = 1; f[x][1] = 0; for(int i = h[x]; ~i; i = pre[i]) { int y = e[i]; if(vis[y]) continue; dfs(y, x); f[x][0] *= f[y][1] + f[y][0]; f[x][0] %= mod; } } else { f[x][0] = 0; f[x][1] = 1; int val = 1; for(int i = h[x]; ~i; i = pre[i]) { int y = e[i]; if(vis[y]) continue; dfs(y, x); f[x][1] *= f[y][0] + f[y][1]; f[x][1] %= mod; } for(int i = h[x]; ~i; i = pre[i]) { int y = e[i]; ll k = f[y][0] + f[y][1]; k = ksm(k, mod - 2); if(y != fa) f[x][0] += (((f[y][0] * f[x][1]) % mod) * k) % mod, f[x][0] %= mod; } } } int main() { int n; cin >> n; memset(h, -1, sizeof h); for(int i = 2; i 8 数位DP 数位dp的题目一般会问，某个区间内，满足某种性质的数的个数。 对应的数位dp问题有相应的解题技巧： 利用前缀和，比如求区间[x,y]中的个数，转化成求[0,y]的个数 -[0,x-1]的个数。 利用树的结构来考虑（按位分类讨论） 此时的dp更多的是进行预处理，而不解决具体问题。 具体问题要用树形结构的分析思路去求解。 例题 数字 1 的个数 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例 1： 输入：n = 13 输出：6 示例 2： 输入：n = 0 输出：0 解： 分别枚举小于等于n的整数中每一位上数字1出现的次数。 假设n从高位到低位为abcdefg，则d位置上为1且小于等于n的数字hijklmn有两种情况，一是最高的三位hij小于abc，则这种情况前3位hij可以取000~(abc - 1)，后三位lmn可以去000~999，所以有(abc) 1000个数。二是最高的三位hij等于abc，这种情况下如果k小于d，则nml可以取000~999，有1000个数，如果k等于d，则nml可以取000 ~ efg，有efg+1个数。综上，总共有(abc) 1000+1000+efg+1个数，则第d位上数字1出现的个数就求出来了，同理将每一位上1出现的个数求和得到的就是答案 class Solution { int get(vector& v, int l, int r){ int res = 0; for(int i = r; i >= l; -- i){ res *= 10; res += v[i]; } return res; } public: int countDigitOne(int dig) { int res = 0; vector num; // dig = abc d efg while(dig) num.push_back(dig % 10), dig /= 10; int n = num.size(); for(int i = n - 1; i >= 0; -- i){ int x = num[i]; // 前面取 0 - (abc - 1)时 当i == n-1 时，abc不存在.. if(i 1) res += pow(10, i); } return res; } }; 同理，要求m出现的次数，把上述代码中最后部分 if(x == m) res.. else if(x > m) 即可。 2出现的次数 编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。 示例: 输入: 25 输出: 9 解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次) 度的数量 求给定区间 [X,Y] 中满足下列条件的整数个数：这个数恰好等于 K 个互不相等的 B 的整数次幂之和。 例如，设 X=15,Y=20,K=2,B=2，则有且仅有下列三个数满足题意： 17=2^4+2^0 18=2^4+2^1 20=2^4+2^2 #include #include #include #include using namespace std; const int N = 35; int K, B; int f[N][N]; void init(){//求组合数 for(int i=0;i v; while (n) v.push_back(n % B), n /= B; int res=0; int last=0; // 表示已经取了多少个1 for(int i=v.size()-1;i>=0;i--){//从最高位对每一位数讨论 int x=v[i]; if(x){ res += f[i][K - last];//加上第i位取0的时候的组合数，也就是对于后面i位取k-last个1的数量 if (x > 1)//如果x>1，就可以直接用组合数表示出来，不用进行讨论，也就是i位取1的时候，后面i位随便取k-last-1个1 { if (K - last - 1 >= 0) res += f[i][K - last - 1]; break; } else//如果x==1，那么i位取1的时候，还要进行讨论，后面i位不能随便取，也就不是组合数 { last ++ ; if (last > K) break; } } if (!i && last == K) res ++ ;// 对于最后一位来特殊来考虑 ，即最右侧分支的一条线(n = a_v a_(v-1) .. a_2 a_1 a_0) } return res; } int main() { init(); int l, r; cin >> l >> r >> K >> B; cout 数位DP记忆化搜索 彩色铅笔：数位DP基本概念+数位DP记忆化搜索 #include #include #include using namespace std; const int N = 35; int l, r, k, b; int a[N], al; int f[N][N]; int dp(int pos, int st, int op) //op: 1=,0 k) continue; res += dp(pos - 1, st + i, op && i == a[pos]); } return op ? res : f[pos][st] = res; } int calc(int x) { al = 0; memset(f, -1, sizeof f); //模板的必要初始化步骤 while (x) a[ ++ al] = x % b, x /= b; //把x按照进制分解到数组中 return dp(al, 0, 1); } int main() { cin >> l >> r >> k >> b; cout 数字游戏 一个整数闭区间 [a,b]，问这个区间内有多少个不降数：必须满足从左到右各位数字呈非下降关系，如 123，446。。 #include #include #include #include using namespace std; const int maxn=15; int f[maxn][maxn]; ///f[i][j]表示最高位是j并且一共有i位的不降数的集合 void init() { for(int i=0;inums; while(n) nums.push_back(n%10),n/=10; int res=0;//方案数 int last=0;//保留一些前缀信息，本题是上一个数是几 ///从最大数开始枚举 for(int i=nums.size()-1;i>=0;i--) { int x=nums[i];//x为当前这位数 for(int j=last;j=上一位，所以从last开始枚举,最多枚举到x,last为上一位，也即最高位，对下一位的枚举是有限制的 res+=f[i+1][j]; ///左端的节点有i+1个位数（因为第一位的下标是0) if(x>l>>r) { cout 数位DP记忆化搜索 #include #include #include using namespace std; const int N = 35; int l, r; int a[N], al; int f[N][N]; int dp(int pos, int st, int op) { if (!pos) return 1; if (!op && ~f[pos][st]) return f[pos][st]; int res = 0, maxx = op ? a[pos] : 9; for (int i = st; i > l >> r) { cout 至少有 1 位重复的数字 给定正整数 n，返回在 [1, n] 范围内具有 至少 1 位 重复数字的正整数的个数。 示例 1： 输入：n = 20 输出：1 解释：具有至少 1 位重复数字的正数（ 补集为 ：周赛：统计各位数字都不同的数字个数 周赛题解： class Solution { public: int countSpecialNumbers(int n) { vector nums; int x = n; while (x) nums.push_back(x % 10), x /= 10; int res = 0; // S(nums.begin(), nums.end()); if (nums.size() == S.size()) res ++ ; return res; } }; 不含连续1的非负整数 给定一个正整数 n ，返回范围在 [0, n] 都非负整数中，其二进制表示不包含 连续的 1 的个数。 示例 1: 输入: n = 5 输出: 5 解释: 下面是带有相应二进制表示的非负整数 class Solution { static const int N = 50; // f[i][j] 为考虑二进制长度为 i，而且最高位为 j（0 or 1）时的合法数个数（值不超过） // 如 f[2][1] 代表二进制长度为 2，且（值不超过）最高位为 1 的合法数的个数为 3 个：10、01、00 long f[N][2]; void init() { f[1][0] = 1; f[1][1] = 2; for (int i = 1; i = 0; i--) { if (((n >> i) & 1) == 1) return i; } return 0; } public: int findIntegers(int n) { int len = getLen(n); int ans = 0, pre = 0; init(); for(int i = len; i >= 0; -- i){ int cur = ((n >> i) & 1); // 当前位是 0 还是 1 // 由于始终要满足小于等于的要求，如果当前位本来为 1 的话，填成 0 的话，后面的低位无论怎么填，都是满足小于等于的要求的，因此将 f[i + 1][0] 累加到答案 if(cur == 1) ans += f[i + 1][0]; if(pre == 1 && cur == 1) break; // 出现连续位为 1，分支结束，方案数被计算完 pre = cur; if(!i) ans ++; } return ans; } }; Windy数 Windy 定义了一种 Windy 数：不含前导零且相邻两个数字之差至少为 2 的正整数被称为 Windy 数。 Windy 想知道，在 A 和 B 之间，包括 A 和 B，总共有多少个 Windy 数？ 解：数位DP 假设我们当前枚举到第i位(设共有n位)，且第i位上的数字为x，那么对于答案中第i位数字j来说，有两类： 1.0~x-1 (如果第i位是最高位，这里是1~x-1) 括号中提到的1~x-1后面会解释 ,我们用last记录上一位的数字，然后枚举j，如果abs(j-last) >= 2 就累加答案，res += f[i+1][j]; 2.x 不需要枚举j，last = x,再枚举之后的数位即可 上述做完之后，由于上面的答案都是n位的，对于数位个数低于n的，再累加到答案中就行了 f数组的处理 f[i][j] 表示一共有i位，且最高位数字为j的满足windy数定义的数的个数 状态转移： 因为第i位是j已经确定，考虑第i-1位，设第i-1位数字为k，那么根据windy数定义只要abs(k-j) >= 2就可以转移过来 关于前导0 上面提到了枚举的第i位是最高位，那么不能填0，这里解释一下，如果我们填0，那么答案就会加上f[i+1][0],，举这样一个例子， 对于数字13，他是满足windy数定义的，那么加上前导0之后的013就不会被f[3][0]加进去，原因就是abs(0-1) #include #include #include #include #include using namespace std; const int N = 11; int f[N][N]; //f[i][j] 表示一共有i位，且最高为是数字j的满足wingy数定义的数的个数 void init(){ for(int i = 0; i=2) f[i][j] += f[i-1][k]; } int dp(int n){ int res = 0,last = -10; vector a; while(n)a.push_back(n%10),n/=10; int len = a.size()-1; //答案是a.size()位的 for(int i =len; i>=0; --i){ int x = a[i]; for(int j = (i==len); j=2) res += f[i+1][j]; if(abs(x-last)>l>>r; cout 数位dp + 记忆化搜索 #include #include #include using namespace std; const int N = 35; int l, r; int a[N], al; int f[N][N]; int dp(int pos, int st, int op) { if (!pos) return 1; if (!op && ~f[pos][st]) return f[pos][st]; int res = 0, maxx = op ? a[pos] : 9; for (int i = 0; i = 2) res += dp(pos - 1, !i && st == -2 ? -2 : i, op && i == a[pos]); return op && st == -2 ? res : f[pos][st] = res; } int calc(int x) { memset(f, -1, sizeof f); al = 0; for ( ; x; x /= 10) a[ ++ al] = x % 10; return dp(al, -2, 1); } int main() { cin >> l >> r; cout 数字游戏 II 指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数(这种数字必须满足各位数字之和 mod N 为 0)。 输入格式 输入包含多组测试数据，每组数据占一行。 每组数据包含三个整数 a,b,N。 输出格式 对于每个测试数据输出一行结果，表示区间内各位数字和 mod N 为 0 的数的个数。 数据范围 1≤a,b≤231−1, 1≤N 预处理 int f[N][10][M]; //f[i][j][k] 表示一共有i位，且最高位数字是j，且所有位数字和模p位k的数字个数 int mod(int u,int v){ return (u%v+v)%v; //c++的%会得到负数，需要做一个偏移 } void init(){ memset(f,0,sizeof f); //多组测试数据，f数组要清空 for(int i = 0; i 求解 int dp(int n){ if(!n) return 1; int res = 0,last = 0; vector a; while(n) a.push_back(n%10),n/=10; int len = a.size()-1; for(int i = len; i>=0; --i){ int x =a[i]; for(int j = 0; j 不要62 不吉利的数字为所有含有 4 或 62 的号码。例如：62315,73418,88914 都属于不吉利号码。但是，61152 虽然含有 6 和 2，但不是 连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照号区间 [n,m]，推断出交管局今后又要实际上给多少辆新的士车上牌照了。(可以以0开头) 预处理 int f[N][N];//f[i][j] 表示 我们填到第i位，当第i位填j的时候有多少种合适的车牌 void init()//数位DP日常初始化 { for(int i = 0;i 求解 int dp(int x) { if(!x) return 1; //日常边界判断，有的数位DP题里必须有，这道题需不需要你交一下试试就知道了 int a[12] = {0}; //我要用a数组把这个数的每一位都取出来 int l = 0, ans = 0,int last = 0; //last用来看上一位是不是6，如果是6 那么这一位我就不能填2了 while(x) { a[++ l] = x % 10; x /= 10; } for(int i = l;i >= 1;i --) { for(int j = 0;j 力扣数位dp题集 9 单调队列优化DP 看见连续等词，如连续k个至少选一个，一次最多跳k个格等考虑单调队列优化dp。 基础详见 基本数据结构部分中的单调队列基础。 还可用于优化多重背包问题。详情见动态规划中 多重背包部分。 此类题目需要转化问题，有的只需要求前面k个源元素的最值，有的则需要处理。如求前缀和的最值， 例题 如： 跳跃游戏 VI [j, i] 为[i - k,i - 1] 中，i - j 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。 一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。 你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。 请你返回你能得到的 最大得分 。 示例 1： 输入：nums = [1,-1,-2,4,-7,3], k = 2 类似烽火传递 带限制的子序列和 [j, i] 为[i - k,i] 中，i - j 给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和 j 满足 i 最大子序和 [j, i] 为 sum[i - k + 1, i] ，i - j 输入一个长度为 n 的整数序列，从中找出一段长度不超过 k 的连续子序列，使得子序列中所有数的和最大。 注意： 子序列的长度至少是 1。 修剪草坪 可选多段区间，每段区间长度受限，总的最大和 给定一个长度为 n 的数组 w，其中 wi 是第 i 个元素的 贡献 我们可以选择的 数组 中的一些 元素，需满足不能包含超过 K 个连续的元素， 求解一种 方案，使得选择的 元素贡献总和 最大。 ★★★★★D-和至少为 K 的最短子数组 给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。 子数组 是数组中 连续 的一部分。 ★★★★★D-绝对差不超过限制的最长连续子数组 题目： 给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。 如果不存在满足条件的子数组，则返回 0 dp + 单调队列优化 跳跃游戏 VI 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。 一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。 你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。 请你返回你能得到的 最大得分 。 示例 1： 输入：nums = [1,-1,-2,4,-7,3], k = 2 输出：7 解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。 示例 2： 输入：nums = [10,-5,-2,4,0,3], k = 3 输出：17 解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。 示例 3： 输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2 输出：0 class Solution { int p[100010], hh = 0, tt = -1; public: int maxResult(vector& nums, int k) { int n = nums.size(); vector f(n, 0); // 初值设为多少都行 f[0] = nums[0]; hh = 0, tt = 0; for(int i = 1; i p[hh]) hh ++; f[i] = f[p[hh]] + nums[i]; while(hh 烽火传递 给定一个长度为 nn 的数组 w，以及一个正整数 m 其中 wi 表示第 i 个 元素 的 价值 求一种选择元素的 方案： 使得选择的 相邻元素 之间相差 不超过 m−1 个 不选 的元素 选择的元素总贡献 最小 #include #include #include using namespace std; const int N = 2e5 + 10; int n, m; int w[N], f[N]; int que[N]; int main() { scanf(\"%d%d\", &n, &m); for (int i = 1; i m) hh ++ ; f[i] = f[que[hh]] + w[i]; while (hh = f[i]) tt -- ; que[ ++ tt] = i; } if (n + 1 - m > que[hh]) hh ++ ; //滑动窗口往后滑动一位 printf(\"%d\\n\", f[que[hh]]); return 0; } 带限制的子序列和 给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和 j 满足 i class Solution { static const int N = 100010; int q[N], f[N], hh = 0, tt = -1; public: int constrainedSubsetSum(vector& nums, int k) { // 非空 说明至少选一个。 // f[i] 表示在数组的前 i 个数中进行选择，并且恰好选择了第 i 个数，可以得到的最大和。 int n = nums.size(); int ans = nums[0]; for(int i = 0; i q[hh]) hh ++; f[i] = max(0, f[q[hh]]) + nums[i]; // max() !!!!关键啊 前面的最大值 前缀和 + 单调队列 最大子序和 输入一个长度为 n 的整数序列，从中找出一段长度不超过 m 的连续子序列，使得子序列中所有数的和最大。 注意： 子序列的长度至少是 1。 输入格式 第一行输入两个整数 n,m。 第二行输入 n 个数，代表长度为 n 的整数序列。 同一行数之间用空格隔开。 输出格式 输出一个整数，代表该序列的最大子序和。 数据范围 1≤n,m≤300000 输入样例： 6 4 1 -3 5 1 -2 3 输出样例： 7 解： 上述是选[j + 1, i],故 fi = max(si - sj) = si - min(sj), i 则i - m ，即i - m > j时弹出. 注意维护的是si,而且是最小值。 另外一种解释： 选sum[j, i], 则 fi = max(si - s(j-1)), 0 而求sum[j - i]时 为 s[i] - s[j - 1], 另j - 1 = h,为队头元素 则有 1 即1 为合法方案，当 i - h > m,即 i - q[hh] > m 时把队头弹出. const int N = 3e5 + 10; int n, m; LL s[N], que[N]; int main() { scanf(\"%d%d\", &n, &m); for (int i = 1; i m) hh ++ ; res = max(res, s[i] - s[que[hh]]); while (hh = s[i]) tt -- ; que[ ++ tt] = i; } printf(\"%lld\\n\", res); return 0; } 修剪草坪 给定一个长度为 n 的数组 w，其中 wi 是第 i 个元素的 贡献 我们可以选择的 数组 中的一些 元素，需满足不能包含超过 K 个连续的元素， 求解一种 方案，使得选择的 元素贡献总和 最大。 解： 枚举最后一个没有被选择的元素j,则有【j-1】【j】【j+1】...【i】 fi = max(f(j - 1) + si - sj) , 0 fi = si + max(f(j - 1) - sj), 0 #include #include #include using namespace std; typedef long long LL; const int N = 1e5 + 10; int n, m; LL s[N], f[N]; int que[N]; LL g(int i) { return f[max(0, i - 1)] - s[i]; } int main() { scanf(\"%d%d\", &n, &m); for (int i = 1; i = g(que[tt])) tt -- ; que[ ++ tt] = i; // i - j >= 0 故先入队 while (hh m) hh ++ ; f[i] = s[i] + g(que[hh]); } printf(\"%lld\\n\", f[n]); return 0; } ★★★★★D-和至少为 K 的最短子数组 给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。 子数组 是数组中 连续 的一部分。 示例 1： 输入：nums = [1], k = 1 输出：1 示例 2： 输入：nums = [1,2], k = 4 输出：-1 示例 3： 输入：nums = [2,-1,2], k = 3 输出：3 提示： 1 解： 首先计算原数组前缀和，用于快速计算区间[i，j]的子数组和。 枚举每个前缀，维护到一个单调递增的双端队列中。 对比当前前缀与双端队列的第一个元素（最小元素），通过差值算出区间和是否达到k，如果达到k则将区间长度添加到答案中。 弹出第一个元素，继续对比第二元素，缩短区间寻找更优解。 class Solution { static const int N = 100010; int q[N], hh = 0, tt = -1; long long pre[N]; public: int shortestSubarray(vector& nums, int k) { // k 为正值，故要求pre[j] - pre[i] > 0 int n = nums.size(); for(int i = 1; i = pre[j]) tt--; // 区间和为负或0直接舍去，即把tt去掉，即使可能会扩大j - i的范围 while(hh = k) // 满足条件 更新res res = min(res, j - q[hh]), hh ++; // 更新后q[hh]不会再被利用，因为即使被利用也不会是最优的结果 q[++ tt] = j; } // cout 哈希 +单调队列优化 满足不等式的最大值 给你一个数组 points 和一个整数 k 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 points[i] = [xi, yi] ，并且在 1 解： 所求式化简后得 问题要求解 y(i) + y(j) + |x(i) - x(j)| 的最大值。 由于给定的 points 数组横坐标 x 是从小到大排列的。所以，如果我们保证我们搜索的两个点，points[i] 在 points[j] 的前面，就一定有 x(i) - x(j) y(i) - x(i) 是多少。 我们把问题转换成为了一个求区间最大值的问题。 困难 绿色通道 给定一个 正整数 mm，以及一个长度为 nn 的正整数 数组 ww，其中 wiwi 为第 ii 个元素的 价值 求一个选择元素的 方案，使得元素的 价值总和 不超过 mm 且 相邻元素 的 间距最小 输出该 最小间距 解： 直接做不是很好做，不妨把问题转化为我们熟悉的模型来求解 显然，答案是存在 单调性 的： 1.任意比 答案 小的 间距 的选择方案，其 元素总和 必然超过 m 2.任意比 答案 大或相等的 间距，必然存在一个方案，使得 元素总和 小于等于 m 对于 2 是显然的，我们可以在原合法方案上，删去一些数，从而实现 间距 变大的操作 对于 1，我们可以用 反证法：若小于 答案 的 间距 存在符合条件的选元素方案 则我们的 答案 应该是该 间距，这与原答案 矛盾 找出该 单调性，我们就可以上 二分 了 现问题就转化成了：在确定 最小间距 情况下，能否找出选择 元素总和 小于等于 m 的方案 该问题 等价于： 在确定 最小间距 情况下，选择 元素总和 最小的方案 价值 是否 小于等于 m 这样本题就变成：AcWing 1089. 烽火传递【单调队列优化DP + 目标状态小优化】 #include #include #include using namespace std; const int N = 5e4 + 10; int n, m; int w[N], que[N], f[N]; bool check(int limit) { int hh = 0, tt = 0; for (int i = 1; i limit + 1) hh ++ ; f[i] = f[que[hh]] + w[i]; while (hh = f[i]) tt -- ; que[ ++ tt] = i; } if (n + 1 - que[hh] > limit + 1) hh ++ ; //滑动窗口往后多滑一位 return f[que[hh]] > 1; if (check(mid)) r = mid; else l = mid + 1; } printf(\"%d\\n\", r); return 0; } 基于二分 + 单调队列优化 你可以安排的最多任务数目 给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0 开始的整数数组 tasks 中，第 i 个任务需要 tasks[i] 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers 中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] >= tasks[i] ）。 除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。 给你下标从 0 开始的整数数组tasks 和 workers 以及两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。 示例 1： 输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1 输出：3 解释： 我们可以按照如下方案安排药丸： 给 0 号工人药丸。 0 号工人完成任务 2（0 + 1 >= 1） 1 号工人完成任务 1（3 >= 2） 2 号工人完成任务 0（3 >= 3） 解： 解决问题的关键在于想到如果完成了m个任务，最佳方案一定是力量最大的m个worker完成了要求力量最小的m个任务，每个worker都必须完成一个任务。如果能在O(n)的时间内解决m个worker能否完成m个任务的判定问题，就可以在O(nlogn)时间内通过二分法找到最佳方案。 解决判定问题的关键则是找到一个可行的贪心策略。按力量从小到大依次考虑每个worker W_j ，他可以选择的任务是要求力量值不超过W_j + strength且尚未完成的任务之一，而且必须从当中选一个。这里分为两种情况： 如果当前可选任务中要求力量值最小的一个小于等于W_j ，那么这个worker不用吃药就可以完成这个任务，因为后续的worker力量一定都比当前worker强，反正这个力量之最小的任务一定要被完成，当然是现在最弱的人完成最划算，而且也没必要吃药，所以当前worker应该不吃药直接完成这个要求力量值最小的任务 如果没有可以直接完成的任务，那么这个worker必须要吃药，如果没有药了就立即失败。有药的情况下，反正要从当前可选任务中选一个，那么选要求力量值最大的任务比较划算 当然，如果吃了药也没有能完成的任务，也直接失败 这里可以利用的一点是药增加的力量值是个固定值，因而随着worker力量增加，可选任务范围是固定增加的，任务永远按照从小到大的顺序添加到可选任务范围中；而从可选任务范围中移除任务时，要么移除当前最小，要么移除当前最大，因而可以用一个双端可以移除的单调队列来实现，这样就可以做到O(n)复杂度了，整体复杂度也就被控制到了O(nlogn) 动态规划 + 单调队列优化 + 推导难 ★★★★★从仓库到码头运输箱子 你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 箱子数目的限制 和 总重量的限制 。 给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和 maxWeight ，其中 boxes[i] = [ports​​i​, weighti] 。 ports​​i 表示第 i 个箱子需要送达的码头， weightsi 是第 i 个箱子的重量。 portsCount 是码头的数目。 maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。 箱子需要按照 数组顺序 运输，同时每次运输需要遵循以下步骤： 卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。 对于在卡车上的箱子，我们需要 按顺序 处理它们，卡车会通过 一趟行程 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 额外行程 ，箱子也会立马被卸货。 卡车上所有箱子都被卸货后，卡车需要 一趟行程 回到仓库，从箱子队列里再取出一些箱子。 卡车在将所有箱子运输并卸货后，最后必须回到仓库。 请你返回将所有箱子送到相应码头的 最少行程 次数。 解： 推导很666啊 class Solution { public: int boxDelivering(vector>& boxes, int portsCount, int maxBoxes, int maxWeight) { int n=boxes.size(),head=0,tail=0; vectorq(n+5),f(n+5); vectorW(n+5),neg(n+5); f[0]=q[0]=W[0]=0; for(int i=1,j;imaxBoxes || W[i]-W[q[head]]>maxWeight)) head++; //动态规划，状态转移 j=q[head],f[i]=f[j]+neg[i]-neg[j+1]+2; //最优化剪枝，即：维护单调队列 while(head 旅行问题 给定一个 环，环 上有 n 个节点，编号从 1∼n，以及一辆小车车 每一个 节点 i 有一个 权值 pi 表示当车 到达该点 时，可以 获得 的 油量 还有一个 权值 di 表示当车从 节点 i 到 节点 i+1 所需要 消耗 的 油量 现有一辆车想从环上 任意点 出发，顺时针 或 逆时针 绕环一圈走回起点 行驶的过程中，油量不能为 负数，初始油量 为 起点 处所能获得的 油量 判断能否完成 环圈行驶 解： 看到 环形问题，就会想到在先前 环形区间DP 中提到的一个解决方法：拉环成链 复制 一份数组接在 原数组 后面，这样原问题就 等价于 在 新数组 中 存在 长度为 n+1 的 合法区间 然后考虑区间何时 合法 的问题，题中提及： 1.会先在一个点 获得油量 2.然后 消耗油量 到达下一个点 3.消耗后的油量 不能小于 0 这极像一个我们熟悉的 括号序列模型 — 任意 前缀区间 必然满足 左括号数≥右括号数 故想到用 前缀和思想 来分析：该 区间 如果 合法，则必然 任意前缀 获得油量 ≥ 消耗油量 这里我们要 明确 每个数组下标的实际含义，才能调对本题的 边界，不然会 WA 疯 #include #include #include using namespace std; typedef long long LL; const int N = 1e6 + 10, M = N n) hh ++ ; if (i > n) if (get_val1(i - n, que[hh]) >= 0) f[i - n] = true; while (hh = g(i)) tt -- ; que[ ++ tt] = i; } hh = 0, tt = -1; for (int i = n n) hh ++ ; if (i = 0) f[i] = true; while (hh = h(i)) tt -- ; que[ ++ tt] = i; } for (int i = 1; i 其中一个比较简单的例题： 滑动窗口+两个单调队列 ★★★★★D-绝对差不超过限制的最长连续子数组 题目： 给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。 如果不存在满足条件的子数组，则返回 0 题解： O(nlogn) - 滑动窗口+哈希 O(n) - 滑动窗口+两个单调队列 deque版本class Solution { public: int longestSubarray(vector& nums, int limit) { deque queMax, queMin; int n = nums.size(); int left = 0, right = 0; int ret = 0; while (right nums[right]) { queMin.pop_back(); } queMax.push_back(nums[right]); queMin.push_back(nums[right]); while (!queMax.empty() && !queMin.empty() && queMax.front() - queMin.front() > limit) { if (nums[left] == queMin.front()) { queMin.pop_front(); } if (nums[left] == queMax.front()) { queMax.pop_front(); } left++; } ret = max(ret, right - left + 1); right++; } return ret; } }; 手动实现版本class Solution { static const int N = 100010; int p[N], q[N], phh = 0, ptt = -1, qhh = 0, qtt = -1; // p 维护最大值， 单调递减队列 q 维护最小值，单调递增队列 public: int longestSubarray(vector& nums, int limit) { int res = 1, n = nums.size(); for(int i = 0, j = 0; j nums[j]) qtt--; q[++ qtt] = j; while(phh limit){ // phh ++; qhh ++; if(nums[p[phh]] == nums[i]) phh ++; if(nums[q[qhh]] == nums[i]) qhh ++; i ++; } res = max(res, j - i + 1); } return res; } }; 10 斜率优化DP 11 基环树DP 12 四边形不等式优化 13 插头DP 14 其他 kadane算法 对于一个给定数组 A，Kadane 算法可以用来找到 A 的最大子段和。 ★★★★环形子数组的最大和 解法 法1： kadane 法2：两种情况分类讨论后，将问题进行转化 最大的环形子数组和 = max(最大子数组和，数组总和-最小子数组和) 对于环形数组，分两种情况。 (1)答案在数组中间，就是最大子序和。例如[1,-2,3,-2]； (2)答案在数组两边，例如[5,-3,5]最大的子序和就等于数组的总和SUM-最小的子序和。(一种特殊情况是数组全为负数，也就是SUM-最小子序和==0，最大子序和等于数组中最大的那个)。 状态定义与转移 连续子数组属性 乘积为正数的最长子数组长度 给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。 一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。 请你返回乘积为正数的最长子数组长度。 示例 1： 输入：nums = [1,-2,-3,4] 输出：4 解释：数组本身乘积就是正数，值为 24 。 示例 2： 输入：nums = [0,1,-2,-3,-4] 输出：3 解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。 注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。 示例 3： 输入：nums = [-1,-2,-3,0,1] 输出：2 解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。 即： 定义 dpP[i]包含nums[i]的，乘机为正的最长子数组的长度， dpN[i]包含nums[i]的，乘机为负的最长子数组的长度， 只有当nums[i]为负数的时候，才会改变乘积的符号； - nums[i] > 0, 不改变符号， dpP[i] = dpP[i-1]+1; dpN[i] = dpN[i-1] == 0 ? 0 : dpN[i-1]+1; - nums[i] 代码 class Solution { public: int getMaxLen(vector& nums) { int length = nums.size(); vector positive(length), negative(length); if (nums[0] > 0) { positive[0] = 1; } else if (nums[0] 0) { positive[i] = positive[i - 1] + 1; negative[i] = (negative[i - 1] > 0 ? negative[i - 1] + 1 : 0); } else if (nums[i] 0 ? negative[i - 1] + 1 : 0); negative[i] = positive[i - 1] + 1; } else { positive[i] = 0; negative[i] = 0; } maxLength = max(maxLength, positive[i]); } return maxLength; } }; 滚动数组 class Solution { public: int getMaxLen(vector& nums) { int length = nums.size(); int positive = (nums[0] > 0); int negative = (nums[0] 0) { ++positive; negative = (negative > 0 ? negative + 1 : 0); } else if (nums[i] 0 ? negative + 1 : 0; int newNegative = positive + 1; tie(positive, negative) = {newPositive, newNegative}; } else { positive = negative = 0; } maxLength = max(maxLength, positive); } return maxLength; } }; 同理(美团T2)求乘积为整数的连续子数组的数量，其中每个元素为-1和1. Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2023-01-13 16:22:46 "},"01_数据结构与算法笔记/01_学习笔记/06_图论.html":{"url":"01_数据结构与算法笔记/01_学习笔记/06_图论.html","title":"1.6 图论","keywords":"","body":"图论 0 图论基础 1 树与图的存储 树是一种特殊的图，与图的存储方式相同。 对于无向图中的边ab，存储两条有向边a->b, b->a。 因此我们可以只考虑有向图的存储。 邻接矩阵 g[x,y]=w; 邻接表 -> 没有顺序性，头插一个节点即可 V 1:-> (3) -> (4) -> () V 2:-> (1) -> (4) ->() V 3:-> (4) -> () V 4:-> () (1) 邻接矩阵：g[a][b] 存储边a->b (2) 邻接表： // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a->b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); 注意： dijkstra用邻接矩阵存的时候还需要处理下重边，如果用邻接表存就不用处理了。 原因是：矩阵1个边只能有1个值，类似g[i][j]=123,所以要处理一下，保证存的是最小值，但邻接表重边也可以存多次，在算法里保证最小就可以了。 2 树与图的遍历 时间复杂度 O(n+m), n 表示点数，m 表示边数 (1) 深度优先遍历 树的重心 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } (2) 宽度优先遍历 图中点的层次 queue q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } } 3 概述 一、最短路 单源最短路 所有边权都是正数 朴素Dijkstra O(n^2) 用于稠密图 堆优化版Dijkstra O(mlogn) 用于稀疏图 因为边多了也会达到m=n^2 ??,反而更大了 存在负权边 Bellman-Ford O(mn) 用于不超过k条边 SPFA 一般O(m) 最坏O(mn)(即如果不卡数据，可以求用Dijkstra解的题目。但卡的话，还是用堆优化的Dijkstra。) 多源汇最短路 Floyd算法 O(n^3) 基于动态规划 拓展： 次短路 边权为1 bfs 边权不为1 其他 如Dijkstra 第k短路 - 虚拟源点 用于解决多源点到一个终点最短路问题(下题也可以用反向边，即把终点做为起点，各源点作为目标点，但用虚拟源点可扩展为m个源点到n个终点的最短路) 选择最佳线路 分层 最短路求方案数 最短路计数(最短路求方案数) 因为要求的是方案数，因此我们在求最短路中的dist[]时，还要再额外维护一个cnt[]数组来记录最短路的方案数。 当dist[v]>dist[u]+d[u][v]时，cnt[v]的值即为cnt[u]的值（因为v点最短距离是由u点的最短距离更新而来）。 dist[v]==dist[u]+d[u][v]时，cnt[v]的值要再加上cnt[u]的值（v点的最短距离的路线多了一个u的路径）。 以上就是cnt[]数组的求法了。 此外还需要注意一个问题：在求cnt[v]时，必须要保证cnt[u]上的值已经为最终的结果了（即计算过程需要满足拓扑序）。因此，我们不能够用spfa算法来求解这道题。所以我们需要用bfs或dijkstra算法来求解这道题（bfs和dijkstra都是满足拓扑序的）。而这道题的边没有权值，因此我们可以用bfs。 汇总思路 Dijkstra-朴素 O(n^2) 利用邻接矩阵。初始化距离数组, dist[1] = 0, dist[i] = inf; for n次循环 每次循环确定一个min加入S集合中，n次之后就得出所有的最短距离 将不在S中dist_min的点->t t->S加入最短路集合 用t更新到其他点的距离 Dijkstra-堆优化 O(mlogm) 利用邻接表，优先队列 在priority_queue,greater> heap;中将返回堆顶 利用堆顶来更新其他点，并加入堆中类似宽搜 Bellman_ford O(nm) 利用边数组。注意若不超过k次时由于串联需要备份,struct Edge{inta,b,c} Edge[M]; 初始化dist, 松弛dist[x.b] = min(dist[x.b], backup[x.a]+x.w); 松弛k次，每次访问m条边 Spfa O(n)~O(nm) 利用队列优化仅加入修改过的地方。st数组在队列里的j，区别于以上Dijkstra中的st表示已求得最小值。 for k次 for 所有边利用宽搜模型去优化bellman_ford算法 更新队列中当前点的所有出边 Floyd O(n^3) 初始化d k, i, j 去更新d 二、最小生成树 不一定唯一，但最小值一定 Prim算法 (Dijkstra相似) 用邻接矩阵存 朴素Prim O(n^2) 基于贪心 堆优化 O(mlogn) Kruskal算法 O(mlogm) 用(a,b,w)存 三、二分图 染色法 O(m+n) 匈牙利算法 O(mn) 实际运行时间一般远小于O(mn) 1 最短路问题 汇总细节 使用何种结构存储图。 一是考虑数据范围，二是考虑算法。 稀疏图通常用邻接表，稠密图通常用邻接矩阵； bellman-ford每次要遍历所有边所以用结构体方便，而spfa每次要更新队头点所连所有边，用邻接表方便。 1 朴素Dijkstra Dijkstra求最短路 I 迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。 Article:Dijkstra求最短路 I：图解 详细代码（图解 步骤： 初始化dist[i]=0x3f3f3f3f;dist[1]=0, state 已确定最短距离的点 for 1:n -> O(n) 寻找不在s中，且距离源点最近的点t O(n) 将t加入到s中，即state[t]=true; 用t更新 到其他点的距离 O(n) 常见问题合集 for(int i=0;i 如果是问编号a到b的最短距离该怎么改呢? （好问题） 回答： 初始化时将 dist[a]=0,以及返回时return dist[b]。 自环和重边对 Dijkstrea算法有影响吗？ 回答： 自环在朴素版dijkstra算法中是没有任何影响的，所以自环的权值是多少都可以，只要不是负数就行。而重边时，我们去取重边中的最小值 即代码g[x][y]=min(g[x][y],z)。而用邻接表时，重边没问题。 为什么要用邻接矩阵去存贮，而不是邻接表？ 回答： 我们采用邻接矩阵还是采用邻接表来表示图，需要判断一个图是稀疏图还是稠密图。稠密图指的是边的条数|E|接近于|V|²，稀疏图是指边的条数|E|远小于于|V|²（数量级差很多）。本题是稠密图，显然稠密图用邻接矩阵存储比较节省空间，反之用邻接表存储。 为什么不能用于求负权边的最短路？ 首先：Dijkstra算法的3个步骤 1、找到当前未标识的且离源点最近的点t 2、对t号点点进行标识 3、用t号点更新其他点的距离 结果： dijkstra算法在图中走出来的最短路径是1 -> 2 -> 4 -> 5，算出 1 号点到 5 号点的最短距离是2 + 2 + 1 = 5，然而还存在一条路径是1 -> 3 -> 4 -> 5，该路径的长度是5 + (-2) + 1 = 4，因此 dijkstra 算法失效 dijkstra详细步骤 初始dist[1] = 0 找到了未标识且离源点1最近的结点1，标记1号点，用1号点更新其他所有点的距离，2号点被更新成dist[2] = 2，3号点被更新成dist[3] = 5 找到了未标识且离源点1最近的结点2，标识2号点，用2号点更新其他所有点的距离，4号点被更新成dist[4] = 4 找到了未标识且离源点1最近的结点4，标识4号点，用4号点更新其他所有点的距离，5号点被更新成dist[5] = 5 找到了未标识且离源点1最近的结点3，标识3号点，用3号点更新其他所有点的距离，4号点被更新成dist[4] = 3 结束 得到1号点到5号点的最短距离是5，对应的路径是1 -> 2 -> 4 -> 5，并不是真正的最短距离。 Dijkstra代码： 时间复杂是 O(n2+m), n 表示点数，m 表示边数 int g[N][N]; // 存储每条边 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j 2 堆优化Dijkstra Dijkstra求最短路 II 时间复杂度 O(mlogn), n 表示点数，m 表示边数 typedef pair PII; int n; // 点的数量 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储所有点到1号点的距离 bool st[N]; // 存储每个点的最短距离是否已确定 // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue, greater> heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 3 Bellman-Ford算法 有边数限制的最短路 Article:有边数限制的最短路 Bellman - ford 算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。 (通俗的来讲就是：假设 1 号点到 n 号点是可达的，每一个点同时向指向的方向出发，更新相邻的点的最短距离，通过循环 n-1 次操作，若图中不存在负环，则 1 号点一定会到达 n 号点，若图中存在负环，则在 n-1 次松弛后一定还会更新) 应用于存在负权边的最短路问题，但并不一定存在最短路，如成环值为负，即负权回路(负环)。当然存在负权回路也可能存在最短路，即该回路不在到达终点所经过的路上。 这种情况下，想要存在最短路，需要限制步数k。要不然就不能成环。 bellman_ford算法 1)初始化所有点到源点的距离为∞,把源点到自己的距离设置为0； 2)不管3721遍历n次;每次遍历m条边，用每一条边去更新各点到源点的距离。 值得注意的是 1) 需要把dist数组进行一个备份，这样防止每次更新的时候出现串联； 2) 由于存在负权边，因此return -1的条件就要改成dist[n]>0x3f3f3f3f/2; 3) 上面所谓的n次遍历的实际含义是当前的最短路径最多有n-1条边，这也就解释了为啥要i遍历到n的时候退出循环了，因为只有n个点,最短路径无环最多就存在n-1条边。 4) 这里无需对重边和自环做单独的处理： 1] 重边：由于遍历了所有的边，总会遍历到较短的那一条; 2] 自环: 有自环就有自环啊，反正又不会死循环; 5) 令人愉悦的是，该算法无非就是循环n次然后遍历所有的边，因此不需要做什么特别的存储，只要把所有的边的信息存下来能够遍历就行; 6）bellman_ford算法可以存在负权回路，因为它求得的最短路是有限制的，是限制了边数的，这样不会永久的走下去，会得到一个解； 7)SPFA算法各方面优于该算法，但是在碰到限制了最短路径上边的长度时就只能用bellman_ford了，此时直接把n重循环改成k次循环即可 for n次 for 所有边 a,b,w dist[b] = min(dist[b], dist[a]+w) // 松弛操作 // 最终可计算得到任意边 满足三角不等式 : dist[b] 如果对次数进行限制， for n次 for 所有边 a,b,w (松弛操作) dist[b] = min(dist[b],backup[a] + w) 注意：backup[] 数组是上一次迭代后 dist[] 数组的备份，由于是每个点同时向外出发，因此需要对 dist[] 数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点 时间复杂度 O(nm), n 表示点数，m 表示边数 注意在模板题中(对k条边进行限制)需要对下面的模板稍作修改，加上备份数组，详情见模板题。 // 对所经过的边数不加限制不用备份 int n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i dist[a] + w) dist[b] = dist[a] + w; // dist[b] = min(dist[b], dist[a] + w); } } // 防止到达不了终点，但dist也被更新成了一个比初始值稍小的数。// 所以没用dist[n]==0x3f3f3f3f; if (dist[n] > 0x3f3f3f3f / 2) return -1; return dist[n]; } 备份dist数组 如果对所经过的边数加以限制，则为了防止串联，需要在k次循环中，对上一循环的dist进行备份。防止用更新过的dist计算新的dist，而只新计入一次边。导致所计算出的距离其实经过的边多于k次，不满足要求。 可理解为动态规划的滚动数组优化，如01背包时的降序就是防止某个物品拿多次。 如下题中可用dp解法。 787. K 站中转内最便宜的航班 解法中bellman-ford可求解此类带限制次数的题。本质还是动态规划。 也可用bfs等其他方法做。 具体： 为了避免如下的串联情况， 在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2。 正确做法是用上轮节点2更新的距离--无穷大，来更新节点3， 再取最小值，所以节点3离起点的距离是3。 #include #include using namespace std; const int N = 510, M = 10010; struct Edge { int a; int b; int w; } e[M];//把每个边保存下来即可 int dist[N]; int back[N];//备份数组防止串联 int n, m, k;//k代表最短路径最多包涵k条边 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i 0x3f3f3f3f / 2) return -1; else return dist[n]; } int main() { scanf(\"%d%d%d\", &n, &m, &k); for (int i = 0; i 4 spfa 算法 （队列优化的Bellman-Ford算法） spfa求最短路 注意：能用dijkstra的就别用spfa。 spfa只会更新所有能从起点走到的点，所以如果无解，那么起点就走不到终点，那么终点的距离就是0x3f3f3f3f。 详解： SPFA算法仅仅只是对Bellman-Ford算法的一个优化。 Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。 值得注意的是 1) st数组的作用：判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。 即便不使用st数组最终也没有什么关系，但是使用的好处在于可以提升效率。 2) SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的: 1] Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。 2] Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。 3]注意由于入队的问题，在出队的时候取出节点，但不要用队列中出队的pair对应值，而是从dist中重新获取最新的值，因为入队时的值可能并非最新值 3) ⭐️Bellman_ford算法里最后return-1的判断条件写的是dist[n]>0x3f3f3f3f/2;而spfa算法写的是dist[n]==0x3f3f3f3f;其原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。 4) ⭐️ Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。 5) ⭐️由于SPFA算法是由Bellman_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为 O(nm)，假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?) 6) ⭐️求负环一般使用SPFA算法，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环。 时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数 int n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 如果采用如下方式入队pair #include #include #include using namespace std; const int N = 1e5 + 10; #define fi first #define se second typedef pair PII; int h[N], e[N], w[N], ne[N], idx = 0; int dist[N]; bool st[N]; int n, m; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++; } int spfa() { memset(dist, 0x3f, sizeof dist); queue q; dist[1] = 0; q.push({0,1}); st[1] = true; while(q.size()){ auto t = q.front(); q.pop(); int node = t.se, d = t.fi; // d 和 dist[node] 有区别！！！ st[node] = false; //从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队 for(int i = h[node]; i != -1; i = ne[i]){ int j = e[i]; if(dist[j] > dist[node] + w[i]){ // 不用d，而用最新的dist[node] dist[j] = dist[node] + w[i]; if(!st[j]){ //当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率 st[j] = true; q.push({dist[j], j}); // cout > n >> m; memset(h, - 1, sizeof h); while(m -- ){ int a, b, c; cin >> a >> b >> c; add(a, b, c); } int res = spfa(); if(res == 0x3f3f3f3f) puts(\"impossible\"); else printf(\"%d\", res); return 0; } 负环 spfa判断负环 有负权回路的话，spfa可能会陷入死循环。处理方式：加一个节点计数数组可以解决负环问题 每次做一遍spfa()一定是正确的，但时间复杂度较高，可能会超时。初始时将所有点插入队列中可以按如下方式理解： 在原图的基础上新建一个虚拟源点，从该点向其他所有点连一条权值为0的有向边。那么原图有负环等价于新图有负环。此时在新图上做spfa，将虚拟源点加入队列中。然后进行spfa的第一次迭代，这时会将所有点的距离更新并将所有点插入队列中。执行到这一步，就等价于视频中的做法了。那么视频中的做法可以找到负环，等价于这次spfa可以找到负环，等价于新图有负环，等价于原图有负环。得证。 1、dist[x] 记录虚拟源点到x的最短距离 2、cnt[x] 记录当前x点到虚拟源点最短路的边数，初始每个点到虚拟源点的距离为0，只要他能再走n步，即cnt[x] >= n，则表示该图中一定存在负环，由于从虚拟源点到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用 3、若dist[j] > dist[t] + w[i],则表示从t点走到j点能够让权值变少，因此进行对该点j进行更新，并且对应cnt[j] = cnt[t] + 1,往前走一步 注意：该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点 时间复杂度是 O(nm), n 表示点数，m 表示边数 int n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的边数 bool st[N]; // 存储每个点是否在队列中 ！！！ // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 // 原理：即如果某条最短路径上有n个边存在环。 queue q; for (int i = 1; i dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] >= n) return true; // 如果从1号点到x的最短路中包含至少n个边，则说明存在环 if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } 5 floyd算法 Floyd求最短路 可用于求有负权边的图，但不能存在负环。 最短路(多源汇) 传递闭包 找最小环 恰好经过k条边的最短路 倍增 思路： 基于动态规划01背包，从三维空间优化成了二维空间。 三维： f[i, j, k]表示从i走到j的路径上除i和j点外只经过1到k的点的所有路径的最短距离。那么f[i, j, k] = min(f[i, j, k - 1), f[i, k, k - 1] + f[k, j, k - 1]。 因此在计算第k层的f[i, j]的时候必须先将第k - 1层的所有状态计算出来，所以需要把k放在最外层。 读入邻接矩阵，将次通过动态规划装换成从i到j的最短距离矩阵 如存在负权边，则在代码中，判断从a到b是否是无穷大距离时，需要进行if(t > INF/2)判断，而并非是if(t == INF)判断，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，t大于某个与INF相同数量级的数即可 证明： 时间复杂度是 O(n3) , n 表示点数 //初始化： for (int i = 1; i 2 最小生成树 给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。 定理： 对于一张无向图，如果存在最小生成树和（严格）次小生成树，那么对于任何一棵最小生成树，都存在一棵(严格)次小生成树与其只有一条边不同。 1 prim算法 prim 算法采用的是一种贪心的策略。 每次将离连通部分的最近的点和点对应的边加入到连通部分，连通部分逐渐扩大，最后将整个图连通起来，并且边长之和最小。 证明： 思路 ： 当前外界与 证明 ： 如果不按上述选最小的边，则会产生环。... 如何证明当前这条边一定可以被选？ 假设不选当前编码，最终得到了一棵树。然后将这条边加上，那么必然会出现一个环， Article:Prim算法求最小生成树：图解+详细代码注释(带上了保存路径) 我们将图中各个节点用数字 1 ~ n 编号。 要将所有景点连通起来，并且边长之和最小，步骤如下： 用一个state 数组表示节点是否已经连通。state[i] 为真，表示已经连通，state[i] 为假，表示还没有连通。初始时，state 各个元素为假。即所有点还没有连通。 用一个 dist 数组保存各个点到连通部分的最短距离，dist[i] 表示 i 节点到连通部分的最短距离。初始时，dist 数组的各个元素为无穷大。 用一个 pre 数组保存节点的是和谁连通的。pre[i] = k 表示节点 i 和节点 k 之间需要有一条边。初始时，pre 的各个元素置为 -1。 从 1 号节点开始扩充连通的部分，所以 1 号节点与连通部分的最短距离为 0，即disti[1] 置为 0。 遍历 dist 数组，找到一个还没有连通起来，但是距离连通部分最近的点，假设该节点的编号是 i。i节点就是下一个应该加入连通部分的节点，stata[i] 置为 1。 用青色点表示还没有连通起来的点，红色点表示连通起来的点。 这里青色点中距离最小的是 dist[1]，因此 state[1] 置为 1。 遍历所有与 i 相连但没有加入到连通部分的点 j，如果 j 距离连通部分的距离大于 i j 之间的距离，即 dist[j] > w[i][j]（w[i][j] 为 i j 节点之间的距离），则更新 dist[j] 为 w[i][j]。这时候表示，j 到连通部分的最短方式是和 i 相连，因此，更新pre[j] = i。 与节点 1 相连的有 2， 3， 4 号节点。1->2 的距离为 100，小于 dist[2]，dist[2] 更新为 100，pre[2] 更新为1。1->4 的距离为 140，小于 dist[4]，dist[4] 更新为 140，pre[2] 更新为1。1->3 的距离为 150，小于 dist[3]，dist[3] 更新为 150，pre[3] 更新为1。 重复 3 4步骤，直到所有节点的状态都被置为 1. 这里青色点中距离最小的是 dist[2]，因此 state[2] 置为 1。 与节点 2 相连的有 5， 4号节点。2->5 的距离为 80，小于 dist[5]，dist[5] 更新为 80，pre[5] 更新为 2。2->4 的距离为 80，小于 dist[4]，dist[4] 更新为 80，pre[4] 更新为2。 选dist[4]，更新dist[3]，dist[5]，pre[3]，pre[5]。 选dist[5]，没有可更新的。 选dist[3]，没有可更新的。 此时 dist 数组中保存了各个节点需要修的路长，加起来就是。pre 数组中保存了需要选择的边。 int dist[n],state[n],pre[n]; dist[1] = 0; for(i : 1 ~ n) { t 朴素版prim算法Prim算法求最小生成树 和Dijkstra的代码特别像。 联系：Dijkstra算法是更新到起始点的距离，Prim是更新到集合S的距离 时间复杂度是 O(n2+m), n 表示点数，m 表示边数 int n; // n表示点数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 const int N = 510, INF = 0x3f3f3f3f; // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; dist[1] = 0; // 找一个源点，！！但此时还未加入！！，用于第一个循环中更新t for (int i = 0; i dist[j])) t = j; if (i && dist[t] == INF) return INF; // 不连通 if (i) res += dist[t]; // ！！！ st[t] = true; // 此时才算加入 for (int j = 1; j 堆优化prim略，一般用不到，对于稀疏图用Kruskal更佳 最低成本联通所有城市 若用prim需用堆优化版本。 2 Kruskal算法 Kruskal算法求最小生成树 拓展水资源分配优化(kruskal+虚拟超级源点) 用于稀疏图 将所有边按权重从小到大排序 O(mlogm) 枚举每条边，a,b,w O(m) if a,b不连通 将a,b边加入集合中 注意 1）类似并查集。 2）需要使用变量cnt记录加进集合的边数，若cnt表示不能遍历所有点 时间复杂度是 O(mlogm), n 表示点数，m 表示边数 int n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 struct Edge // 存储边 { int a, b, w; bool operator 3 拓扑排序 有向无环图一定存在入度为0的点，因此可以形成拓扑序列。 反证：如果每个节点入度都不为0，则... 拓扑序列：针对有向无环图（DAG）(Directed Acyclic Graph简称DAG)来说。 用来判断是否存在环。 不唯一 方法：bfs 入度 出度统计 bfs queue j 删除t->j,d[j]--; if(d[j]==0) queue 时间复杂度 O(n+m) , n 表示点数，m 表示边数 用手写队列实现 bool topsort() { int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i 方法：dfs 需要遍历，并且每个节点有三种状态，0(为开始搜索),1(正在搜索),2(已完成搜索) 课程表 课程表2 重建序列 4 二分图 二分图当且仅当图中不含奇数环 充分性：由于图中不含奇数环，所有染色过程中一定没有矛盾。 必要性: A(0)->1 -> 0->1->A(0) 1 染色法判别二分图 染色法判定二分图 染色法 将所有点分成两个集合，使得所有边只出现在集合之间，就是二分图 二分图：一定不含有奇数环，可能包含长度为偶数的环， 不一定是连通图 dfs版本 代码思路： 染色可以使用1和2区分不同颜色，用0表示未染色 遍历所有点，每次将未染色的点进行dfs, 默认染成1或者2 由于某个点染色成功不代表整个图就是二分图,因此只有某个点染色失败才能立刻break/return 染色失败相当于存在相邻的2个点染了相同的颜色 #include #include #include using namespace std; const int N = 1e5 + 10, M = 2e5 + 10; // 无向图, 所以最大边数是2倍 int e[M], ne[M], h[N], idx; int st[N]; void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } bool dfs(int u, int color) { st[u] = color; for(int i = h[u]; i != -1; i = ne[i]){ int j = e[i]; if(!st[j]) { if(!dfs(j, 3 - color)) return false; }else if(st[j] == color) return false; } return true; } int main(){ int n, m; scanf(\"%d%d\", &n, &m); memset(h, -1, sizeof h); while (m --){ int a, b; scanf(\"%d%d\", &a, &b); add(a, b), add(b,a); // 无向图 } bool flag = true; for(int i = 1; i bfs版本 代码思路 颜色 1 和 2 表示不同颜色, 0 表示 未染色 定义queue是存PII，表示 , 同理，遍历所有点, 将未染色的点都进行bfs 队列初始化将第i个点入队, 默认颜色可以是1或2 -while (队列不空) -每次获取队头t, 并遍历队头t的所有邻边 -若邻边的点未染色则染上与队头t相反的颜色，并添加到队列 -若邻边的点已经染色且与队头t的颜色相同, 则返回false #include #include #include using namespace std; const int N = 1e5 + 10, M = 2e5 + 10; typedef pair PII; int e[M], ne[M], h[N], idx; int n, m; int st[N]; void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } bool bfs(int u){ int hh = 0, tt = 0; PII q[N]; q[0] = {u, 1}; st[u] = 1; while(hh 总结：对于第一次被遍历还未被染色的点，进行互斥染色。对于已经染色的，要检验合法性。 以下为模板： 时间复杂度是 O(n+m), n 表示点数，m 表示边数 int n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i 2 匈牙利算法 二分图的最大匹配 另见基本算法中贪心部分。 趣写算法系列之--匈牙利算法 什么是最大匹配？ 要了解匈牙利算法必须先理解下面的概念： 匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。 下面是一些补充概念： 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替 路称为增广路（agumenting path）。 时间复杂度是 O(nm), n 表示点数，m 表示边数 int n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数 int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边 int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i 代码中st数组作用： 每次循环都重置 st数组用来保证本次匹配过程中，第二个集合中的每个点只被遍历一次，防止死循环。match存的是第二个集合中的每个点当前匹配的点是哪个，但就算某个点当前已经匹配了某个点，也有可能被再次遍历，所以不能起到判重的作用。 st数组可以理解为预定数组，即某一轮中某个女孩是不是被男生预定了。如果find函数递归下去能够帮心仪对象的对象找到备胎，那皆大欢喜，所有这一轮预定的姑娘被match对应的男孩（回溯）。如果找不到备胎，那这些预定姑娘就保持不动。 -没有st数组会导致爆栈。举个简单例子：左1、左2都指向右1，执行find(1)后会使得match[1] = 1，接着执行find(2)时，需执行find(1)，find(1)又需执行find(1)，如此进入了死循环，导致爆栈。 补充一下证明： 1) 匈牙利算法中，一个有伴侣的人，无论男女，不会重新变成单身。 2) 若我们尝试给一个有对象的女生换个对象，如果成功，整个交换链条终止于一个单身女性。 由2)可知，调整对象失败则代表由该女生作为起点的生成树内已无单身女性。 由1)可知，以该女生作为起点的生成树不会凭空出现单身女性。 3 KM算法 OI Wiki二分图最大权匹配 km算法入门 ?? KM算法详解+模板 KM算法用来求二分图最大权完美匹配。 二分图的最大权匹配是指二分图中边权和最大的匹配。 Hungarian Algorithm（Kuhn-Munkres Algorithm）¶ 匈牙利算法又称为 KM 算法，可以在 O(n^3) 时间内求出二分图的 最大权完美匹配。 考虑到二分图中两个集合中的点并不总是相同，为了能应用 KM 算法解决二分图的最大权匹配，需要先作如下处理：将两个集合中点数比较少的补点，使得两边点数相同，再将不存在的边权重设为 ，这种情况下，问题就转换成求 最大权完美匹配问题，从而能应用 KM 算法求解。 以D-数组的最大与和为例。 (详情见 动态规划状压dp 部分提供六种解法 - 状态DP - 三进制- 最小费用最大流- 模拟退火- 贪心- KM) KM算法本质上在匈牙利算法的基础上增加期望度机制。 初始化左半图每个number的期望度为该number最大可获得权值，右半图每个slot的期望度为0。 每次匹配时，只考虑边权等于相连number和slot期望度和的边。 当一次匹配中无法成功时，执行期望度更新操作：将涉及的所有number期望度减一、所有slot期望度加一。 可行性： 相当于限制了参与搜索的边的集合，使得权值较大的边能被优先搜索，保证了算法可行的充分性。 每次降低期望度时，将本次搜索中左半图所有点期望度减1、右半图所有点期望度加1。每次降低期望度时，设涉及到的左半图点个数为n_1，则涉及到的右半图点个数为n_1-1（不搜第n_1 个左半图点时恰好匹配，而加入该点后不匹配，因此相关左半图点刚好比相关右半图点多一个）。 对已被匹配的边而言，对应左半图点期望度减1，右半图点期望度加1，故这些边仍然在被搜索的边集合中。期望度更新操作后，每个左半图点相关的权值稍小的边被加入搜索集中。由于更新时以1为粒度，所以能保证搜索过程中不会漏掉边，保证了算法可行的必要性。 模板： 背景:现在有N男N女，有些男生和女生之间互相有好感，我们将其好感程度定义为好感度，我们希望把他们两两配对，并且最后希望好感度和最大。 #include #include #include using namespace std; const int MAXN = 305; const int INF = 0x3f3f3f3f; int love[MAXN][MAXN]; // 记录每个妹子和每个男生的好感度 int ex_girl[MAXN]; // 每个妹子的期望值 int ex_boy[MAXN]; // 每个男生的期望值 bool vis_girl[MAXN]; // 记录每一轮匹配匹配过的女生 bool vis_boy[MAXN]; // 记录每一轮匹配匹配过的男生 int match[MAXN]; // 记录每个男生匹配到的妹子 如果没有则为-1 int slack[MAXN]; // 记录每个汉子如果能被妹子倾心最少还需要多少期望值 int N; bool dfs(int girl) { vis_girl[girl] = true; for (int boy = 0; boy 基础题： 最大兼容性评分和 有一份由 n 个问题组成的调查问卷，每个问题的答案要么是 0（no，否），要么是 1（yes，是）。 这份调查问卷被分发给 m 名学生和 m 名导师，学生和导师的编号都是从 0 到 m - 1 。学生的答案用一个二维整数数组 students 表示，其中 students[i] 是一个整数数组，包含第 i 名学生对调查问卷给出的答案（下标从 0 开始）。导师的答案用一个二维整数数组 mentors 表示，其中 mentors[j] 是一个整数数组，包含第 j 名导师对调查问卷给出的答案（下标从 0 开始）。 每个学生都会被分配给 一名 导师，而每位导师也会分配到 一名 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。 例如，学生答案为[1, 0, 1] 而导师答案为 [0, 0, 1] ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。 请你找出最优的学生与导师的配对方案，以 最大程度上 提高 兼容性评分和 。 给你 students 和 mentors ，返回可以得到的 最大兼容性评分和 。 示例 1： 输入：students = [ [1,1,0],[1,0,1],[0,0,1] ], mentors = [ [1,0,0],[0,0,1],[1,1,0] ] 输出：8 解释：按下述方式分配学生和导师： -学生 0 分配给导师 2 ，兼容性评分为 3 。 -学生 1 分配给导师 0 ，兼容性评分为 2 。 -学生 2 分配给导师 1 ，兼容性评分为 3 。 最大兼容性评分和为 3 + 2 + 3 = 8 。 示例 2： 输入：students = [ [0,0],[0,0],[0,0]] , mentors = [ [1,1],[1,1],[1,1] ] 输出：0 解释：任意学生与导师配对的兼容性评分都是 0 。 提示： m == students.length == mentors.length n == students[i].length == mentors[j].length 1 解： 枚举 状压dp 对状态转移方程的理解：mask决定了两个信息，分配的学生个数和可供匹配的老师编号。对于编号c-1学生来说，可供选择的老师编号就是mask二进制为1的位置，所以枚举所有1位置，并将该位置0得到上一个状态 mask\\i ，此状态包含学生[0,..,c-2]和不含该位置的c-1个老师。所以状态转移方程为 f[mask] = max(f[mask\\i] + g[c - 1][i]) class Solution { public: int maxCompatibilitySum(vector>& students, vector>& mentors) { int m = students.size(); int n = students[0].size(); vector> g(m, vector(m)); for (int i = 0; i j的评分 } } } vector f(1 km class Solution { public: int maxCompatibilitySum(vector>& students, vector>& mentors) { int n = students.size(); vector> c(n, vector(n, 0)); // student[i]与teacher[j]的兼容性 for (int i = 0; i >& c) { vector match(n, -1); // match[i]为teacher[i]匹配的student编号 vector exStudent(n); // student的期望 vector exTeacher(n, 0); // teacher的期望 for (int i = 0; i visStudent(n, false); vector visTeacher(n, false); if (dfs(i, n, c, match, visStudent, visTeacher, exStudent, exTeacher)) break; // 无法匹配降低期望 for (int j = 0; j >& c, vector& match, vector& visStudent, vector& visTeacher, vector& exStudent, vector& exTeacher) { visStudent[i] = true; for (int j = 0; j 困难题见： 动态规划状压dp部分的 D-数组的最大与和 (详情见 动态规划状压dp 部分提供六种解法 - 状态DP - 三进制- 最小费用最大流- 模拟退火- 贪心- KM) D-两个数组最小的异或值之和 5 负环 6 差分约束 或者参考： / 差分约束两大应用 应用一: 1 求不等式组的可行解 ⭐源点需要满足的条件: 从源点出发,一定可以走到所有的边 否则 用单源最短路做的话 有一条边走不到 则该边对应的不等式就无法满足 某一个点x[i]走不到无所谓(某个点走不到代表它不受限制,x[i]取任意数都可以) 过程: 1 把每个x[i] ≤ x[j] + C[k]不等式转化为一条从x[j]走到x[i]长度为C[k]的边 2 然后在这个图上找一个超级源点,使得该源点一定可以遍历到所有边 3 从源点求一遍 单源最短路 3.1 假如存在负环 x[1]→x[2]→x[3]→x[k] ↑ c1 c2 c3 ↓ ← ← ← ← ← ← ck x[2]≤ x[1]+c[1] ... x[k]≤ x[k-1]+c[k-1] x[1]≤ x[k]+c[k] 对第一个不等式用后面的不等式一直做松弛 x[2] ≤ x[1]+c[1] ≤ x[k]+c[k]+c[1] ≤ x[k-1]+c[k-1]+c[k]+c[1] ... ≤ x[2]+c[2]+...+c[k-1]+c[k]+c[1] ≤ x[2]+(小于零的Σc[i]) x[2] 存在负环 4 求完单源最短路之后 4.1 存在负环 => 不等式无解 4.2 没有负环 => 求完之后一定是满足这个不等式的 即一个可行解 x[i] ≤ x[j] + C[k] x1 ≤ x2+1 { x2 ≤ x3+2 x3 ≤ x1-5 x1 = 0 x2 = -1 x3 = -2 类比最短路 i→j 求之前 d[j] > d[i]+c c 求完后 d[j] ≤ d[i]+c 一个图里每个点求完最短距离后每个点的最短距离都有第二个不等式满足 即 任何一个最短路问题 可以 转化为一个差分约束问题 同理 一个差分约束问题 可以 转化为一个单源最短路问题 最长路 i→j 求之前 d[j] 应用二: 2 如何求最大值或者最小值(x[i] for i in range(1,n)) 结论1:如果求的是最小值,则应该求最长路,如果求的是最大值,则应该求最短路 问题1:如何转化x[i] ≤ c 其中c是一个常数 这类的不等式 方法:建立一个超级源点,0号点x[0],然后建立0→i 长度是c的边即可 x[i] ≤ c x[i] ≤ x[0] + c = 0 + c 以求x[i]的最大值为例:所有从x[i]出发,构成的不等式链 x[i] ≤ x[j] + c[j] ≤ x[k] + c[k] + c[j] ≤ x[0] + c[1]+ c[2]+... + c[j] = 0 + c[1]+ ... + c[j] 所计算出的上界, 最终x[i]的最大值 =所有上界的最小值 举例 x[i] ≤ 5 x[i] ≤ 2 x[i] ≤ 3 max(x[i]) = min(5,2,3) = 2 0 → 1 → 3 → 5 → ... → i c1 c3 c5 ci-1 x[1] ≤ x[0] + c[1] x[3] ≤ x[1] + c[3] x[5] ≤ x[3] + c[5] ... x[i] ≤ x[i-1] + c[i-1] 则 x[i] ≤ x[i-1] + c[i] ≤ x[i-3] + c[i-3] + c[i] ... ≤ x[0] + c[1] + c[3] + c[i-3] + c[i-1] ⭐可以发现Σc[i]就是从0→i的一条路径的长度 那么 求x[i]最大值 求所有上界的最小值 求所有从0→i的路径和的最小值 最短路求dist[i] 同理 求x[i]最小值 求所有下界的最大值 求所有从0→i的路径和的最大值 最长路求dist[i] / 注意点 负环 判断有无 cnt计数 spfa时的 hh==N hh=0; tt == N, tt =0; ???? 是否需要超级源点 是否要创建出来 创建出来 建立边 不创建出来 而是spfa中先把所有点都先入队列 问题转化 最大值 最小值 与 最短路 和最长路的关系 例题 糖果 求最小需要的糖果，即求最长路。 / 本题 1 A = B A≥B B≥A 2 A B≥A+1 3 A≥B A≥B 4 A > B A≥B+1 5 B≥A B≥A x≥1 } x≥x0+1(超级源点x0=0) x0=1 举例 x[i] ≥ 5 x[i] ≥ 2 x[i] ≥ 3 min(x[i]) = 5 总共最小值 = min(x[i]最小值) for i in range(n) = 求x[i]所有下界的最大值 = 求所有从0→i的路径和的最大值 = 最长路求dist[i] 0 → 1 → 3 → 5 → ... → i c1 c3 c5 ci-1 x[1] ≥ x[0] + c[1] x[3] ≥ x[1] + c[3] x[5] ≥ x[3] + c[5] ... x[i] ≥ x[i-1] + c[i-1] 则 x[i] ≥ x[i-1] + c[i] ≥ x[i-3] + c[i-3] + c[i] ... ≥ x[0] + c[1] + c[3] + c[i-3] + c[i-1] ⭐可以发现Σc[i]就是从0→i的一条路径的长度 那么 求x[i]最小值 求所有下界的最大值 求所有从0→i的路径和的最大值 最长路求dist[i] 即： if(d[j] A≥B B≥A 2条 +超级源点和所有点xi建边 =3n */ 区间 给定 n 个区间 [ai,bi] 和 n 个整数 ci。 你需要构造一个整数集合 Z，使得 ∀i∈[1,n]，Z 中满足 ai≤x≤bi 的整数 x 不少于 ci 个。 求这样的整数集合 Z 最少包含多少个数。 同样的题目： 见贪心：（数据量 和 数据范围更大， 需要离散。。。） LCP 32. 批量处理任务 思路： 贪心 朴素贪心 考虑把所有线段按照右端点 b 从小到大排序，依次考虑每一条线段的要求： 如果已经满足要求则跳过 否则尽量选择靠后的数（因为之后的线段的右端点都在这条线段的右边，这样容错更高） 所以，我们可以建一个数组，d[i] 表示 i 数字是否选择（填11或00），扫一遍 [l,r] 区间求和，然后从后往前贪心放数即可。#include #include #include using namespace std; const int N = 50005; int n, d[N], c[N]; struct Seg{ int a, b, c; bool operator 0) { for (int j = r; j >= l && cnt; j--) if(!d[j]) cnt--, ans++, d[j] = 1; } } printf(\"%d\\n\", ans); return 0; } 贪心 + 树状数组优化 + 并查集 考虑用数据结构优化。 发现我们需要三个操作： 询问 [l,r] 区间的数字个数 将值为 x 的位置 +1 从后往前，找到比当前位置靠前的下一个 0 的位置。 前两个就是 “区间求和，单调修改”，典型的树状数组。O(nlog250000) 第三种操作，可以用并查集优化。为什么可以确保时间复杂度呢？对于每一条线段，最多只有一次会枚举到 1 （即开始的那一次），之后每次枚举都会枚举到 0 的位置，即d[i]=0，然后把它变成 1，而以后就不会访问到了。而一共有 50000 个值，所以复杂度是 O(50000logn) #include #include #include using namespace std; const int N = 50001; int n, d[N], c[N], f[N]; struct Seg{ int a, b, c; bool operator 0) { for (int j = r; j >= l && cnt; ) { // d[j] == 1 的情况每条线段至多出现一次 if(!d[j]) { cnt--, ans++, d[j] = 1; // j 被标记成 1 了，要指向 find(j - 1) f[j] = j - 1; // 维护树状数组 add(j); }; if(find(j) != j) j = f[j]; else j--; } } // cout 贪心 + 线段树 + 二分 差分约束(求最小值，则求最长路) #include #include #include #include using namespace std; const int N = 50010, M = 150010; int e[M], ne[M], h[N], w[M], idx; int n; int dist[N]; bool st[N]; int q[N]; void add(int a, int b, int c){ e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++; } // void spfa() // { // memset(dist, -0x3f, sizeof dist); // dist[0] = 0; // st[0] = true; // int hh = 0, tt = 1; // q[0] = 0; // while (hh != tt) // { // int t = q[hh ++ ]; // // if (hh == N) hh = 0; //？？？？ // st[t] = false; // for (int i = h[t]; ~i; i = ne[i]) // { // int j = e[i]; // if (dist[j] q; q.push_back(0); st[0] = true; while(q.size()) { auto u = q.back(); // back和front都行 q.pop_back(); st[u] = false; for(int i = h[u]; ~ i; i = ne[i]){ int j = e[i]; if(dist[j] > n; memset(h, -1, sizeof h); for(int i = 1; i > a >> b >> c; add(a , b + 1, c); } spfa(); cout 排队布局 当排队等候喂食时，奶牛喜欢和它们的朋友站得靠近些。 农夫约翰有 N 头奶牛编号从 1 到 N，沿一条直线站着等候喂食。 奶牛排在队伍中的顺序和它们的编号是相同的。 因为奶牛相当苗条，所以可能有两头或者更多奶牛站在同一位置上。 如果我们想象奶牛是站在一条数轴上的话，允许有两头或更多奶牛拥有相同的横坐标。 一些奶牛相互间存有好感，它们希望两者之间的距离不超过一个给定的数 L。 另一方面，一些奶牛相互间非常反感，它们希望两者间的距离不小于一个给定的数 D。 给出 ML 条关于两头奶牛间有好感的描述，再给出 MD 条关于两头奶牛间存有反感的描述。 你的工作是：如果不存在满足要求的方案，输出-1；如果 1 号奶牛和 N 号奶牛间的距离可以任意大，输出-2；否则，计算出在满足所有要求的情况下，1 号奶牛和 N 号奶牛间可能的最大距离。 / x[i] 表示 第i头牛位置 以求x[i]的最大值为例:所有从x[i]出发,构成的不等式链 x[i] ≤ x[j] + c[j] ≤ x[k] + c[k] + c[j] ≤ x[0] + c[1]+ c[2]+... + c[j] = 0 + c[1]+ ... + c[j] 所计算出的上界, 最终x[i]的最大值 =所有上界的最小值 举例 x[i] ≤ 5 x[i] ≤ 2 x[i] ≤ 3 max(x[i]) = min(5,2,3) = 2 0 → 1 → 3 → 5 → ... → i c1 c3 c5 ci-1 x[1] ≤ x[0] + c[1] x[3] ≤ x[1] + c[3] x[5] ≤ x[3] + c[5] ... x[i] ≤ x[i-1] + c[i-1] 则 x[i] ≤ x[i-1] + c[i] ≤ x[i-3] + c[i-3] + c[i] ... ≤ x[0] + c[1] + c[3] + c[i-3] + c[i-1] ⭐可以发现Σc[i]就是从0→i的一条路径的长度 最大位置→不等式上界（小于等于）→上界里的最小值→最短路 x[i] ≤ x[j] + c j → i 1 每头奶牛按编号排序 i+1 → i w = 0 x[i] ≤ x[i+1] 2 两者之间的距离不超过一个给定的数L x[b]-x[a] ≤ L a → b w = L x[b] ≤ x[a] + L 3 两者之间的距离不小于一个给定的数D x[b]-x[a] ≥ D x[a] ≤ x[b]-D b → a w = -D 问题1： 因为没有一个点可以无条件到所有点, 所以建超级源点0 从0向 假定所有x[i] ≤ x[0] + 0 从而可以从0向x[i]连一条长度为0的边 1 如果没有负环-有解 2 如果有负环-无解 问题2： 直接把所有点i加入队列 == 创建超级源点0 点1和点n距离是否可以无限大？ 则可以把点1固定在一个位置上(选0位置)x[1] = 0,判断x[n]是否可以无限大 即求从1→n的最短路径,由于x[1]取0,则x[n]代表了n和1的最大距离,如果x[n]/ 总结来看，关系有 /* x_i+1 >= x_i -> x_i x_b = D -> x_a 代码如下：yxc代码及问答 #include #include #include #include using namespace std; const int N = 1010, M = 10000 + 10000 + 1000 + 10, INF = 0x3f3f3f3f; int n, m1, m2; int h[N], e[M], w[M], ne[M], idx; int dist[N]; int q[N], cnt[N]; bool st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } bool spfa(int size) { int hh = 0, tt = 0; memset(dist, 0x3f, sizeof dist); memset(st, 0, sizeof st); memset(cnt, 0, sizeof cnt); for (int i = 1; i dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] >= n) return true; if (!st[j]) { q[tt ++ ] = j; if (tt == N) tt = 0; st[j] = true; } } } } return false; } int main() { scanf(\"%d%d%d\", &n, &m1, &m2); memset(h, -1, sizeof h); for (int i = 1; i b) swap(a, b); add(a, b, c); } while (m2 -- ) { int a, b, c; scanf(\"%d%d%d\", &a, &b, &c); if (a > b) swap(a, b); add(b, a, -c); } if (spfa(n)) puts(\"-1\"); else { spfa(1); if (dist[n] == INF) puts(\"-2\"); else printf(\"%d\\n\", dist[n]); } return 0; } 拓展：差分约束+二分:雇佣收银员 参考： Acticle:差分约束 差分约束复习 7 LCA问题 最近公共祖先LCA问题 LCA总结 方法： 向上标记法 O(n) 倍增法 O(nlog(n)) 线段树或者RMQ Tarjan (可用于离线）O(m+n) 总结： 对于单次询问的LCA，单次询问怎么都卡不到时间复杂度。只有多次询问的LCA才有意义。 说一下q次询问的LCA问题： 无论是朴素还是倍增还是离线tarjan都需要前序知识就是DFS。 朴素做法，预处理节点深度O(V+E), 对于每次询问让深层次的节点跳到和另外一个层次相同，然后同上一步一步上跳。q次询问总体复杂度是O(qn) 倍增是基于朴素升级的，同样先预处理对于每次询问让深层次的节点跳到和另外一个层次相同，然后一起倍增往高处跳，f[x][i] = f[f[x][0]][i-1];对于跳2^i可以先跳一半到祖先节点然后在从祖先跳一半上去。最后答案就是f[x][0]; q次询问下来时间复杂度就是O(max(q,n) * logn) 线段树或者RMQ解决多次查询，线段树是在线询问问题的克星。先DFS得到一个DFS序列O(V+E)，然后利用RMQ或者线段树预处理DFS序O(nlogn)，对于每次询问直接获取这两个节点之间DFS序的最小值就是LCA。时间复杂度同上 tarjan的离线做法了，这种一次性记录需要查询的序列对，然后依次tarjan直接得到所有的需要查询的答案。时间复杂度是O(V+E)。 对于LCA一般选择倍增是比较好的，又快又准。不需要离线直接在线倍增就行。而线段树在这里是大材小用了。tarjan的强项也不在这里，tarjan是强连通，割边，割点....问题的最优解。 1 向上标记法 > o / \\ o o / \\ o . / \\ . o o / \\ . o / \\ o . / \\ . o 方法1 向上标记法 O(n) o ↗ \\ . o ↗ \\ o . ↗ \\ 2 . o 1 步骤 1 先从点1往上走到根节点,走过的点都标记 2 再从点2往上走,碰到的第一个带标记的点就是最近公共祖先 分析： 假设给定的节点为node1,node2,可以分为下面的两种情况： 1）node1是node2的祖先节点或孩子结点，可以理解为两个节点在一条线上。例如：Dist(2,4),Dist(6,1) 2）node1和node2没有直接或间接的父子关系。例如，Dist(4,3)，他们需要一个共同的祖先结点1连接起来 假设lca是两个节点的最低公共祖先节点： Dist(n1,n2)=Dist(root,n1)+Dist(root,n2)-2*Dist(root,lca) 这个公式已经涵盖了上面的两种情况。先找出lca,再求root节点到某个节点的距离就比较简单了。 > o / \\ o o / \\ o . / \\ . o o / \\ . o / \\ o . / \\ . o 方法1 向上标记法 O(n) o ↗ \\ . o ↗ \\ o . ↗ \\ 2 . o 1 步骤 1 先从点1往上走到根节点,走过的点都标记 2 再从点2往上走,碰到的第一个带标记的点就是最近公共祖先 class Solution { public: unordered_map fa; unordered_map vis; void dfs(TreeNode* root){ if (root->left != nullptr) { fa[root->left->val] = root; dfs(root->left); } if (root->right != nullptr) { fa[root->right->val] = root; dfs(root->right); } } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { fa[root->val] = nullptr; dfs(root); while (p != nullptr) { vis[p->val] = true; p = fa[p->val]; } while (q != nullptr) { if (vis[q->val]) return q; q = fa[q->val]; } return nullptr; } }; 2 递归法 这个问题可以分为三种情况来考虑： 情况一：root未知，但是每个节点都有parent指针 此时可以分别从两个节点开始，沿着parent指针走向根节点，得到两个链表，然后求两个链表的第一个公共节点，这个方法很简单，不需要详细解释的。 情况二：节点只有左、右指针，没有parent指针，root已知 思路：有两种情况，一是要找的这两个节点（a, b），在要遍历的节点（root）的两侧，那么这个节点就是这两个节点的最近公共父节点； 二是两个节点在同一侧，则 root->left 或者 root->right 为 NULL，另一边返回a或者b。那么另一边返回的就是他们的最小公共父节点。 递归有两个出口，一是没有找到a或者b，则返回NULL；二是只要碰到a或者b，就立刻返回。 // 二叉树结点的描述 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; // 节点只有左指针、右指针，没有parent指针，root已知 /** 注意p,q必然存在树内, 且所有节点的值唯一!!! 递归思想, 对以root为根的(子)树进行查找p和q, 如果root == null || p || q 直接返回root 表示对于当前树的查找已经完毕, 否则对左右子树进行查找, 根据左右子树的返回值判断: 1. 左右子树的返回值都不为null, 由于值唯一左右子树的返回值就是p和q, 此时root为LCA 2. 如果左右子树返回值只有一个不为null, 说明只有p和q存在与左或右子树中, 最先找到的那个节点为LCA 3. 左右子树返回值均为null, p和q均不在树中, 返回null **/ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr || root == p || root == q ) return root; // TreeNode* lson = lowestCommonAncestor(root->left, p, q); TreeNode* rson = lowestCommonAncestor(root->right, p, q); if(lson && rson) return root; return lson ? lson : rson; } }; 情况三： 二叉树是个二叉查找树，且root和两个节点的值(a, b)已知 // 二叉树是个二叉查找树，且root和两个节点的值(a, b)已知 BinaryTreeNode* findLowestCommonAncestor(BinaryTreeNode* root , BinaryTreeNode* a , BinaryTreeNode* b) { char min , max; if(a->data data) min = a->data , max = b->data; else min = b->data , max = a->data; while(root) { if(root->data >= min && root->data data data rchild; else root = root->lchild; } return NULL; } 一般情况： dfs 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3： 输入：root = [1,2], p = 1, q = 2 输出：1 提示： 树中节点数目在范围 [2, 105] 内。 -109 解： class Solution { public: TreeNode* ans; bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr) return false; bool lson = dfs(root->left, p, q); bool rson = dfs(root->right, p, q); if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) { ans = root; } return lson || rson || (root->val == p->val || root->val == q->val); } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, p, q); return ans; } }; 更简洁啊： class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr || root == p || root == q ) return root; // TreeNode* lson = lowestCommonAncestor(root->left, p, q); TreeNode* rson = lowestCommonAncestor(root->right, p, q); if(lson && rson) return root; return lson ? lson : rson; } }; 应用 二叉树中两个节点的距离 d(x) 为 x 到根节点距离 d(x,y) = d(x) + d(y) - 2 * d(lca) 二叉树中两个节点间的路径 M-从二叉树一个节点到另一个节点每一步的方向 3 倍增法 祖孙询问(树上倍增LCA) 方法2 倍增法 预处理(nlogn) + 查询(logn) ⭐关键是理解二进制拼凑 在这里是怎么体现的 即 x,y从同一高度同时起跳后,在f[x][0]!=f[y][0] 的约束下 我们能跳的最多的步数跳完后 x,y就达到了LCA的下面一层 假定我们知道 x,y出发点为第1层 LCA下一层为第12层 那么最多能跳的步数t = 12-1 = 11 = (1011)2 = 最多能跳2^3 + 2^2 + 2^0 步 所以我们就通过从大到小枚举k使得我们刚好跳11步而不能跳超过12步 但实际上我们并不知道要跳11步,所以我们可以通过f[x][0]!=f[y][0]的约束来实现 即f[x][总共>=12步] = f[y][总共>=12步] 那就不跳(不拼凑2^k) f[x][总共 预处理出每个点向上走2^k步的节点的父亲是谁 f[i][j] 从i开始向上走2^j步所能走到的节点 00 f[i][j-1] i → mid → t 2^j-1 2^j-1 f[i][j-1] f[i][j] mid = f[i][j-1] t = f[i][j] 则f[i][j] = f[mid][j-1] = f[f[i][j-1]][j-1] depth[i]表示深度/层数 1 / \\ 2 y / \\ 4 5 / \\ x 7 步骤1 把两个点跳到同一层 把x跳到和y同一层 二进制拼凑 2^0 ~ 2^k t 举例 2^0 ~ 2^4 11 1 2 4 8 16 11 二进制 16>11 0 83 0 2=1 t = 1 1 二进制 (1011)2 depth(x) - depth(y) 从x跳到y 从x跳2^k步后的点的深度 depth(f[x][k]) >= depth(y)时 就可以继续跳 步骤2 在depth(x)==depth(y)后 一起往上跳2^k(for k in [log(n),1] 情况1 x==y 则该点就是x和y的最近公共祖先 情况2 x!=y 即他俩同层但不同 则继续让两个点同时往上跳 一直跳到它们的最近公共祖先的下一层 1 1 / \\ / \\ 2 y x y / \\ / \\ 4 5 4 5 / \\ / \\ x 7 6 7 why 最近公共祖先的下一层 not 最近公共祖先？ 方便判断 假如f[x][k] == f[y][k] f[x][k] or f[y][k]是x和y的一个公共祖先 但不一定是最近的 举个栗子 此时f[x][1] == f[y][1] = 节点2 是x和y的一个公共祖先 但不是最近公共祖先4 ,但由于我们是从大到小拼凑的,假如拼凑终止条件为f[x][k] == f[y][k] ,则此时会停在公共祖先2而非最近公共祖先4 1 / \\ 2 3 / \\ 4 5 / \\ / x y 8 步骤一 x先到y同一层 f[x][0]!=f[x][0] 且把k能填1的都填完了 加上约束 f[x][k] != f[y][k] 思考一下为啥: 因为第一个出现f[x][k] == f[y][k]的节点只是公共祖先却不能保证是最近公共祖先 所以只要 f[x][k] != f[y][k] 那么 x y就还没跳到过最近公共祖先,而在其下面层 从大往小枚举k 枚举过程中 只要 f[x][k] != f[y][k] 那么 x y就还没跳到过最近公共祖先,而在其下面层,则x,y更新为f[x][k] f[y][k] 这个过程中 f[x][k] == f[y][k]时 不执行跳2^k步跳到 f[y][k] 的操作 直到k枚举完为止 枚举完之后就走到了最近公共祖先的下一层 二进制拼凑 2^0 ~ 2^k t 这里的k最大为logn t为 x和y达到同一高度(depth(起始)) - 最近公共祖先下一层深度-1(depth(祖先)-1) 举例 2^0 ~ 2^4 2 1 2 4 8 16 2 二进制 16>2 0 8>2 0 4>2 0 2=2 t = 2-2 = 0 1 1>0 0 1 / \\ 2 3 / \\ \\ 4 5 8 / \\ \\ x 7 9 1 \\ / \\ y 2 3 / \\ \\ 4 5 8 / \\ \\ x 7 y 在这个例子里 k=4 t=2(4(x,y出发层)-2(LCA下一层))[通过f[x][k] != f[y][k]约束] 1 / \\ x y / \\ \\ 4 5 8 / \\ \\ 6 7 9 此时它们的最近公共祖先就是x or y往上跳一步 即LCA = f[x][0] or f[y][0] */ 做法： 先预处理出每个点的深度（dfs或bfs），以及跳2i个祖先后所在的位置（fa[i][j]表示第i个点跳2j个祖先后的位置，再递推）； 然后同理暴力，先把两点跳到同一深度（也用倍增），每次跳2i个祖先，判断是否相等，如果相等就不跳（原因见易错点），否则跳； 难点： 1、递推时方程为fa[i][j]=fa[fa[i][j-1]][j-1]，因为i跳2j个祖先后所在的位置等于i连跳两次2j−1个祖先后所在的位置； 2、递推时，j先扫1到20，i再扫1到n，因为每次更新f[i][j]要用到另外的位置跳2j−1个祖先后所在的位置； 3、两个点跳的时候，如果相等，是不能直接输出的，有可能跳过头，就不是最近的公共祖先了； 4、每次读进来的边要存两次（树是无向图），同理，邻接表的数组也要开两倍长； #include #include #include #include using namespace std; const int N = 40010, M = N * 2; int n, m; int h[N], e[M], ne[M], idx; int depth[N], fa[N][16];//往上跳2^k步后的父亲节点 int q[N]; void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } void bfs(int root)//宽搜不容易因为递归层数过多爆栈 { memset(depth,0x3f,sizeof depth); // 哨兵depth[0] = 0: 如果从i开始跳2^j步会跳过根节点 // fa[fa[j][k-1]][k-1] = 0 // 那么fa[i][j] = 0 depth[fa[i][j]] = depth[0] = 0 depth[0] = 0,depth[root] = 1; queue q; q.push(root); while(q.size()) { int t = q.front(); q.pop(); for(int i=h[t];i!=-1;i=ne[i]) { int j = e[i]; if(depth[j]>depth[t]+1)//说明j还没被搜索过 { depth[j] = depth[t]+1; q.push(j);//把第depth[j]层的j加进队列 fa[j][0] = t;//j往上跳2^0步后就是t /* i → mid → t 2^j-1 2^j-1 f[i][j-1] f[i][j] mid = f[i][j-1] t = f[i][j] 则f[i][j] = f[mid][j-1] = f[f[i][j-1]][j-1] */ for(int k=1;k= 0; k -- ) //当a跳完2^k依然在b下面 我们就一直跳 //二进制拼凑法 //这里因为 if (depth[fa[a][k]] >= depth[b]) a = fa[a][k]; //如果跳到了b if (a == b) return a; //a,b同层但不同节点 for (int k = 15; k >= 0; k -- ) // 假如a,b都跳出根节点,fa[a][k]==fa[b][k]==0 不符合更新条件 if (fa[a][k] != fa[b][k]) { a = fa[a][k]; b = fa[b][k]; } //循环结束 到达lca下一层 //lca(a,b) = 再往上跳1步即可 return fa[a][0]; } int main() { cin >> n; int root = 0; memset(h, -1, sizeof h); for (int i = 0; i > a >> b; if (b == -1) root = a; else add(a, b), add(b, a); } bfs(root);//建fa[i][j] scanf(\"%d\", &m); while (m -- ) { int a, b; cin >> a >> b; int p = lca(a, b); if (p == a) cout 4 Tarjan Article:距离(tarjan求lca) Trajan 离线算法O(n + m); 在线做法：边读边做 离线做法：先读完，再全部处理，最后全部输出。 Tarjon本质就是对向上标记法的一个优化，任取一个节点当成根节点进行dfs优先遍历，把所有节点分成三部分 1）已经遍历并且回溯的标记成2 2）正在遍历的没有回溯的标记成1 3）未遍历的标记成0 其中所有2号点和正在搜索的1号点路径中已经通过并查集合并成一个集合 1、先求出所有点到根结点的距离depth[]，设x号点和y号点的最近公共祖先是p,则x和y的最近距离等于depth[x] + depth[y] - 2 * depth[p] 2、在深度优先遍历1号点中的u点的时候，需要把u的查询的另外一个点的最短距离进行计算并存储，最后把u点合并到上一结点的集合。 注意：顺序一定不能乱。 1）当这个点遍历子节点后的时候把子节点的祖宗更新成当前点 2）只有当前点回溯的时候才可以用这个点来计算所有之前为2的点，因为如果当前点为a,而b是a这条路径的上的点，并且b在a的下面，那么因为b先回溯，所以要等b回溯了之后才能正确的判断a. 3)加入询问的时候要加入两次 num[a].push_back = {b, i}, num[b].push_back(a, i}; 距离 给出 n 个点的一棵树，多次询问两点之间的最短距离。 注意： 边是无向的。 所有节点的编号是 1,2,…,n。 输入格式 第一行为两个整数 n 和 m。n 表示点数，m 表示询问次数； 下来 n−1 行，每行三个整数 x,y,k，表示点 x 和点 y 之间存在一条边长度为 k； 再接下来 m 行，每行两个整数 x,y，表示询问点 x 到点 y 的最短距离。 树中结点编号从 1 到 n。 */ #include #include #include #include #include using namespace std; typedef pair PII; const int N = 10010, M = N * 2; int n, m; int h[N], e[M], w[M], ne[M], idx; int dist[N];//每个点和1号点的距离 int p[N]; int res[M]; int st[N]; vector query[N];//把询问存下来 // query[i][first][second] first存查询距离i的另外一个点j，second存查询编号idx void add(int a,int b,int c) { e[idx] = b; ne[idx] = h[a]; w[idx] = c; h[a] = idx++; } int find(int x) { if(p[x]!=x)p[x] = find(p[x]); return p[x]; } void dfs(int u,int fa) { for(int i=h[u];~i;i=ne[i]) { int j = e[i]; if(j==fa) continue; dist[j] = dist[u]+w[i]; dfs(j,u); } } void tarjan(int u) { st[u]=1;//当前路径点标记为1 // u这条路上的根节点的左下的点用并查集合并到根节点 for(int i = h[u];~i;i=ne[i]) { int j = e[i]; if(!st[j]) { tarjan(j);//往左下搜 p[j] = u;//从左下回溯后把左下的点合并到根节点 } } // 对于当前点u 搜索所有和u for(auto item:query[u]) { int y = item.first,id = item.second; if(st[y]==2)//如果查询的这个点已经是左下的点(已经搜索过且回溯过,标记为2) { int anc = find(y);//y的根节点 // x到y的距离 = d[x]+d[y] - 2*d[lca] res[id] = dist[u]+dist[y] - dist[anc]*2;//第idx次查询的结果 res[idx] } } //点u已经搜索完且要回溯了 就把st[u]标记为2 st[u] = 2; } int main() { cin >> n >> m; // 建图 memset(h,-1,sizeof h); for(int i=0;i> a >> b >> c; add(a,b,c),add(b,a,c); } // 存下询问 for(int i=0;i> a >> b; if(a!=b) { query[a].push_back({b,i}); query[b].push_back({a,i}); } } for(int i=1;i 以下尚未整理 有向图的强连通分量 tarjan 无向图的双连通分量 欧拉回路和欧拉路径 基础 欧拉通路与欧拉回路 欧拉通路： 对于图G来说，如果存在一条通路包含G中所有的边，则该通路成为欧拉通路，也称欧拉路径。 欧拉回路： 如果欧拉路径是一条回路，那么称其为欧拉回路。 欧拉图 ： 含有欧拉回路的图是欧拉图。 对无向图G和有向图H： 图G存在欧拉路径与欧拉回路的充要条件分别是： 欧拉路径： 图中所有奇度点的数量为0或2。 欧拉回路： 图中所有点的度数都是偶数。 图H存在欧拉路径和欧拉回路的充要条件分别是： 欧拉路径： 所有点的入度等于出度 或者 存在一点出度比入度大1(起点)，一点入度比出度大1(终点)，其他点的入度均等于出度。 欧拉回路：所有点的入度等于出度。 例题： 欧拉回路 给定一张图，请你找出欧拉回路，即在图中找一个环使得每条边都在环上出现恰好一次。 输入格式 第一行包含一个整数 t，t∈{1,2}，如果 t=1，表示所给图为无向图，如果 t=2，表示所给图为有向图。 第二行包含两个整数 n,m，表示图的结点数和边数。 接下来 m 行中，第 i 行两个整数 vi,ui，表示第 i 条边（从 1 开始编号）。 如果 t=1 则表示 vi 到 ui 有一条无向边。 如果 t=2 则表示 vi 到 ui 有一条有向边。 图中可能有重边也可能有自环。 点的编号从 1 到 n。 输出格式 如果无法一笔画出欧拉回路，则输出一行：NO。 否则，输出一行：YES，接下来一行输出 任意一组 合法方案即可。 如果 t=1，输出 m 个整数 p1,p2,…,pm。令 e=|pi|，那么 e 表示经过的第 i 条边的编号。如果 pi 为正数表示从 ve 走到 ue，否则表示从 ue 走到 ve。 如果 t=2，输出 m 个整数 p1,p2,…,pm。其中 pi 表示经过的第 i 条边的编号。 数据范围 1≤n≤105, 0≤m≤2×105 输入样例1： 1 3 3 1 2 2 3 1 3 输出样例1： YES 1 2 -3 输入样例2： 2 5 6 2 3 2 5 3 4 1 2 4 2 5 1 输出样例2： YES 4 1 3 5 2 6 解： dfs 根据欧拉回路判断的充要条件(所有点的入度等于出度)，可以判定一个图是否是欧拉图，之后，我们可以利用dfs来找到一条欧拉回路： 以无向图为例，因为每个点的度都为偶数，所以我们从任意一个点出发，假设所有点的度数都为2，那么dfs一定会回到起点，从而形成一个回路(如果度数都为2，那么现在就是一条欧拉回路)，假设度数不全为2，有4,6,8...那么在dfs过程中，当走到这些点(假设走到点u)上时，可能会走到其他环上，但是由于度数是偶数，所以如果走到其他环上，最后也会回到点u，在dfs过后，一定会形成许多环，环与环之间有一个交点(在图中两个环可能有两个交点，但在dfs过程中只会选择一条边去走，所以这个”交点”的意义要分清楚)，在回溯过程中将这些点添加到答案中，就是一条欧拉回路。 有向图同理。 #include #include #include #include using namespace std; const int N = 100100, M = 400100; int h[N],e[M],ne[M],idx; int ans[N*2],cnt; bool used[M]; int din[N],dout[N]; int n,m,ver; void add(int a,int b){ e[idx] = b,ne[idx] = h[a],h[a] = idx++; } void dfs(int u){ for(int &i = h[u]; ~i; ){ if(used[i]){ //如果这条边用过了 i = ne[i]; //删除这条边 continue; } used[i] = true; //标记这条边已使用 if(ver == 1) used[i^1] = true; //如果是无向图，那么这条边的反向边也要标记使用过了 int t; if(ver == 1){ t = i/2 + 1; if(i&1) t = -t; //(0,1) (2,3) (4,5) 奇数编号是返回的边 }else t = i+1; int j = e[i]; i = ne[i]; dfs(j); ans[cnt++] = t; } } int main() { scanf(\"%d%d%d\",&ver,&n,&m); memset(h,-1,sizeof h); for(int i = 0; i=0; --i){ cout Hierholzer 算法 求欧拉通路、回路(节点)或欧拉路径(边) Hierholzer 算法流程如下： 从起点出发，进行深度优先搜索。 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边（灵魂）。 如果没有可移动的路径，则将所在节点加入到结果中，并返回。 当我们顺序地考虑该问题时，我们也许很难解决该问题，因为我们无法判断当前节点的哪一个分支是「死胡同」分支。 不妨倒过来思考。我们注意到只有那个入度与出度差为 1 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变记录的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点记录（即逆序）。 对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。 而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。 也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支 记录。 （因为如果是非死胡同分支，会再回到当前节点，只要当前节点还有其他分支，则不会入栈记录。 只有当分支为 死胡同分支时，才可能让 剩余分支数 减到0.） 这样就能保证我们可以「一笔画」地走完所有边，最终的记录结果逆序地保存了「一笔画」的结果。我们只要将结果中的内容反转，即可得到答案。 模版有四步： 1.建邻接表、入度表、出度表 2.根据是通路还是回路判断是否要找起点start 3.Hierholzer 算法找路 4.最后将上一步找的路再逆回来 例题： 重新安排行程 合法重新排列数对 破解保险箱 对于： 重新安排行程 给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。 例如，行程 [\"JFK\", \"LGA\"] 与 [\"JFK\", \"LGB\"] 相比就更小，排序更靠前。 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。 class Solution { unordered_map, greater>> vec; vector stk; void dfs(const string& cur){ while(vec.count(cur) && vec[cur].size() > 0){ string tt = vec[cur].top(); vec[cur].pop(); dfs(move(tt)); } stk.emplace_back(cur); } public: vector findItinerary(vector>& tickets) { for(auto & it : tickets){ vec[it[0]].emplace(it[1]); } dfs(\"JFK\"); reverse(stk.begin(), stk.end()); return stk; } }; 对于： 合法重新排列数对 给你一个下标从 0 开始的二维整数数组 pairs ，其中 pairs[i] = [starti, endi] 。如果 pairs 的一个重新排列，满足对每一个下标 i （ 1 解： class Solution { public: vector> validArrangement(vector>& pairs) { // 存储图 unordered_map> edges; // 存储入度和出度 unordered_map indeg, outdeg; for (const auto& p: pairs) { int x = p[0], y = p[1]; edges[x].push_back(y); ++indeg[y]; ++outdeg[x]; } // 寻找起始节点 int start = pairs[0][0]; for (const auto& [x, occ]: outdeg) { // 如果有节点出度比入度恰好多 1，那么只有它才能是起始节点 if (occ == indeg[x] + 1) { start = x; break; } } vector> ans; // 深度优先搜索（Hierholzer 算法）求解欧拉通路 function dfs = [&](int u) { while (!edges[u].empty()) { int v = edges[u].back(); edges[u].pop_back(); dfs(v); ans.push_back({u, v}); } }; dfs(start); reverse(ans.begin(), ans.end()); return ans; } }; 以下为进阶部分 网络流 1 最大流 1.1 算法模板 1.2 二分图匹配 1.3 上下界可行流 1.4 多源汇最大流 1.5 关键边 1.6 最大流判定 1.7 拆点 1.8 建图实战 2 最小割 2.1 算法模板 2.2 直接应用 2.3 最大权闭合图 2.4 最大密度子图 2.5 最小点权覆盖集 2.6 最大点权独立集 2.7 建图实战 3 费用流 3.1 算法模板 3.2 直接应用 3.3 二分图最优匹配 3.4 最大权不相交路径 3.5 网格图模型 3.6 拆点 3.7 上下界可行流 2-SAT 朱刘算法 Prufer编码 最小费用最大流问题与算法实现（Bellman-Ford、SPFA、Dijkstra） Bellman-Ford特点：可以解决负权边，但不允许有负环不足：每次循环值均对所有元素进行松弛判断，造成许多不必要的操作。 贝尔曼-福特算法（Bellman-Ford algorithm），是求解单元最短路径的一种算法。 它的基本原理是对图进行|V| - 1次松弛操作，得到所有可能的最短路径。 它比Dijkstra算法好的部分在于，在计算最短路径的班的权值可以为负，实现起来比较简单。 缺点则是时间复杂度较高，为O(|V||E|)。不过算法已经有了一些改进方案，比如队列优化的Bellmanford算法（SPFA算法），一定程度上提高了效率。 算法原理： 贝尔曼-福特算法与迪科斯彻算法类似，都以松弛操作为基础，即估计的最短路径值渐渐地被更加准确的值替代，直至得到最优解。 在两个算法中，计算时每个边之间的估计距离值都比真实值大，并且被新找到路径的最小长度替代。 然而，迪科斯彻算法以贪心法选取未被处理的具有最小权值的节点，然后对其的出边进行松弛操作；而贝尔曼-福特算法简单地对所有边进行松弛操作，共|V| - 1次。 在重复地计算中，已计算得到正确的距离的边的数量不断增加，直到所有边都计算得到了正确的路径。 因为算法可以使用负权值的边，因此贝尔曼-福特算法比迪科斯彻算法适用于更多种类的输入。 优化选项： 循环的提前跳出 在实际操作中，贝尔曼-福特算法经常会在未达到|V|-1前就给出解，|V|-1就是最大值。因此可以在循环中设置判定，在某次循环不再松弛时，直接退出循环，进行负权环判定。 队列优化 队列优化的贝尔曼-福特算法——SPFA算法基本思路与原算法是一样的，不过该算法的提升在于它不会盲目尝试所有的节点，而是维护一个备选节点队列，并且仅有节点被松弛之后才会放入到队列中。 SPFA特点：进阶版的BF，使用队列进行优化，每次循环值选择当前节点相邻的若干节点进行松弛。在稀疏图上十分高效。不足：单路增广。SPFA需要维护较为复杂的标号和队列操作，同时为了修正标号，需要不止一次地访问某些节点，速度会比较慢。 算法描述： 初始化：distance数组（从源点s到各点的最小费用）全部赋值为inf，用一个队列保存所有待松弛的顶点，初始时将s点放入队列中。 队列+松弛操作：每次出队一个顶点u，对其所有的边进行松弛，如果存在某条边u->v松弛成功（dist(v)>dist(u)+w(u,v)），则将v加入队列中（当v不在队列时）；重复以上操作直到队列为空或者发现负权环。 如果网络中存在负权回路，则算法永远都不会结束，陷入死循环。 判断是否存在负权环的方法： 对任何一个顶点，每进入一次队列，意味着需要进行一次松弛，即如果某个顶点进入队列的次数超过V，说明存在负权环。 算法步骤： 建立一个队列，将源点加入队列中，建立一个数组dist记录源点到所有点的最短路径（初始为inf，源点到本身的最短路径是0）。 从队列中取出队头元素，刷新其连接的所有点的最短路径；如果刷新成功且被刷新点不在队列中，则把该点加入到队尾。 重复执行以上步骤直到队列为空或者队列中存在负权环。 改进的Dijkstra 特点：速度普遍比SPFA要快。不足：无法直接处理负权边图，需要对算法进行改进。 算法描述： 用于求解指定两点间的最短路，或从指定点到其余个点的最短路。是目前求非负权网络最短路问题的最好方法。 基本步骤： 将所有的顶点分成两个集合，P集合和Q集合，初始时P集合只有源点，其他顶点都在Q集合中。 每次选择P集合中新加入的顶点u，用该顶点作为中转点更新Q集合中的顶点的最短路（松弛）；选择Q中最短路值最小的顶点加入到集合P中。 重复步骤2直到集合Q中没有顶点。 由于最小费用最大流网络中存在负权值，Dijkstra算法不能直接求解最小费用最大流问题，如果最小费用最大流网络中的权值都非负，则可使用Dijkstra算法。引入势函数h(u)为上一次Dijkstra算法的dist(u)（表示从源点到顶点u的最短距离），对每一条边（u,v）,h(v) Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-09-22 14:00:59 "},"01_数据结构与算法笔记/01_学习笔记/07_计算几何.html":{"url":"01_数据结构与算法笔记/01_学习笔记/07_计算几何.html","title":"1.7 计算几何","keywords":"","body":"计算几何 二维计算几何基础 最新常用汇总： // 计算几何 #include #include #include #include \"assert.h\" using namespace std; const double eps = 1e-8; const double PI = acos(-1); struct Point{ double x, y; Point(double x = 0, double y = 0): x(x), y(y){} }; typedef Point Vector; Vector operator - (const Vector& a, const Vector& b){ return Vector(a.x - b.x, a.y - b.y); } Vector operator + (const Vector& a, const Vector& b){ return Vector(a.x + b.x, a.y + b.y); } Vector operator * (const Vector& a, double p){ return Vector(a.x * p, a.y * p); } Vector operator / (const Vector& a, double p){ assert(p != 0); return Vector(a.x / p, a.y / p); } int dcmp(double x){ return fabs(x) 0 ? 1 : -1); } // basic operator double Dot(const Vector& a, const Vector& b){ return a.x * b.x + a.y * b.y; } double Cross(const Vector& a, const Vector& b){ return a.x * b.y - a.y * b.x; } double Length(const Vector& a){ return sqrt(Dot(a, a)); } double Angle(const Vector& a, const Vector& b){ return acos(Dot(a, b) / Length(a) / Length(b)); } double Area(Point a, Point b, Point c){ return Cross(b - a, c - a) / 2; // + - } Vector Rotate(Vector a, double rad){ return Vector(a.x * cos(rad) - a.y * sin(rad), a.x * sin(rad) + a.y * cos(rad)); } // 常考知识点 //1. 两直线交点 Point intersectionLine(Point p, Vector v, Point q, Vector w){ double t = Cross(q - p, w) / Cross(v, w); return p + v * t; } //2. 点到直线距离 double disToLine(Point p, Point a, Point b){ Vector u = p - a, v = b - a; return fabs(Cross(u, v) / Length(v)); } bool operator == (const Point& a, const Point& b){ return (dcmp(a.x - b.x) == 0) && (dcmp(a.y - b.y) == 0); } //3. 点到线段距离 double disToSegment(Point p, Point a, Point b){ if(a == b) return Length(p - a); } //4. 点在直线投影 // P AB Q = A + t * AB Point Projection(Point p, Point a, Point b){ return a + (b - a) * (Dot(p - a, b - a) / Length(b - a)); } //5. 两线段相交 bool intersectionSeg(Point a1, Point a2, Point b1, Point b2){ // 1. quick if(max(a1.x, a2.x) & p){ double area = 0; for(int i = 0; i & p){ double alpha = 0; for(int i = 0; i & p){ for(int i = 0; i 1 常用定义 1 点 和 向量 //定义点的类型 struct Point { double x, y; Point(double x = 0, double y = 0) : x(x) , y(y) { } //构造函数，方便代码编写 }; typedef Point Vector; //从程序实现上，Vector只是Point的别名 //向量 + 向量 = 向量 ，点 + 向量 = 点 Vector operator + (const Vector & A, const Vector & B) { return Vector(A.x+B.x, A.y+B.y); } //点 - 点 = 向量 Vector operator - (const Vector & A, const Vector & B) { return Vector(A.x-B.x, A.y-B.y); } //向量 * 数 = 向量 Vector operator * (const Vector & A, double p) { return Vector(A.x*p, A.y*p); } //向量 / 数 = 向量 Vector operator / (const Vector & A, double p) { return Vector(A.x/p, A.y/p); } 2 比较 计算及处理几何问题尽量减小误差 涉及到double，计算少用除法、开根（牛顿迭代法三次除法） a = b => |a - b| b => a - b > eps a a - b // 可能不太严谨 bool operator 0 ? 1 : -1); } bool operator == (const Point& a, const Point& b) { return dcmp(a.x - b.x) == 0 && dcmp(a.y - b.y) == 0; } 3 点积 & 叉积 点积： //点积 double Dot(Vector A, Vector B) { return A.x*B.x + A.y*B.y; } //求点积 double Length(Vector A) { return sqrt(Dot(A, A)); } //求向量长度 double Angle(Vector A, Vector B) { return acos(Dot(A, B) / Length(A) / Length(B)); }//求向量之间的夹角 叉积： //叉积 double Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }//求叉积 double Area2(Point A, Point B, Point C) { return Cross(B-A, C-A); }//根据叉积求三角形面积的两倍 带符号 总结： >点积 a*b 在第一个向量a上 b的投影长度 a * b = |a||b|cos(theta) = 一个数字 a*b = b * a 描述两个向量共线程度， 越接近ab越共线，越接近-ab，越方向 描述力做功，力和运动的共线程度 >叉积 aXb 方向与ab垂直 大小为平行四边形面积 = 一个向量 c = aXb = -bXa 方向由右手定则，手指向第一个a，手指指向第二个b，大拇指为C方向 描述两个向量垂直程度，越接近ab越垂直(面积越大)， 描述力矩，力与位矢的垂直程度 应用： 面积 多边形面积 见下文计算代码 折线段拐向 PNC:可用于判断过路口时 引导线的拐向 计算公式： a=(x1,y1) b = (x2,y2), a*b = x1*y1+x2*y2; >因为a=x1i+y1j，b=x2i+y2j 所以a*b=（x1i+y1j）*(x2i+y2j)=x1x2(i^2)+x1y2i*j+x2y1i*j+y1y2j^2 又因为i*i=1,j*j=1 i*j=j*i=0 所以a*b=x1x2+y1y2 a=(x1,y1) b = (x2,y2), aXb = x1*y2-x2*y1; >a=(a1,a2,a3) ,b=(b1,b2,b3) axb=(a2b3-a3b2,a3b1-a1b3,a1b2-a2b1) 或者用行列式计算 或者类似点乘计算 4 旋转 //旋转 Vector Rotate(Vector A, double rad) {//rad是弧度 return Vector(A.x*cos(rad) - A.y*sin(rad), A.x*sin(rad)+A.y*cos(rad) ); } 2 常用计算 1 两向量夹角 double angle_bettwen(Vector A, Vector B){ // 弧度 要求角度 * 180 / pi return acos(Dot(A, B)/Length(A)/Length(B)); } 2 向量的单位法线 //向量单位法向量，调用前请确保A不是零向量 (顺时针) Vector Normal(Vector A) { double L = Length(A); return Vector(-A.y/L, A.x/L); } 3 二直线交点 OI-WIKI //二直线交点（参数式） 妙啊 面积之比 = t Point GetLineIntersection(Point P, Vector v, Point Q, Vector w) { Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t; } 4 点到直线距离 //点到直线距离 (直线用其上两个点表示，或者用一个点加一个向量) double DistanceToLine(Point P, Point A, Point B) { Vector v1 = B-A, v2 = P - A; // 平行四边形面积除以底 return fabs(Cross(v1,v2) / Length(v1)); //如果不取绝对值，得到的是有向距离 } >点到直线距离 直线 Ax+By+C = 0, 点(a,b) d =|Aa+Bb+C|/sqrt(A^2 + B^2) 若直线ABC未知，可由两点确定直线A，B, C Ax1 + By1 + C = 0; Ax2 + By2 + C = 0; 相减 A(x1 - x2) + B(y1 - y2) = 0; 取 A = (y1 - y2), 则 B = (x2 - x1); C = x1 * y2 - x2 * y1; （类似叉乘公式） 5 点到线段距离 PNC:查找点到一折线段的最近距离,可进行分块优化，见数据结构进阶部分 区别于到直线，若点在线段外，则为点到AB较近点的距离。 //点到线段距离 double DistanceToSegment(Point P, Point A, Point B) { if(A==B) return Length(P-A); Vector v1 = B - A, v2 = P - A, v3 = P - B; if(dcmp(Dot(v1, v2)) 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1); } 6 点在直线投影 点在直线上的投影 起点A + 投影所占比例AB 即 `A + |AP|cos(theta) / |AB| * AB` //点在直线上的投影 Point GetLineProjection(Point P, Point A, Point B) { Vector v = B - A; return A + v * ( Dot(v, P-A) / Dot(v, v) ); } 拓展： 向量表示线段（有向线段） 对于 ∀C∈AB, ∀p∈[0,1], C = p A + (1 - p)B 7 线段相交判定 总结： 首先快速排斥 在x，y两个方向上投影有重叠 (以下代码为 不包括端点相交的 版本，如果算端点) //线段相交判定 bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) { double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) 8 点在线段上 判断一个点是否在一条线段上 //判断一个点是否在一条线段上 bool OnSegment(Point p, Point a1, Point a2) { // 在直线上 而且在 两端点内部(根据点乘方向共线反向 9 多边形面积 计算任意多边形的面积 //多边形面积 p点需要按逆时针(结果为正)排列 或顺时针排列( 加上fabs() ), double ConvexPolygonArea(Point* p, int n) { double area = 0; // for(int i = 1; i 以上对于三角形显然成立，对于四边形，不管凹凸都行。同理... 对于四边及以上，重要的是要知道点的顺序，只要构成边是逆时针或顺时针。 原理是划分成多个三角形进行一次计算。 对于凸多边形，可用其中一顶点进行分割。 对于凹，则不能用其中的顶点分割。 如下图，多边形的面积 = S_ABC + S_ACD + S_ADE, 这个面积明显超过多边形的面积。 我们根据二维向量叉乘求三角形ABC面积时，利用的是 这样求出来的面积都是正数，但是向量叉乘是有方向的，即AB X AC 是有正负的，如果把上面第三个公式中的绝对值符号去掉，即S_ABC = 0.5*(AB X AC) ，那么面积也是有正负的。反应在上面第二个图中，S = S_ABC + S_ACD + S_ADE，如果S_ABC和S_ADE是正的，那么S_ACD是负的，这样加起来刚好就是多边形的面积。对于凸多边形，所有三角形的面积都是同正或者同负。 如果我们不以多边形的某一点为顶点来划分三角形而是以任意一点，如下图，这个方法也是成立的：S = S_OAB + S_OBC + S_OCD + S_ODE + S_OEA。计算的时候，当我们取O点为原点时，可以简化计算。 当O点为原点时，根据向量的叉积计算公式，各个三角形的面积计算如下： S_OAB = 0.5(A_xB_y - A_yB_x) 【(A_x，A_y)为A点的坐标】 S_OBC = 0.5(B_xC_y - B_yC_x) S_OCD = 0.5(C_xD_y - C_yD_x) S_ODE = 0.5(D_xE_y - D_yE_x) S_OEA = 0.5(E_xA_y - E_y*A_x) 10 判断点在多边形中 判断点是否在多边形中 首先要严格定义 在边上或顶点上 不算是在内部。 以及怎么处理顶点和边上的情况 判断点是否在多边形内（不一定是凸多边形） a. 射线法，从该点任意做一条和所有边都不平行的射线。交点个数为偶数，则在多边形外，为奇数，则在多边形内。 b. 转角法 判断点是否在凸多边形内(只对凸有效) c. 只需判断点是否在所有边的左边（逆时针存储多边形）。 全在， 则在内部。 不全在，则在外部。 d. 在矩形内，一直矩形中心点x,y,theta（长边方向）,length,width。 坐标变换 到 车体坐标系中，与半车宽和半车长比较即可。 bool insidePolygon(Point * p, int n, Point A){ for(int i = 0; i 代码汇总： // mbjhip 几何inpolygon 内角和 // 1.内角和360 bool InPolygon(Point *p, int n, Point A){ double alpha = 0; for(int i = 0; i 射线法 // 2.射线法 int InPolygon(float *vertx, float *verty, int n, Point P) { bool c = 0; // 绘制一条往右的射线 double testx = P.x, testy = P.y; for (int i = 0; i testy) != (verty[j]>testy)) && (testx 左侧 // 3.左侧(凸，逆时针存储) bool InPolygon(Point * p, int n, Point A){ for(int i = 0; i 坐标变换 // 4.在矩形内，一直矩形中心点x,y,theta（长边方向）,length,width。 //- 坐标变换 到 车体坐标系中，与半车宽和半车长比较即可。 bool inPolygon(const Point &point) const { const double x0 = point.x() - center_.x(); const double y0 = point.y() - center_.y(); const double dx = std::abs(x0 * cos_heading_ + y0 * sin_heading_); const double dy = std::abs(-x0 * sin_heading_ + y0 * cos_heading_); return dx 详细 内角和 多边形为凸 - 角度和 const double pi = acos(-1); Point P[N]; int n; bool InsidePolygon(Point A){ double alpha = 0; for(int i = 0; i 射线法 多边形不限制凸和凹 - 射线法 · 点与多边形的关系：在内或在外 做一条直线，记穿边的个数，奇内偶外 如果交了顶点，算远不算近（不要问我，对于顶点肯定不能说交了1个点对吧，那么交0个或者交2个对奇偶性是没有影响的，算不算无所谓） · 还有一种判断点是否在多边形的方法 把多边形放在极坐标系里，以一个点作为原点，易知每条对角线的极角是单增的，知道点的极角，二分它所在的区域，再用叉乘判断点在不在里面就行了。 使用奇内偶外的方法：射线法 判断一个坐标点是否在不规则多边形内部的算法 // int pnpoly(int nvert, float *vertx, float *verty, float testx, float testy) // { // int i, j, c = 0; // 绘制一条往右的射线 // for (i = 0, j = nvert-1; i testy) != (verty[j]>testy)) && // (testx 采用下面这个版本 int insidePolygon(float *vertx, float *verty, int n, Point P) { bool c = 0; // 绘制一条往右的射线 double testx = P.x, testy = P.y; for (int i = 0; i testy) != (verty[j]>testy)) && (testx 首先，参数nvert 代表多边形有几个点。浮点数testx, testy代表待测试点的横坐标和纵坐标，vertx,verty分别指向储存多边形横纵坐标数组的首地址。 我们注意到，每次计算都涉及到相邻的两个点和待测试点，然后考虑两个问题： 被测试点的纵坐标testy是否在本次循环所测试的两个相邻点纵坐标范围之内？即 verty[i] 或者verty[j] , 即向量异号((verty[i]>testy) != (verty[j]>testy) 待测点test是否在i,j两点之间的连线之下?(线段左侧区域更准确吧)？看不懂后半短if statement的朋友请自行在纸上写下i,j两点间的斜率公式，要用到一点初中解析几何和不等式的知识范畴，对广大码农来说小菜一碟。 然后每次这两个条件同时满足的时候我们把返回的布尔量取反。 可这到底是啥意思啊？ 这个表达式的意思是说，随便画个多边形，随便定一个点，然后通过这个点水平划一条线，先数数看这条横线和多边形的边相交几次，（或者说先排除那些不相交的边，第一个判断条件），然后再数这条横线穿越多边形的次数是否为奇数，如果是奇数，那么该点在多边形内，如果是偶数，则在多边形外。详细的数学证明这里就不做了，不过读者可以自行画多边形进行验证。 判断一个点是否在多边形内部 - 射线法思路 比如说，我就随便涂了一个多边形和一个点，现在我要给出一种通用的方法来判断这个点是不是在多边形内部（别告诉我用肉眼观察……）。 首先想到的一个解法是从这个点做一条射线，计算它跟多边形边界的交点个数，如果交点个数为奇数，那么点在多边形内部，否则点在多边形外。 这个结论很简单，那它是怎么来的？下面就简单讲解一下。 首先，对于平面内任意闭合曲线，我们都可以直观地认为，曲线把平面分割成了内、外两部分，其中“内”就是我们所谓的多边形区域。 基于这一认识，对于平面内任意一条直线，我们可以得出下面这些结论： 直线穿越多边形边界时，有且只有两种情况：进入多边形或穿出多边形。 在不考虑非欧空间的情况下，直线不可能从内部再次进入多边形，或从外部再次穿出多边形，即连续两次穿越边界的情况必然成对。 直线可以无限延伸，而闭合曲线包围的区域是有限的，因此最后一次穿越多边形边界，一定是穿出多边形，到达外部。 现在回到我们最初的题目。假如我们从一个给定的点做射线，还可以得出下面两条结论： 如果点在多边形内部，射线第一次穿越边界一定是穿出多边形。 如果点在多边形外部，射线第一次穿越边界一定是进入多边形。 把上面这些结论综合起来，我们可以归纳出： 当射线穿越多边形边界的次数为偶数时，所有第偶数次（包括最后一次）穿越都是穿出，因此所有第奇数次（包括第一次）穿越为穿入，由此可推断点在多边形外部。 当射线穿越多边形边界的次数为奇数时，所有第奇数次（包括第一次和最后一次）穿越都是穿出，由此可推断点在多边形内部。 到这里，我们已经了解了这个解法的思路，大家可以试着自己写一个实现出来。 不知道大家思考得怎么样，有没有遇到一些不好处理的特殊情况。今天就来讲讲射线法在实际应用中的一些问题和解决方案。 点在多边形的边上 前面我们讲到，射线法的主要思路就是计算射线穿越多边形边界的次数。那么对于点在多边形的边上这种特殊情况，射线出发的这一次，是否应该算作穿越呢？ 看了上面的图就会发现，不管算不算穿越，都会陷入两难的境地——同样落在多边形边上的点，可能会得到相反的结果。这显然是不正确的，因此对这种特殊情况需要特殊处理。 点和多边形的顶点重合 这其实是第一种情况的一个特例。 射线经过多边形顶点 射线刚好经过多边形顶点的时候，应该算一次还是两次穿越？这种情况比前两种复杂，也是实现中的难点，后面会讲解它的解决方案。 射线刚好经过多边形的一条边 这是上一种情况的特例，也就是说，射线连续经过了多边形的两个相邻顶点。 解决方案： 1判断点是否在线上的方法有很多，比较简单直接的就是计算点与两个多边形顶点的连线斜率是否相等，中学数学都学过。 2点和多边形顶点重合的情况更简单，直接比较点的坐标就行了。 3顶点穿越看似棘手，其实我们换一个角度，思路会大不相同。先来回答一个问题，射线穿越一条线段需要什么前提条件？没错，就是线段两个端点分别在射线两侧。只要想通这一点，顶点穿越就迎刃而解了。这样一来，我们只需要规定被射线穿越的点都算作其中一侧。 如上图，假如我们规定射线经过的点都属于射线以上的一侧，显然点D和发生顶点穿越的点C都位于射线Y的同一侧，所以射线Y其实并没有穿越CD这条边。而点C和点B则分别位于射线Y的两侧，所以射线Y和BC发生了穿越，由此我们可以断定点Y在多边形内。同理，射线X分别与AD和CD都发生了穿越，因此点X在多边形外，而射线Z没有和多边形发生穿越，点Z位于多边形外。 解决了第三点，这一点就毫无难度了。根据上面的假设，射线连续经过的两个顶点显然都位于射线以上的一侧，因此这种情况看作没有发生穿越就可以了。由于第三点的解决方案实际上已经覆盖到这种特例，因此不需要再做特别的处理。 左侧 计算几何 判断点在直线的左右哪一侧 直线的左右？？明显不对吧 将道理、左右是按照直线前进的方向来的。 判断点在直线的位置 判断点在线的左边还是右边在构建三角网时是非常重要的 以及两点p1(x1,y1),p2(x2,y2),判断点p(x,y)在线的左边还是右边。 1. bool LeftOfLine(const ZCoord2D& p, const ZCoord2& p1, const ZCoord2D& p2) { double tmpx = (p1.x - p2.x) / (p1.y - p2.y) * (p.y - p2.y) + p2.x; if (tmpx > p.x)//当tmpx>p.x的时候，说明点在线的左边，小于在右边，等于则在线上。 return true; return false; } 2.另外一种方法： Tmp = (y1 – y2) * x + (x2 – x1) * y + x1 * y2 – x2 * y1 Tmp > 0 在左侧 Tmp = 0 在线上 Tmp 3.向量叉乘法 设线段端点为从 A(x1, y1)到 B(x2, y2), 线外一点 P(x0，y0)， 判断该点位于有向线 A→B 的那一侧。 a = ( x2-x1, y2-y1) (以起点A作两个向量，不是以P) b = ( x0-x1, y0-y1) a x b = | a | | b | sinφ (φ为两向量的夹角) | a | | b | ≠ 0 时， a x b 决定点 P的位置 所以 a x b 的 z 方向大小决定 P位置 (x2-x1)(y0-y1) – (y2-y1)(x0-x1) > 0 左侧 (x2-x1)(y0-y1) – (y2-y1)(x0-x1) bool insidePolygon(Point * p, int n, Point A){ for(int i = 0; i 测试 int main() { cout 点在多面体内 如四面体： 对于四面体的每个平面,检查该点是否与剩余的顶点在同一侧: bool SameSide(v1, v2, v3, v4, p) { normal := cross(v2 - v1, v3 - v1) dotV4 := dot(normal, v4 - v1) dotP := dot(normal, p - v1) return Math.Sign(dotV4) == Math.Sign(dotP); } 你需要检查每架飞机: bool PointInTetrahedron(v1, v2, v3, v4, p) { return SameSide(v1, v2, v3, v4, p) && SameSide(v2, v3, v4, v1, p) && SameSide(v3, v4, v1, v2, p) && SameSide(v4, v1, v2, v3, p);} 可以通过四个顶点 ABC 和 D 来定义四面体。因此，您也可以使用 4 个三角形来定义四面体的表面。 您现在只需检查点 P 是否在平面的另一侧。每个平面的法线都指向远离四面体中心的方向。所以你只需要对 4 架飞机进行测试。 您的平面方程如下所示：ax+by+c*z+d=0 只需填写点值 (xyz)。如果结果的符号 >0，则该点与法线在同一侧，result == 0，点位于平面内，在您的情况下，您需要第三个选项： 11 判断线段是否在多边形中 12 多边形重心 多边形重心 方法一： 累加求和重心。 设平面上有n个点（xi，yi）(i=1、2、3……n)，其多边形重心G（x，y）为: 在这里插入图片描述 这是求多边形最简单直观的方法。可以直接利用数据点的x, y坐标就能求图形重心。但是缺陷在于没有对离散数据点所围图形做任何处理和分析,精度不够。 x = ∑xi / n y = ∑yi / n 方法二： 这里有几个定理需要用到： 定理一：已知三角形△A1A2A3的顶点坐标Ai ( xi, yi ) ( i =1, 2, 3) 。它的重心坐标为: xc = (x1+x2+x3) / 3 ; yc = (y1+y2+y3) / 3 ; 定理二：已知三角形△A1A2A3的顶点坐标Ai ( xi , yi ) ( i =1, 2, 3) 。该三角形的面积为: 　　S = ( (x2 - x1) (y3 - y1) - (x3 - x1) (y2 - y1) ) / 2 ; 　　△A1A2A3 边界构成逆时针回路时取+ , 顺时针时取 -。 　　 另外在求解的过程中，不需要考虑点的输入顺序是顺时针还是逆时针，相除后就抵消了。 方法： (1) 分割 以多边形的一个顶点O为原点（可以选输入的第一个点作为原点），作连接O与其他所有非相邻顶点的线段，将多边形（n条边）分为n-2个三角形。 (2) 求每个三角形的面积和重心 设其中一个三角形的重心为G（cx，cy）,顶点坐标分别为A1（x1，y1），A2（x2，y2），A3（x3，y3），则有cx = (x1+x2+x3) / 3 ; cy = (y1+y2+y3) / 3; 面积为 S = ( (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1) ) / 2 ; (3) 求多边形的重心 公式：cx = (∑ cx[i]*s[i]) / ∑s[i] ; cy = (∑ cy[i]*s[i] ) / ∑s[i];其中（cx[i], cy[i]）, s[i]分别是所划分的第i个三角形的重心坐标和面积。另外，在（2）中求每个重心坐标时要除以3，实际上不需要在求每个三角形坐标时都除以3，只需要求出∑ cx[i]*s[i]后一次性除以3即可。 参考： 计算几何初步 学习笔记：计算几何全家桶 3 经典问题 最小圆覆盖 （经典算法【三点定圆】） 最小圆覆盖 给定n个点，用一个最小的圆把这些点全部覆盖，求这个圆的圆心半径。 1.几何法 2.模拟退火法 即最小圆覆盖问题：给定n个点的平面坐标，求一个半径最小的圆，把n个点全部包围，部分点在圆上。（两种算法：几何算法和模拟退火算法） 几何法 于是，这个问题就被转化为若干个子问题来求解了 由于三个点确定一个圆，我们的过程大致上做的是从没有确定点，到有一个确定点，再到有两个确定点，再到有三个确定点来求圆的工作 时间复杂度：O(N) 空间复杂度：O(N) 小细节 Q1. 过三点如何求圆？ A1. 先求叉积 若叉积为0，即三个点在同一直线，那么找到距离最远的一对点，以它们的连线为直径做圆即可； 若叉积不为0，即三个点不共线，那么就求三角形的外接圆 Q2. 如何求三角形外接圆？ 几何算法： （1）加第1个点P1。C1的圆心就是P1，半径为0。 （2）加第二个点P2。新的C2的圆心是线段P1P2的中心，半径为两点距离的一半。这一步操作是两点定圆。 3）加第三个点P3。若P3在圆内或圆上，忽略；若不在，则以P3为圆心，重复（1）和（2），若还是不行则用三点定圆。 （4）加第四个点P4。若P4在圆内或圆上，忽略；若不在，则以P4为圆心，从前三个点中选择一个点重复（1）和（2）即两点定圆，若还是不行则选三个点进行三点定圆(一定有)。 （5）继续加入新的点。 复杂度分析：3层for循环，貌似是O(n3)，但是当点的分布是随机的时候，可以通过概论计算得到实际复杂度接近O(n)，代码中使用random_shuffle()函数实现。 #include #include #include #include #include #include #include using namespace std; typedef long long lt; #define eps 1e-6 #define sqr(x) ((x)*(x)) const int maxn=1000010; int n; struct point{ double x,y; }p[maxn],O; double R;//半径 double getd(point a,point b){ //求直径 return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y)); } point getO(point p1,point p2,point p3) { //求圆心 point res; double a=p2.x-p1.x; double b=p2.y-p1.y; double c=p3.x-p2.x; double d=p3.y-p2.y; double e=sqr(p2.x)+sqr(p2.y)-sqr(p1.x)-sqr(p1.y); double f=sqr(p3.x)+sqr(p3.y)-sqr(p2.x)-sqr(p2.y); res.x=(f*b-e*d)/(c*b-a*d)/2.0; res.y=(a*f-e*c)/(a*d-b*c)/2.0; return res; } void mincir() { O=p[1]; R=0; for(int i=1;ieps) { //不在圆内 O=p[i]; R=0; for(int j=1;jeps) {//不在圆内 O=(point){(p[i].x+p[j].x)/2.0,(p[i].y+p[j].y)/2.0}; R=getd(p[i],p[j])/2.0; for(int k=1;keps) {//不在圆内 O=getO(p[i],p[j],p[k]); //外接圆 R=getd(p[i],O); } } } } } } int main() { cin>>n; for(int i=1;i 模拟退火 #include #include #include #include #include using namespace std; const double eps=1e-8; struct POINT{ double x,y,z; }p[510]; POINT op;//最小圆的圆心 int n; inline double dist(POINT &a,POINT &b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } void solve(){ double ret,delta=100.0; double maxDis,tempDis; int i,id; while(delta>eps){ id=0; maxDis=dist(op,p[id]); for(i=1;imaxDis){ maxDis=tempDis; id=i; } } ret=maxDis; op.x+=(p[id].x-op.x)/maxDis*delta; op.y+=(p[id].y-op.y)/maxDis*delta; delta*=0.98; } printf(\"%.3f\\n\",ret); } int main(){ scanf(\"%d\",&n); op.x=op.y=0; for(int i=0;i 其他 https://easylearn.baidu.com/edu-page/tiangong/questiondetail?id=1733349032401936462&fr=search 圆内任取三点,形成钝角三角形概率? 问：圆内任取三点,形成钝角三角形概率? 答： 3/4; 1：在圆上任意取第一个点A； 2：再任意第二个点B,有AB重合、AB在同一条直径上两个特殊点, 但对于圆上的无数个点来说,B取到上面两个特殊点的概率为0； 所以可以使AB能够不重合且不在同一直径上的概率为1；以下叙述将不考虑上述两个特殊点； 由上所述,A、B两点的取法可以看做是任意取,概率为1； 3：再任意取第三点C,C有与A重合、与B重合两个特殊点,同上,可以忽略不计 设原点为O,则AO交圆于点D,BO交圆于点E,则C在弧DBAE时（D、B、A、E四点除外）,三角形ABC为钝角三角形； 由AB的长度从趋近于零,到趋近于直径,弧DBAE的长度由趋近于圆周长1,到趋近于半圆周1/2, 所以弧DBAE的平均长度为（1+1/2）/2 = 3/4; 所以三角形ABC为钝角三角形的概率为3/4 或： 随机A,连直径。 B，C在直径两侧：1/2 emm 好像还不是太好分析 B, C在直径同侧：1/2 只能是钝角 4 代码 汇总注释版 //定义点的类型 struct Point { double x, y; Point(double x = 0, double y = 0) : x(x) , y(y) { } //构造函数，方便代码编写 }; typedef Point Vector; //从程序实现上，Vector只是Point的别名 //向量 + 向量 = 向量 ，点 + 向量 = 点 Vector operator + (Vector A, Vector B) { return Vector(A.x+B.x, A.y+B.y); } //点 - 点 = 向量 Vector operator - (Vector A, Vector B) { return Vector(A.x-B.x, A.y-B.y); } //向量 * 数 = 向量 Vector operator * (Vector A, double p) { return Vector(A.x*p, A.y*p); } //向量 / 数 = 向量 Vector operator / (Vector A, double p) { return Vector(A.x/p, A.y/p); } bool operator 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1); } //点在直线上的投影 Point GetLineProjection(Point P, Point A, Point B) { Vector v = B - A; return A + v * ( Dot(v, P-A) / Dot(v, v) ); } //线段相交判定 bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) { double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) 汇总简洁版 struct Point { double x, y; Point(double x = 0, double y = 0) : x(x) , y(y) { } }; typedef Point Vector; Vector operator + (Vector A, Vector B) { return Vector(A.x+B.x, A.y+B.y); } Vector operator - (Vector A, Vector B) { return Vector(A.x-B.x, A.y-B.y); } Vector operator * (Vector A, double p) { return Vector(A.x*p, A.y*p); } Vector operator / (Vector A, double p) { return Vector(A.x/p, A.y/p); } bool operator 0 ? 1 : -1); } bool operator == (const Point& a, const Point& b) { return dcmp(a.x - b.x) == 0 && dcmp(a.y - b.y) == 0; } double Dot(Vector A, Vector B) { return A.x*B.x + A.y*B.y; } double Length(Vector A) { return sqrt(Dot(A, A)); } double Angle(Vector A, Vector B) { return acos(Dot(A, B) / Length(A) / Length(B)); } double Cross(Vector A, Vector B) { return A.x*B.y - A.y*B.x; } double Area2(Point A, Point B, Point C) { return Cross(B-A, C-A); } Vector Rotate(Vector A, double rad) { return Vector(A.x*cos(rad) - A.y*sin(rad), A.x*sin(rad)+A.y*cos(rad) ); } Vector Normal(Vector A) { double L = Length(A); return Vector(-A.y/L, A.x/L); } Point GetLineIntersection(Point P, Vector v, Point Q, Vector w) { Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t; } double DistanceToLine(Point P, Point A, Point B) { Vector v1 = B-A, v2 = P - A; return fabs(Cross(v1,v2) / Length(v1)); } double DistanceToSegment(Point P, Point A, Point B) { if(A==B) return Length(P-A); Vector v1 = B - A, v2 = P - A, v3 = P - B; if(dcmp(Dot(v1, v2)) 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1); } Point GetLineProjection(Point P, Point A, Point B) { Vector v = B - A; return A + v * ( Dot(v, P-A) / Dot(v, v) ); } bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) { double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) 距离 点到直线距离(中学版) 直线 Ax+By+C = 0, 点(a,b) d =|Aa+Bb+C|/sqrt(A^2 + B^2) 若直线ABC未知，可由两点确定直线A，B, C Ax1 + By1 + C = 0; Ax2 + By2 + C = 0; 相减 A(x1 - x2) + B(y1 - y2) = 0; 取 A = (y1 - y2), 则 B = (x2 - x1); C = x1 * y2 - x2 * y1; 其他 尚未整理 三角形面积 三边长 a, b, c 海伦公式 p = (a + b + c) /2 S = sqrt(p*(p - a)*(p - b)*(p - c)); 外接圆半径 四边形面积 一般四边形（凸四边形）的婆罗摩笈[jí]多公式 凸？？ 四个点顺序需要依次给出 否则由于C4—2构成6条边，不知道哪个四边形 对于圆内接四边形 可直接用婆罗摩笈多公式， 否则用 abh,hcd分别计算两个三角形面积求和， h 为第一个顶点和第三个顶点连线长度 百科：婆罗摩笈多公式 对于圆内接四边形 p = (a + b + c + d) /2 S = sqrt((p - a)*(p - b)*(p - c)*(p - d)); 否则还需要S = sqrt((p - a)(p - b)(p - c)(p - d) - abcdcos^2(theta)); theta = 四边形一对角和的一半 (圆内接四边形的对角和为pi) 海伦公式给出三角形的面积。它是婆罗摩笈多公式取d = 0的特殊情形。 其中S为四边形的面积，a、b、c、d为四边形的四边长度，θ为四边形任一对角和的一半，s为半周长（a+b+c+d）/2。 我们可以看出，角度θ并不是确定值，会随着四边形的不稳定而变化，只有当θ=90°时，四边形的面积是最大的，既四边形对角和为180°时。 另外，婆罗摩笈多公式在一条边等于零时，退化为三角形的海伦公式，其中的可变量θ与零相乘消失，海伦公式可以直接给出确定的三角形面积： 点 边 面 关系 多边形相交 用于碰撞检测 圆 struct Point { double x,y; Point(double x = 0, double y = 0):x(x),y(y){} }; Point Excenter(Point a, Point b, Point c){ double a1 = b.x - a.x; double b1 = b.y - a.y; double c1 = (a1*a1 + b1*b1)/2; double a2 = c.x - a.x; double b2 = c.y - a.y; double c2 = (a2*a2 + b2*b2)/2; double d = a1*b2 - a2*b1; return Point(a.x + (c1*b2 - c2*b1)/d, a.y + (a1*c2 - a2*c1)/d); } 计算几何代码欣赏 计算几何 - 二维几何基础 （模板） 二维下计算几何程序头 （模板） PPT-计算几何--ACM 类版本 #include #include using namespace std; const double epoints = 1e-9; int sgn(double a) { return (a > epoints) - (a --- 模板 1.计算几何 1.1 注意 注意舍入方式(0.5的舍入方向);防止输出-0. 几何题注意多测试不对称数据. 整数几何注意xmult和dmult是否会出界; 符点几何注意eps的使用. 避免使用斜率;注意除数是否会为0. 公式一定要化简后再代入. 判断同一个2*PI域内两角度差应该是 abs(a1-a2)pi+pi-beta; 相等应该是 abs(a1-a2)pi+pi-eps; 需要的话尽量使用atan2,注意:atan2(0,0)=0, atan2(1,0)=pi/2,atan2(-1,0)=-pi/2,atan2(0,1)=0,atan2(0,-1)=pi. cross product = |u||v|sin(a) dot product = |u||v|cos(a) (P1-P0)x(P2-P0)结果的意义: 正: 在顺时针(0,pi)内 负: 在逆时针(0,pi)内 0 : ,共线,夹角为0或pi 误差限缺省使用1e-8! 1.2几何公式 三角形: 半周长 P=(a+b+c)/2 面积 S=aHa/2=absin(C)/2=sqrt(P(P-a)(P-b)(P-c)) 中线 Ma=sqrt(2(b^2+c^2)-a^2)/2=sqrt(b^2+c^2+2bccos(A))/2 角平分线 Ta=sqrt(bc((b+c)^2-a^2))/(b+c)=2bccos(A/2)/(b+c) 高线 Ha=bsin(C)=csin(B)=sqrt(b^2-((a^2+b^2-c^2)/(2a))^2) 内切圆半径 r=S/P=asin(B/2)sin(C/2)/sin((B+C)/2) =4Rsin(A/2)sin(B/2)sin(C/2)=sqrt((P-a)(P-b)(P-c)/P) =Ptan(A/2)tan(B/2)tan(C/2) 外接圆半径 R=abc/(4S)=a/(2sin(A))=b/(2sin(B))=c/(2sin(C)) 四边形: D1,D2为对角线,M对角线中点连线,A为对角线夹角 a^2+b^2+c^2+d^2=D1^2+D2^2+4M^2 S=D1D2sin(A)/2 (以下对圆的内接四边形) ac+bd=D1D2 S=sqrt((P-a)(P-b)(P-c)(P-d)),P为半周长 正n边形: R为外接圆半径,r为内切圆半径 中心角 A=2PI/n 内角 C=(n-2)PI/n 边长 a=2sqrt(R^2-r^2)=2Rsin(A/2)=2rtan(A/2) 面积 S=nar/2=nr^2tan(A/2)=nR^2sin(A)/2=na^2/(4tan(A/2)) 圆: 弧长 l=rA 弦长 a=2sqrt(2hr-h^2)=2rsin(A/2) 弓形高 h=r-sqrt(r^2-a^2/4)=r(1-cos(A/2))=atan(A/4)/2 扇形面积 S1=rl/2=r^2A/2 弓形面积 S2=(rl-a(r-h))/2=r^2(A-sin(A))/2 棱柱: 体积 V=Ah,A为底面积,h为高 侧面积 S=lp,l为棱长,p为直截面周长 全面积 T=S+2A 棱锥: 体积 V=Ah/3,A为底面积,h为高 (以下对正棱锥) 侧面积 S=lp/2,l为斜高,p为底面周长 全面积 T=S+A 棱台: 体积 V=(A1+A2+sqrt(A1A2))h/3,A1.A2为上下底面积,h为高 (以下为正棱台) 侧面积 S=(p1+p2)l/2,p1.p2为上下底面周长,l为斜高 全面积 T=S+A1+A2 圆柱: 侧面积 S=2PIrh 全面积 T=2PIr(h+r) 体积 V=PIr^2h 圆锥: 母线 l=sqrt(h^2+r^2) 侧面积 S=PIrl 全面积 T=PIr(l+r) 体积 V=PIr^2h/3 圆台: 母线 l=sqrt(h^2+(r1-r2)^2) 侧面积 S=PI(r1+r2)l 全面积 T=PIr1(l+r1)+PIr2(l+r2) 体积 V=PI(r1^2+r2^2+r1r2)h/3 球: 全面积 T=4PIr^2 体积 V=4PIr^3/3 球台: 侧面积 S=2PIrh 全面积 T=PI(2rh+r1^2+r2^2) 体积 V=PIh(3(r1^2+r2^2)+h^2)/6 球扇形: 全面积 T=PIr(2h+r0),h为球冠高,r0为球冠底面半径 体积 V=2PIr^2h/3 凸包 半平面交 最小圆覆盖 三维计算几何基础 三维凸包 旋转卡壳 三角剖分 扫描线 自适应辛普森积分 矩阵 PNC:OSQP Apollo轨迹规划或mpc等算法中，求优化解时，使用的OSQP的二次规划求解器，其中通过调用csc_matrix()进行构建矩阵，即稀疏矩阵。 在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为稀疏矩阵； 与之相反，若非0元素数目占大多数时，则称该矩阵为稠密矩阵。定义非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。 稀疏矩阵 表示 稀疏矩阵的常规方式 下面是最常见的一种，也很好理解，(row，col)指向矩阵非零元素的索引，data里为该元素的值。 row = array([0,2,2,0,1,2]) col = array([0,0,1,2,2,2]) data = array([1,2,3,4,5,6]) csc_matrix( (data,(row,col)), shape=(3,3) ).todense() matrix([ [1, 0, 4], [0, 0, 5], [2, 3, 6] ]) 即 row[i], col[i]存储的数据为data[i]。 从row和col的值，可以看到非零元素值出现的位置为(0,0)，(2,0) ，(2,1) ，(0,2)，(1,2)，(2,2)，依次填入data值即可。 csc_matrix 按列压缩CSC—Compressed sparse column 顾名思义将每一列出现的非零元素的个数统计后放好… >>> indptr = np.array([0, 2, 3, 6]) >>> indices = np.array([0, 2, 2, 0, 1, 2]) >>> data = np.array([1, 2, 3, 4, 5, 6]) >>> csc_matrix((data, indices, indptr), shape=(3, 3)).toarray() array([[1, 0, 4], [0, 0, 5], [2, 3, 6]]) 解释: 比较正规的描述： indptr表示的是indices矩阵里的开始和结尾的index， indptr [0, 2]表示indices[0:2]存储了第一列的数据所位置0行和2行，indices[2:3]存储了第二列的数据位置，即2，第2行（注意从0行开始）， 每个indices[i]对应一个data[i]。 比较快速的理解就是：indptr[i+1]表示稀疏矩阵的第i列(包括i列)之前一共有多少个非零元素，这些非零元素对应的行，依次在indices 中取出来即可。 @ 第0列的非零元素个数为indptr[0+1]-indptr[0]=2-0=2个，从indices中可知对应的非零元素在0、2行，data对应的值为1、2，则第0列为{1 0 2}； @ 第1列的非零元素个数为indptr[1+1]-indptr[1]=3-2=1个，从indices中可知对应的非零元素在2行，data对应的值为3，则第1列为{0 0 3}； @ 第2列的非零元素个数为indptr[2+1]-indptr[2]=6-3=3个，从indices中可知对应的非零元素在0、1、2行，data对应的值为4、5、6，则第2列为{4 5 6}； 得到完整的矩阵。 csr_matrix 按行压缩CSR—Compressed sparse row 原理和CSC类似。 运算 稀疏矩阵的 +-×÷ 运算 csc表示如何计算运算？ 三元组法 参考： C语言 稀疏矩阵操作（三元组表示法） 稀疏矩阵计算器（三元组实现矩阵加减乘法） 行逻辑三元组稀疏矩阵加减乘的编程实现 @@ 待补充 Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-09-22 19:45:03 "},"02_智能车PNC笔记/":{"url":"02_智能车PNC笔记/","title":"第二部分：智能车PNC笔记","keywords":"","body":"暂不开放 一级标题 一级标题的内容 二级标题 二级标题的内容 三级标题 三级标题的内容 Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-04-23 00:08:20 "},"02_智能车PNC笔记/00_基础准备/基础准备.html":{"url":"02_智能车PNC笔记/00_基础准备/基础准备.html","title":"2.0 基础准备","keywords":"","body":"自动驾驶概述 车用地图 与 导航 自动驾驶汽车需要知道的环境信息可以划分为两部分：一部分是相对固定的环境信息，如车道、周边建筑等不会即时变化的要素；另一部分是会发生瞬时变化的交通组成部分，类似其他交通参与者、天气等。 对于前者，一般要提前采集后写到地图中去，即自动驾驶汽车使用的高精车用地图，再与传感器的探测结果结合使用，而后者，一般由汽车自带传感器完成即时感知。 车用高精地图 高精地图作为无人驾驶领域的稀缺资源以及必要数据基础，在整个领域扮演着核心角色。高品质的高精地图可以帮助汽车预先感知路面复杂信息，如坡度、曲率、航向等，结合智能路径规划，让汽车做出正确决策。 区别与传统导航地图 高精地图与现在常见的导航地图（如车载导航地图）相比有很大不同，主要体现在使用者不同、用途不同、所属系统不同、要素和属性不同。导航地图的使用者是人，用于导航、搜索路线。而高精地图的使用者是计算机，用于高精定位、辅助环境感知、决策与规划。因此导航地图在车内属于车载信息娱乐系统，带显示屏，而高精地图是自动驾驶系统的一部分，不需要通过屏幕进行展示。要素跟属性方面，导航地图仅包含简单道路线条、信息点（POI）、行政区划边界，而高精地图包含详细道路模型，包括车道模型、道路部件、道路属性和其他的定位图层。 层级 底层： 静态高精地图 车道模型、道路部件、道路属性和其他的定位图层 首先高精地图要满足车道级的自动驾驶导航，因此需要包含道路细节信息，如车道线、车道中心线、车道属性变化等，如能让汽车知道哪些区域是虚线，能够变道。车道模型中还需要包含道路的曲率、坡度、航向、横坡等数据信息，使汽车能够准确地转向、制动、爬坡等。这些信息构成了车道模型。此外，地图还需要包含交通标志牌、路面标志等道路部件，还要标注出特殊的点，如GPS消失的区域等。 上层： 动态高精地图 道路拥堵情况、施工情况、是否有交通事故、交通管制情况、天气情况等动态交通信息 使用场景 弱地图模式 地图只用来作为寻路和简单的定位辅助，其他还是靠汽车传感器做环境感知 强地图模式(L4,L5) 此时的地图是一个重要的传感器，各种传感器感知到的信息都会融合到地图中来，成为一种数据基础。 用于全局路径规划的图层 道路模型 车道层 辅助层 路径规划算法 总体上包括车队的调度以及交通管制的多汽车路径规划、以及单车路径规划。 路径规划可分为静态路径规划和动态路径规划。 主要以静态道路交通信息为基础的路径规划是静态路径规划；而动态路径规划主要以动态交通信息来确定路权大小，它以起始点和终止点间的交通阻抗最小为原则确定路径规划的最小代价路线。交通阻抗的定义根据实际应用的不同，可采取不同的阻抗标准，如最短行车距离、最少旅行时间、最低通行收费等。而距离、时间、收费等信息可存储在数字道路地图图层的道路属性中。最终计算道路网络中两点之间的最优路径问题便可归结为图论中求解带权有向图的最短路径问题。 因此由于问题特征、网络特征的复杂性的不同，最短路径算法也表现出多样性。按照一般问题的不同，最短路径问题可按下图所示进行分类。 算法 目前，自动驾驶汽车在求解全局路径规划问题上已经有许多成熟的算法。常见的算法包括Dijkstra算法、Floyd算法以及启发式搜索算法，如A\"算法等。Dijkstra算法是求解最优路径问题的最经典的算法，但它是一种盲目的搜索算法，在多年的研究中，各国学者都对其进行不断的改进，该算法的求解速度也大大提高。A'算法是启发式的搜索算法的代表，它在搜索过程中减小了网络图的搜索空间，从而节省了搜索的时间，因而计算效率较高。 Dijkstra 荷兰数学家E.W.Dijkstra于1959年提出了Dijkstra算法，它是一种适用于非负权值网络的单源最短路算法，同时也是目前求解最短路问题的理论上最完备、应用最广的经典算法。它可以给出从指定结点到图中其他结点的最短路径，以及任意两点的最短路径。 Dijkstra算法是一种基于贪心策略的最短路径算法，该种算法的原理是按照路径长度逐点增长的方法构造一棵路径树，从而得出从该树的根结点（即指定结点）到其他所有结点的最短路径。Dijkstra算法的核心思想为：设置两个点的集合S，和T，。集合S，中存放已找到最短路径的结点，T，集合中存放当前还未找到最短路径的结点。初始状态时，集合S，中只包含起始点，然后不断从集合中选择到起始结点路径长度最短的结点加入集合S，中。集合S，中每加入一个新的结点，都要修改从起始点到集合T，中剩余结点的当前最短路径长度值，集合S，中各结点新的当前最短路径长度值为原来最短路径长度值与从起始点过新加入结点到达该结点的路径长度中的较小者。不断重复此过程，直到集合中所有结点全部加人集合中为止。 Dijkstra算法过程包括了三个循环，第一个循环的时间复杂度为O（n），第二、三个循环为循环嵌套，因此总的时间复杂度为O（n2）。可以看出，Dijkstra最短路径算法的执行时间和占用空间与图（或网）中结点数目有关，当结点数目较大时，Dijkstra算法的时间复杂度急剧增加。当图（或网）规模较大时，直接应用该算法就会存在速度慢或空间不够的问题。所以，在大的城市交通网络图中直接应用Dijkstra最短路径算法是很困难的。路径规划作为无人驾驶汽车导航系统的重要功能模块，其算法的优劣是非常重要的，评价该算法的主要性能指标是它的实时性和准确性。Dijkstra算法作为经典的路径规划算法，在实验地图数据量较小情况下会得到很好的规划结果，但在实验地图数据量较大情况下很难满足路径规划的实时性要求 Floyd 核心思路是通过一个图的权值矩阵求出该图中任意两个结点之间的最短。 Floyd 算法是动态规划算法的一种，适用于APSP（All Pairs Shortest Paths），若用在稠密图中计算最优路径，效果更好，而且对边的权重是正是负没有特殊的要求。该算法简单有效，结构紧凑，因为含有三重循环，作用于稠密图，效率要比执行n次Dijkstra算法高得多。 算法的基本原理比较容易理解，算法的执行过程也相对简单，而且能够计算出任意两个结点之间的最短距离。但是由于其时间复杂度比较高，不适用于计算大量数据。 A*算法 以Dijkstra算法、Floyd算法为代表的最短路径算法虽然能够求得最短路径，但是计算量非常大。因此，这些算法只适应解决结点数较少的有向图。而实际中电子地图的结点数量却是非常庞大的，使用这些算法就会增加计算的工作量，因而不是最佳选择。 状态空间搜索是在一定的状态空间中，寻找从初始状态到目标状态的路径的过程。由于在求解问题的过程中存在很多分支，求解条件的不确定性和不完备性使得最终计算得到的路径有多条，这些路径就组成了一个图，这个图就是状态空间。问题的求解实际上就是在 这个图中寻找一条路径，可以从初始点顺利地到达目标点，这个寻找路径的过程就是状态空间搜索 常用的状态空间搜索包括深度优先搜索和广度优先搜索。广度优先搜索算法又称宽度优先搜索算法或横向优先搜索算法，是一种图形搜索算法。该算法是一种盲目搜索法，从初始结点逐层搜索，将遍历图中所有结点来找寻目标结点。深度优先搜索算法是图论中的经典算法。该算法是按照一定的顺序先查找一个分支，尽可能深地搜索该分支，直到遍历该分支的结点，若此时图中还有未被搜索过的分支，则继续遍历其他分支，直到找到目标点。这个遍历图的过程实际上是查找每个顶点或弧的邻接点的过程。广度优先搜索算法和深度优先搜索算法的过程基本相同，不同之处在于两者对顶点的查找顺序不同。它们都是在一个给定的状态空间中，通过遍历所有结点的方式，寻找需要找到的目标点及其路径。在状态空间不大的情况下，这两种算法都适用。但是当状态空间十分大，而且存在许多无法预测的情况下，这两种算法就不是最佳选择。这种遍历的搜索过程具有盲目性，因此效率比较低，而且在有限的时间内可能无法搜索到目标点，此时就要用到启发式搜索。 启发式搜索就是在状态空间中搜索，同时在搜索过程中加人与问题有关的启发式信息引导搜索朝着最优的方向前进。该方法会评估每一个搜索到的结点，通过比较搜索到的结点的评估值选择出最好的结点，然后将这个最好的结点作为下一次搜索的起始点，沿着搜索的方向继续搜索，直到搜索到目标点。一般来说，一个城市的电子地图有上万个结点，由于启发式搜索不需要遍历网络中的所有结点，这样就可以忽略大量与启发信息无关的结点，提高了搜索效率。在启发式搜索中，对结点的估价十分重要，采用不同的估价标准会产生不同 的结果 A算法是建立在Dijkstra算法基础上的启发式搜索算法，多应用于实现道路网的最佳优先搜索。该算法的主要特点是：在选择下一个搜索结点时，通过引人多种有用的路网的信息，计算所有的候选结点与目标点之间的某种目标函数，例如最短行车距离、最短行车时间、最少行车费用等，以此目标函数值为标准来评价该候选结点是否为最优路径应该选择的结点，符合所选择的最优目标函数的候选结点将优先选择为进行下一次搜索的起点，A算法已逐渐广泛地应用于各个领域，不仅仅是应用于无人驾驶汽车的路径规划，同时也较多地应用于机器人和其他要求最小费用解的领域。该算法的优点在于利用含有有效信息的启发函数，使搜索方向更加智能地趋向于终点，所以该算法搜索的结点数少，故占用的存储空间也少。 A算法是一种智能搜索算法，它通过引人与目标点有关的启发式信息，指引算法沿着最有希望的方向进行搜索。选择带有合理、准确的启发式信息的估价函数，有助于减小搜索空间、提高效率。采用启发信息的目的是估计当前结点与目标结点之间的距离，在进行结点的选择时，优先选择具有最小估价值的结点 A算法的关键是确立如下形式的启发式估价函数：f'（n）= g（n）+ h'（n） 式中：g（n）是从起点s到候选结点n的实际代价；h'（n）是从候选结点n到目标点D的估计代价。必须保证h'（n）（n），其中h （n）表示结点n到目的地结点的实际最小代价，该算法在搜索的过程中，优先搜索f'（n）值最小的结点启发式估价函数的合理选择关系着算法是否能够找到最优路径。启发式估价函数要求 具有良好的启发能力，能提供有用且准确的启发性信息。一般地，如果提供的启发性信息不够准确，或实用性较差，那么，在搜索到一条路径前可能会扩展很多无用的结点。这样就导致了搜索时间长，同时也占用了较大的存储空间。因此，引入合理的启发式估价函数是非常重要的。 A\"算法在搜索过程中会建立两个表：OPEN表和CLOSE表。OPEN表中存储的是已经生成但是还没有被扩展的结点，GLOSE表中存储的是已经被扩展的结点。每扩展个结点，都要计算其代价值。若新扩展的结点已存在于OPEN表中，则比较这两个结点的代价值的大小，用代价值小的点替换代价值大的点。每次扩展一个新的结点，都会根据所采用的启发式信息进行排序 设初始结点为S，目标结点为T，则搜索由S到T的最优路径的具体步骤如下。 （1）建立空的OPEN表和CLOSE表。把起点S放人OPEN表中，CLOSE表为空，此时其他结点与起点S的距离为00。 （2）如果OPEN表为空，则搜索失败，算法结束。否则扩展S结点，选取OPEN表中f'值最小的结点，并将该结点从OPEN表移至CLOSE表中，同时判断该结点是否为目标结点。若是目标结点，则从该结点回溯，即从该结点的后向指针一直到初始结点遍历结点获得最优路径，算法结束；若该结点不是目标结点，则继续扩展下一结点。 （3）依次扩展S结点后，扩展S结点的所有后继结点组成集合A，遍历A中的结点，如果存在某一结点既不在OPEN表中也不在CLOSE表中，将该结点放入OPEN表中，同时计算该结点的估价值，并对该结点的代价值与已经存在于OPEN表或CLOSE表中的结点代价值进行比较。若该结点的代价值小于其他两个估价值，则更新OPEN表中的代价值及其父结点， （4）根据所选取的估价函数计算各点的估价值，并按照估价值递增的顺序，对CLOSE表中的所有结点进行排序，这些结点的扩展过程就是通过算法计算得到最优路径。至此，算法结束 RRT 另外，对于高维度的路径规划问题。1998年，La Valle第一次提出了快速扩展随机树 （Rapidly Exploring Random Tree，RRT）算法，它是一种具有采样概率完备性的路径规划算法。 作为一个采用树形结构的规划算法，快速扩展随机树可以用来解决在高维度空间的路径规划问题，其核心的思想就是以给定的起始点作为该树的根结点，从根结点出发依次向状态空间中扩展子结点，子结点得到的方式都是通过在状态空间中随机采样的形式得到的，如果子结点不与障碍物发生碰撞则把子结点加人到树中，更新原来的扩展树的状态，生成新的随机扩展树，如此循环往复，直到扩展到终点，就可以得到状态空间中的一棵扩展树。该树包含了路径给定的起始点和终止点，最后从终点反向溯源到起始点，就可以得到规划的路径。该算法相对于其他算法之所以快速，主要是它以随机采样的形式来探索整个状态空间，可以以最快的速度完成对整个空间的遍历。 发展 与汽车动力学结合 汽车在车道中的相对位置、加速度、横摆角速度以及曲率等、车动力性、操纵性和稳定性评价指标等作为优化指标 与状态参数结合 与机器学习结合 # 全局路径规划 类似导航，但又不完全相同。主要在于运用高精地图。 全局路径规划的目标是根据已知电子地图和起点、终点信息，采用路径搜索算法生成条最优化的（时间最短、路径长度最短等）全局期望路径。这种规划可以在行驶前离线进行也可以在行驶中不停地重规划。 以国家自然科学基金委组织举办的“中国智能车未来挑战赛”为例，比赛组织方赛前提供了比赛的路网定义文件（RNDF），各比赛队伍可以根据RNDF规划出全局期望路径。 全局路径规划中，规划路径以全局的大地坐标系为参考，因此全局期望路径也是以全局坐标的形式给出。全局规划的作用在于产生一条全局路径指引汽车的前进方向，避免汽车盲目地探索环境。 在规划全局路径时，不同的环境下常常会选择不同的择优标准。在平面环境中，通常以路径长度最短或时间最短为最优标准，城市环境下的全局路径规划甚至要参考道路施工和拥堵情况、天气等因素。在越野环境的全局路径规划中，经常以“安全性”为最优标准，在使用该标准时要考虑路径可行宽度和路面平整度来充分保证汽车的运行安全。 行为决策 行为决策接收全局路径规划的结果，同时也接收感知、预测和地图信息。综合这些输入信息，行为决策模块在宏观上决定了自动驾驶汽车如何行驶。这些行为层面的决策包括在道路上的正常跟车或者变道、在遇到交通灯和行人时的等待避让，以及在路口和其他汽车的交互通过等。例如，全局路径模块要求自动驾驶汽车保持在当前车道（Lane）行驶，当感知到前方有一辆正常行驶的汽车时，行为决策的一个决定便很可能是下达跟车（Follow）命令。行为决策模块根据具体实现不同，在宏观上定义的输出指令集合也多种多样。 行为决策层需要的信息： （1）可以到达目的地的全局路径规划结果：如自动驾驶汽车为了到达目的地，需要进入什么道路，在哪一个路口左/右转，在哪里直行。（2）自动驾驶汽车的当前自身状态：车的位置、速度、朝向，以及当前主车所在的车道、按照寻径路由需要进入的下一个车道等。 （3）自动驾驶汽车的历史决策信息：在上一个计算周期，行为决策模块所做出的决策是什么？是跟车、停车、转弯或者是换道？ （4）自动驾驶汽车周边的障碍物信息：自动驾驶汽车周边一定距离的所有障碍物信息。例如，周边的汽车所在的车道，邻近的路口有哪些汽车，它们的速度、位置如何，以及在一个较短的时间内它们的意图和预测的轨迹，周边是否有骑车人或者行人，以及他们的位置、速度、轨迹等。 （5）自动驾驶汽车周边的地理信息：一定范围内车道的结构变化情况，如前方50m处有车道变窄或新增车道，前方30m处车道边线由虚线变成实线，前方是否有人行横道、红绿灯、前方道路限速，哪条车道可以在前方路口左转、右转和直行等。 自动驾驶汽车的行为决策模块，就是要在上述所有信息的基础上，做出如何行驶的决策。可以看出，自动驾驶汽车的行为决策模块汇集了不同来源的信息。由于需要考虑复杂的、不同类型的信息及考虑不同地区的交规限制，行为决策问题往往很难用一个简单的数学模型求解。 交通环境行为预测 运动预测根据预测时间的长短可以分为长期(如数秒，10s)预测与短期(如1s)预测，将涉及意图识别、行为预测和轨迹预测（运动预测）三个层面的内容。一般来说，若能充分考虑汽车的行驶意图，长期运动预测的结果将更加准确。一般认为意图、行为和汽车运动状态三者的抽象程度依次降低，意图为驾驶员做出某种行为的目的，行为是一段连续的运动状态的抽象，而运动状态则是汽车所体现出来的一些运动变量（位置、姿态、速度、加速度等）的集合。 按类型 - 障碍车辆 - 根据驾驶场景、道路拓扑、以及行驶方向可大致分析其驾驶意图和预测轨迹 - 行人等 - 不确定性高 按时长 - 短期：行为意图未变化时，根据运动学或动力学可推测 - 长期：需要根据动力学以及意图等综合推测 对障碍车辆行为预测 基于物理模型 基于物理模型的轨迹预测是基于物理的运动模型将汽车表示为受物理定律支配的动态实体。使用动力学和运动学模型预测未来运动，将一些控制输入（例如转向、加速度），汽车属性（例如重量）和外部条件（例如路面的摩擦系数）与汽车状态的演变（例如位置）联系起来。有大量的工作基于物理的汽车运动模型进行轨迹预测，这种方法仍然是道路安全背景下最常用的轨迹预测和碰撞风险评估的方法。 这些汽车模型的复杂程度不一，它们的区别在于模型的动力学和运动学表现、如何处理不确定性、是否考虑道路的几何形状等， （1）动力学模型 一般来说，汽车动力学模型基于拉格朗日方程，考虑影响汽车运动中不同力的作用，例如纵向和横向轮胎力或道路倾斜角。汽车受到复杂物理学（驾驶员对发动机、变速器、车轮等的作用的影响）的控制，因此动力学模型可能非常复杂并且涉及汽车的许多内部参数。建立这种复杂的模型在涉及与汽车控制相关的计算时可能是有必要的，但在轨迹预测中，为了简化计算，一般会使用更简单的模型。因此在轨迹预测中，常常采用“自行车”模型代替复杂的汽车动力学模型，这意味着将四轮汽车简化为两轮汽车，并在二维平面上移动， （2）运动学模型 运动学模型基于运动参数（例如位置、速度、加速度）之间的数学关系来描述汽车的运动，而不考虑影响运动的力。在运动学模型中，摩擦力被忽略，并假设每个车轮的速度都与车轮方向相同。在轨迹预测方面，运动学模型比动力学模型的应用更加广泛。此外，由于动力学模型所需的汽车的内部参数不能被外部传感器观察到，使得动力学模型在很多场景中无法应用。 运动学模型中最简单的是恒速度（CV）和恒定加速（CA）模型，它们都假定汽车是直线运动的。恒转速和速度（CTRV）以及恒转加速度和加速度（CTRA）模型通过在汽车状态向量中引人偏航角和偏航率变量来考虑绕z轴的变化。由于速度和偏航率是分离的，因此模型复杂度很低。通过考虑转向角而不是状态变量中的横摆率，可以用“自行车”模型来表示汽车模型。这种模型考虑了速度和横摆率之间的相关性，从中可以导出恒定转向角和速度（CSAV）以及恒转加速度和加速度（CSAA） 区别 上述提到的汽车模型可以以各种方式用于轨迹预测，它们之间的主要区别在于如何处理预测的不确定性。单轨迹模拟预测汽车未来轨迹的直接方式是将汽车模型应用于汽车的当前状态，假设当前状态是完全已知的并且汽车模型能完美预测汽车的运动。这种方法可以基于动力学模型或运动学模型，如图3.2所示。这种正向仿真方法的优势在于其计算复杂度低，可以很好地满足实时性的要求。然而，预测没有考虑当前状态的不确定性和汽车模型的缺点，因此计算出的长期预测（超过1s）轨迹是不可靠的。 当前汽车状态及其预测的不确定性可以通过正态分布来建模。用“高斯噪声”来表达不确定性的方法最早来自于卡尔曼滤波器（KF）中。卡尔曼滤波可以从噪声传感器的测量结果中递归地估计汽车状态，是贝叶斯滤波的一种特例。在卡尔曼滤波中，一般假设汽车模型和传感器模型是线性的，并且使用正态分布表示不确定性。在第一步骤（预测步骤）中，将时间t处的估计状态馈送到汽车模型，得到t+1时刻的预测状态，其采用高斯分布的形式。在第二步骤（更新步骤）中，将t+1时刻处的传感器测量值与预测状态组合成t+1时刻的估计状态，其也是高斯分布。每次新测量可用时，循环预测和更新步骤称为滤波。通过循环 预测步骤，可以获得每个未来时间步长的汽车状态的均值和协方差矩阵，并将其转换为具有不确定性的预测轨迹（每个时间点的不确定性正态分布），如图3.3所示。与“单轨迹模拟” 方法相比，这种方法可以计算预测轨迹的不确定性。然而，使用单峰正态分布建模的不确定性并不能准确地建模现实世界中的不确定性。因此有的方法使用高斯混合来建模不确定性。开关卡尔曼滤波器（SKF）依靠一组卡尔曼滤波器来建模汽车的可能变化模型并在它们之间切换。也可以使用启发式方法根据实际情况在不同的运动模型之间切换。 持续速度模型下的轨迹预测 高斯分布下的轨迹预测 扩展卡尔曼滤波（EKF）理论可以利用系统最新状态估计结合系统动力学模型对系统将来状态进行进一步估计。这种方法主要基于运动汽车的运动学方程导出其非线性模型，进而对汽车的将来位置与方向进行预测。其中，协方差矩阵经过分析和转换可以用作卡尔曼滤波过程中不确定性的置信度度量，作为衡量预测质量的指标。 在一般情况下，尽管计算预测轨迹时都假设模型是线性的或考虑不确定性的高斯分布，但一般来说预测状态上的分布的解析表达式并不一定符合假设。蒙特卡洛方法提供了近似表达这种分布的工具，其可以从汽车模型的输入变量中随机抽样，生成可能的未来轨迹。为了考虑道路拓扑，可以对抽样过程应用权重，使所生成的轨迹遵守道路布局的约束。对于汽车模型，在蒙特卡洛方法中可以直接在输入空间中进行采样，要采样的典型输入是加速度和转向角或横向偏差。为了考虑预测轨迹的可行性，一般通过对汽车的现实物理特征进行约束，以便汽车模型的输入以更加真实的方式分布。蒙特卡洛方法计算的预测轨迹如图3.4所示。蒙特卡洛方法可用于从完全已知的当前状态或通过滤波算法估计的不确定当前状态来预测汽车的轨迹。 基于行为模型 基于原型轨迹 分类 聚类 高斯混合模型GMM K-Means对侧向加速度进行分类@ 考虑 对自车换道？路口的识别 匹配 度量：相似度，如最长公共序列LCSS 缺点 依赖路面拓扑结构信息 可拓展性差 对速度变化较大的场景（十字路口汽车停车、起步等）度量难 基于驾驶意图 分类识别 Support Vector Machines，SVM）结合贝叶斯滤波（BayesianFiltering）的方法实现识别 递归神经网络（Recurrent Neural Network，RNN）、前向反馈神经网络（Feedforward Neural Network，FNN）和支持向量机方法在预测道路中他车换道行为 原理 基于可观测的他车状态信息及环境信息作为证据变量来对汽车的行为意图等隐藏变量进行求解 基于机器学习的方法来识别汽车的行驶意图，并不依赖于原型轨迹，因此可以用于任意的道路结构。在利用这一类方法进行行驶意图的估计时，需要先定义一个有限的行为集合（包括车道保持、换道、超车、路口转向等），然后根据感知到的道路汽车运动特征对汽车未来的行为进行分类。这些特征包括可以通过传感器观测的交通车状态变量（车速、加速度、位置、驶向、转向灯等），道路结构（如十字路口、匝道、高速公路），交通信息（交通信号灯、标识牌、交通规则等） 基于神经网络 LSTM LSTM是RNN的一种形式，通过一个存储器单元来代替网络的每一个结点，解决了梯度弥散的问题。通过“门”（Gate）来控制丢弃或者增加信息，从而实现遗忘或记忆的功能。“门”是一种使信息选择性通过的结构，由一个Sigmoid（）函数和一个点乘操作组成。 Sigmoid（）函数的输出值在[0，1]区间，0代表完全丢弃，1代表完全通过。一个LSTM单元有三个这样的门，分别是遗忘门（Forget Gate）、输入门（Input Gate）和输出门（Output Gate）。 存储器单元：决定和积累单元要记忆的内容。输入门限：决定输人信息是否被允许进人模组输出门限：决定输出是否要被模组向外传送。 上述架构使得LSTM模组能够存储和检索任意时长的信息。不同于一般的RNN，LSTM中的反向传播误差不会随着时间指数下降，而且模型很容易训练。因此研究LSTM在周围汽车轨迹分类中的应用十分有必要。 基于交互 基于交互的轨迹预测在对他车环境进行运动预测时，将自车和周围的其他汽车看作是相互影响的，考虑了它们之间的行为依赖关系。因此，比起基于行为模型的轨迹预测，它能够提供更加准确可靠的预测结果。考虑交通参与者之间的交互时，其中一种方法是假设所有驾驶员都尽量避免碰撞，并选择风险最小的驾驶行为。这种方法首先计算每个汽车行驶意图的先验概率分布，然后再通过建模汽车之间的交互关系进行风险评估，进而对先验分布进行修正。这种方法在大多数正常驾驶场景下可以取得很好的效果，但是在一些真正危险的场景下可能会出错。 另一种考虑汽车交互影响的方法是利用动态贝叶斯网络。这种方法在进行行为推理时将汽车之间（Agent（i）、Agent（j））的交互也考虑进来，Agent（j）的运动状态x，-1（j）将对Agent（i）的场景状态ct（i）产生影响。在数学上实现时汽车之间的交互被分解为成对依赖性的对数线性组合。同时在建模汽车的行为时，将交通规则也考虑了进去，然后使用统计推理来计算运动状态的后验概率分布。 使用动态贝叶斯网络建模汽车之间的交互问题时，常常基于因素状态计算汽车之间的因果依赖关系，并建立局部场景的函数，这种方法可以大大减少计算的复杂度为了处理交通场景中汽车之间的行为交互，基于博弈论（Game Theory）的方法也引起了研究者的兴趣。 基于仿生学 基于综合 对汽车轨迹进行长期预测，不仅利用了汽车的历史轨迹信息，还利用了驾驶场景的特征信息，例如通过对道路结构进行建模，帮助对弯道路段进行轨迹预测。在这一过程中，利用回归神经网络从汽车历史轨迹中学习汽车行为并结合道路结构特征，对汽车未来轨迹进行预测 汽车轨迹预测能够帮助自动驾驶汽车更好地了解交通环境、提前执行危险性评估等任务。有的轨迹预测方法通过结合基于物理模型与行为模型的轨迹预测来实现。这两种方法相结合的优势在于基于物理模型的轨迹预测可以在考虑汽车动力学参数的情况下确保短期内预测的准确性，而基于行为模型的轨迹预测可以实现长期的预测。此外，可以在基于物理模型的轨迹预测中融合无迹卡尔曼滤波器来实现对不确定性信息的预测。基于行为模型的轨迹预测则将不确定性随机元素引入到动态贝叶斯网络中，用以推断每个行为过程对应的轨迹 对障碍行人行为预测 特点 随机性 即要符合物理约束、又要符合社会规范(结伴、礼让) 行人间相互影响： 躲避、跟随、追赶、超过 如何预测多个合理轨迹 方法 基于社会力 基于马尔可夫模型 基于循环神经网络 基于生成对抗网络 安全性评估 评估决策模块输出结果 RSS(Responsibility Sensitive Safety)责任敏感模型 Mobileye提出 用数学公式计算自车安全状态 原则： （1）自动驾驶汽车绝对不可以因为自身的原因引发碰撞或者事故； （2）当别的汽车造成潜在风险并且可能会产生交通事故的时候，自动驾驶汽车应采取怎样恰当的应对方式，来避免可能发生的交通事故。 在实际建立模型的时候，RSS模型通过四条形式化的规则，来确保汽车在自动驾驶状态下能够保证安全以及避免成为制造车祸的一方： （1）和前车保持安全距离； （2）给侧边的人或车留下足够的反应时间和空间； （3）在堵车的时候更谨慎； （4）要合理使用路权（路权的使用应优先考虑安全）。 场景 Mobileye发布了一份官方报告，列举了37种可能发生事故的场景，包括了汽车并行状态的安全间距、安全并线的间距、避免追尾的最小安全距离、路边有行人闯入机动车道时的安全车速等。这37种状况基本覆盖了99.4%的车祸可能性，也说明RSS模型目前已经非常完善，处在健全、可用的状态。 汽车行为决策理论 要求 实时性、安全性 行为决策系统首先会分析道路结构环境，明确自身所处的驾驶场景。接着在此基础上，针对特定的驾驶场景，基于基本交通规则或驾驶经验组成的驾驶先验知识，在多个可选行为中基于驾驶任务需求等要素条件，选择此场景下的最优驾驶行为。 决策算法 基于规则的行为决策 核心思想是利用分治的原则将自动驾驶汽车周边的场景进行划分。在每个场景中，独立运用对应的规则来计算自动驾驶汽车对每个场景中元素的决策行为，再将所有划分的场景的决策进行综合，得出一个最后综合的总体行为决定。首先引人几个重要概念：综合决策（Synthetic Decision）、个体决策（Individual Decision）以及场景（Scenario）。 综合决策 综合决策代表自动驾驶汽车行为决策层面的整体最高层的决策，例如按照当前车道跟车保持车距行驶，换道至左/右相邻车道，立刻停车到某一停止线后等； 输出：指令 + 参数 个体决策 个体决策指的是对所有重要的行为决策层面的输人个体，都产生一个个体决策。这里的个体，可以是感知输出的路上汽车和行人，也可以是结合了地图元素的抽象个体，如红绿灯或者人行横道对应的停止线等。 因此，综合决策是在场景划分的基础上产生每个场景下的个体决策，再综合考虑归纳这些个体决策，得到最终的综合决策。个体决策不仅是产生最后的综合决策的元素，而且也和综合决策一起被传递给下游运动规划模块。 个体决策有利于下游路径规划模块的求解，还能帮助工程师在软件开发过程中进行决策模块的调试。 格式同综合决策 场景 将场景理解成一系列具有相对独立意义的自动驾驶汽车周边环境的划分。 利用这种分而治之的思想进行场景划分，可以将自动驾驶汽车行为决策层面汇集的汽车周边的不同类别的信息元素，聚类到不同的富有实际意义的场景实体中。 在每个场景实体中，基于交通规则，并结合主车的意图，可以计算出对于每个信息元素的个体决策，再通过一系列准则和必要的运算把这些个体决策最终综合输出给下游。 总结 整个行为决策层面的框架和运行流程如下图所示。首先是结合主车信息、地图数据及感知结果构建不同层次的场景。在全局路径规划的指引下，每个场景结合自身的规则（往往是交规或者安全避让优先），计算出属于每个场景物体的个体决策。在所有的个体决策计算完毕后，虽然发生的概率极其微小，但模块还是会检查有无冲突的个体决策。在对冲突的个体决策进行冲突解决（往往是优先避让）后，推演、预测当前的所有个体决策能否汇总成- 个安全行驶无碰撞的综合决策。如果这样的安全无碰撞综合决策存在，便将其和个体决策起输出给下层的运动规划模块，计算具体从当前位置到下一个位置的时空轨迹。 有限状态机FSM Finite State Machine： Darpa自动驾驶汽车竞赛中，Stanford斯坦福大学设计。 马尔可夫MDP、POMDP部分可观测马尔可夫决策 轨迹规划 (另见规划笔记部分) 1.可行驶区域生成 表示 Voronoi图 Voronoi图通过最大化汽车与周围障碍物之间的距离来生成路径。 用于静态停车场场景。 占用栅格/成本地图 占用栅格（Occupancy Grid）与成本地图的含义相似，都将状态空间划分为网格。这些网格的每个单元都代表当前单元被障碍物占用的概率，或者代表与网格可通行性和风险成比例的代价值。风险或可行性主要通过考虑障碍物、车道和道路边界来进行计算。 在计算能力较低的情况下，基于网格的方法能快速找到解决方案，但在解决非线性动力学问题的鲁棒性方面和存在障碍物时存在困难。 占用网格可以包含障碍物的位置和速度，从而显示出它们的预期运动；而在成本地图中，某个单元格的成本越高，其在地图上的呈现就越强烈。 - 状态网格 - 状态网格法（State Lattice）可以视为网格生成的过程。 以通过重复矩形或正方形来构建网格以使连续空间离散的方式，通过定期重复原始路径来构造网格。所述原始路径在位置、曲率或时间方面与汽车的可能状态相关联， - 驾驶通道 - 驾驶通道代表了一个连续的无碰撞空间，受到道路和车道边界以及其他障碍物的限制，汽车将会在其中行驶。驾驶通道的生成基于详细数字地图上给出的车道边界信息，或者基于同时定位和建图（SLAM）技术建立的地图。 对比 2. 局部轨迹生成方法 场景 高速 行车环境简单 但 车速快，要求对车辆控制精度高 难点在于 对环境信息获取的位置精度和路径搜索的速度 城市 环境复杂，障碍车辆多、道路特征识别 难点在于 对动态障碍方向和速度的预测 越野 没道路边界，但起伏。 难点在于 可行驶区域的识别 轨迹评价 偏移 碰撞 速度 舒适 生成方法 直接构造 初始和终止位置 5次多项式 构造汽车后轴中心坐标关于时间的函数。该函数可使用5次多项式，构造出来的路径充分拟合初始和终止位置、速度和加速度的路径，适应非结构化的环境。基于5次多项式构造路径有利于保证汽车行驶平稳性，原因在于这种路径加速度变化率最小。 然而，若要保证规划出来的整条路径在速度、加速度、曲率和曲率变化率方面的有界性，该方法还需不断调整轨迹时间区间。 运动轨迹的几何表达方式(详情见书P62-66) 直线/圆弧段 Dubins曲线和Reeds-Shepp曲线都是由最大曲率圆弧和直线组成的，是连接构形空间中任意两点的最短路径，分别对应无倒车和有倒车的情况。存在圆弧和直线连接处曲率不连续的问题时，汽车依据曲线行驶时需曲率不连续处停车调整方向轮才能继续行驶。回旋线可以帮助解决此问题，改造Dubins曲线和RS曲线。回旋线曲率与曲线长度成正比关系，适合作为直线到圆弧之间的过渡曲线，保证曲率连续性， 多项式螺旋线 -这种线条的曲率是曲线长度的多项式函数。回旋线是一种特殊的多项式螺旋线。基于这种线条规划运动轨迹，求解效率较低。为了求解曲线形状，在给定边界条件后，必须使用数值手段求解多项式中的待定系数。 样条曲线 曲率具有连续性。B样条曲线可以实现曲率连续性；三次Bezier曲线可以保证曲率的连续性和有界性；n曲线也有很好的曲率连续性和曲率导数的连续性，它是种七次样条曲线，对于高速行驶汽车的安全行驶而言，这类性质非常重要 贝塞尔 特点 缺点(不灵活、高阶时、不能局部调整) B样条： 可局部调整、连续性、凸包性、分段参数多项式、几何不变性、仿射不变性、造型灵活 路径-速度分解法 有移动障碍物的环境下，可以通过将运动规划拆分成避开静态障碍物与避开移动障碍物的过程。在构造一条路径避开静态障碍物的基础上，进行速度规划以避开移动障碍物。 对比： 直接构造法规划得到的运动轨迹，需满足速度、加速度、曲率和曲率导数的有界性，更为复杂； 路径-速度分解法将构造曲率连续有界的路径与在此路径上生成连续有界的速度且保证加速度、曲率导数有界性的过程分开，运动轨迹规划难度降低。 局部轨迹生成算法 基本算法 DFS 深度优先搜索算法的思想是，搜索算法从起点开始进行搜索（初始状态下待搜索区域内所有结点均未被访问），与周围所有邻点进行比较，选择其中距离终点最近的点进行存储，然后再以该邻点为基础对比其周围未被访问的所有邻点，仍然选择距离终点最近的邻点存储。若访问结点到达终点或访问完所有结点仍未到达终点，则视为搜索失败。成功搜索所存储的结点连接而成的路径即为起点到终点的路径 BFS 广度优先搜索又称为宽度优先搜索或横向优先搜索。它的原理是，从初始点出发依次访问与它相连接的邻点，访问完毕后再从这些邻点出发访问邻点的邻点，但是要保证先被访问的邻点的邻点要比后被访问的邻点的邻点先访问，直至图中所有已被访问的结点的邻点都被访问到。如果此时图中尚有未被访问的结点，则需要选取一个尚未被访问的结点作为个新的初始点，继续搜索访问，直到图中所有的结点都被访问一遍为止。 对比： 因此，深度优先算法与广度优先搜索算法从过程上存在较大差异。深度优先算法优先选择离目标点最近的结点，而广度优先搜索算法优先选择离初始点最近的点。 基于深度优先算法，能以最快的速度找到一条连接初始点到目标点的路径，但不能保证路径的最优性（例如，以路径最短为标准）；广度优先搜索算法则必然能找到最短的路径，但由于需要遍历所有的结点，其计算复杂程度更大。 基于这两种算法的优缺点，A'算法基于启发函数构建了代价函数，既考虑了新结点距离初始点的代价，又考虑了新结点与目标点距离的代价。 A [A 寻路算法](http://www.cppblog.com/christanxw/archive/2006/04/07/5126.html) A算法是一种启发式的搜索算法，它是基于深度优先算法（Depth First Search，DFS） 和广度优先算法（Breadth First Search，BFS）的一种融合算法，按照一定原则确定如何选取下一个结点。启发式搜索算法指的是，从起点出发，先寻找起点相邻的栅格，判断它是否是*最好的位置，基于这个最好的栅格再往外向其相邻的栅格扩展，找到一个此时最好的位置，通过这样一步一步逼近目标点，减少盲目的搜索，提高了可行性和搜索效率。 对bfs的优化：由队列 变成 优先队列 BFS是一层一层扩展的，也就是我们有目前已经在第i步的所有状态，之后由它们拓展出所有第i+1步的状态。 很容易想到，当前的所有状态是有优劣之分的，也就是有的状态很可能是正解的必经状态，而有的状态则与正解差了十万八千里。如果我们优先拓展最优的状态，那么就会更快地接近目标。而状态优劣的判断标准显然可以是f 。 BFS通常使用队列实现的。那么这时，我们就可以用优先队列进行优化，以f 的大小作为判断标准，优先拓展f ff小的 而IDA*是对dfs的优化 普通的DFS“不撞南墙不回头”，不限制的话，很可能沿着一个错误的方向一直递归下去。而IDA*主要有两点升级： 枚举答案的步数。也就是从最小的可能的步数开始往大枚举，直到在这个步数时能从初始状态抵达目标状态。可以简单想一下，每次步数（或者叫深度）加1，那么增加的状态数是相当多的，因此可以忽略前面根本抵达不了终点的步数的耗时。 利用f = g + h 预判是否可能在规定步数抵达终点。假设我们预先设置的步数为x xx，可以知道现状态的f ，那么如果f > x ，则现状态到不了终点。 由于改成了深度优先的方式，与A比起来，IDA更实用：1.不需要判重，不需要排序；2.空间需求减少。 A'算法中包含了开启列表（OPEN表）和关闭列表（CLOSE表）。 在OPEN表中存放的是还没有访问到的结点，CLOSE表中存放的是已访问的结点。算法首先将起点放入开启列表中进行扩展，然后对开启列表中的结点进行路径评分，从而给出从小到大的排列。路径评分需要一个代价函数判断出该结点是否为OPEN表中代价最小的结点，而在算法中，采用如下代价函数评估路径：F=G+H。其中，G为当前结点到起始点的距离，H为当前结点到目标点的距离，F为两者的距离之和。 OPEN 表对列表中的结点根据F值进行从小到大的排列，之后将F值最小的结点从OPEN表中删除，并将其添加到CLOSE表中。 最开始只有起点一个结点，因此起点被放人CLOSE表中，并将起点设为当前结点。通过当前结点搜索当前结点邻近的结点，如果该结点所扩展的结点不在OPEN表中，则将这些结点添加到OPEN表中，之后对添加到OPEN表中的结点进行排序，按照上述过程选出F值最小的结点，选出该结点作为当前结点，并扩展其邻近结点。如果所扩展的结点在OPEN表中，以当前结点为父结点，重新计算G值，并和之前的G值进行比较，从而找出最小的G值进行更新，并重新计算F值，再次进行排列。按照以上步骤循环，直至将目标点添加到OPEN表中，此时搜索算法结束。根据父结点一直找到起点，就得到搜索到的最佳路径。图4.8所示为A'算法的效果示意图。 简单流程 其中f(n)=g(n) + h(n). （1）引进两个集合，open list：存放待检测的结点及F值；close list：已检测过的结点及F值。 （2）初始时，把起点s放入到open list中，close list为空。 （3）取出open list中F值最小的结点，设为当前结点，把当前结点放入到close list中；遍历当前结点的相邻可达结点，相邻结点在close list，则跳过，不然加入/更新open list ；加入或更新的结点以当前结点为父节点。 （4）重复（3）操作，直到当前节点为目标结点或open list变为空。 详细流程 把起点加入 open list 。 重复如下过程： a. 遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。 b. 把这个节点移到 close list 。 c. 对当前方格的 8 个相邻方格的每一个方格？ ◆ 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。 ◆ 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。 ◆ 如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。如果你的 open list 是按 F 值排序的话，改变后你可能需要重新排序。 d. 停止，当你 ◆ 把终点加入到了 open list 中，此时路径已经找到了，或者 ◆ 查找终点失败，并且 open list 是空的，此时没有路径。 保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。 Dijkstra Dijkstra算法是典型基于启发式算法的最短路径算法，用于计算一个结点到其他所有结点的最短路径。其主要特点是以起始点为中心向外层扩展，直到扩展到终点为止。 Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的结点很多，所以效率低，Dijkstra算法的运行过程大致如下所述。 a.同样创建两个表：OPEN表和CLOSE表。 b.OPEN表保存所有已生成而未考察的结点，CLOSE表中记录已访问过的结点。 c.访问离起始点最近且没有被检查过的点，把这个点放人OPEN表中等待检查。 d.从OPEN表中找出距起始点最近的点，找出这个点的所有子结点，把这个点放到CLOSE表中。 e.遍历考察这个点的子结点。求出这些子结点距起始点的距离值，将子结点放到OPEN 表中。 f.重复d、e两步，直到OPEN表为空，或找到目标点。 随机 基于随机采样的运动规划算法的基本思路是：通过对状态空间均匀随机采样来构建一个连通图，当初始、目标状态都在图中或者都可以连接到图中时，则问题得以解决。基于随机采样的算法不需要对状态空间自由区域进行显式建模，由碰撞检测来验证轨迹的可行性即可。 概率路图法（Probabilistic Road Map，PRM） 构图：在自由空间中 随机采样 G = (V,E) 查询： A*、Dijkstra 概率完备且不最优。 算法效率和精度取决于采样精度 快速随机扩展树法（Rapidly Random Tree，RRT） RRT路径规划算法 RRT算法是从起始点开始向外拓展个树状结构，而树状结构的拓展方向是通过在规划空间内随机采点确定的。 过程 树的初始化：初始化树的结点集和边集，结点集只包含初始状态，边集为空。 树的生长：对状态空间随机采样，当采样点落在状态空间安全区域时，选择当前树中离采样点最近的结点，将其向采样点扩展（或连接）。若生成的轨迹不与障碍物发生碰撞，则将该轨迹加人树的边集，该轨迹的终点加人到树的结点集。 重复上述步骤，直至扩展到目标状态集中。 贪心优化 概率完备且不最优 算法弱点：RRT它是一种纯粹的随机搜索算法对环境类型不敏感，当C-空间中包含大量障碍物或狭窄通道约束时，算法的收敛速度慢，效率会大幅降低： 算法重点：how to sample from C-Space (line 4). 如何进行随机采样 how to define the “nearest” node in T (line 5). 如何定义“最近”点 how to plan the motion to make progress toward sample (line 8). 如何进行树的扩展 拓展： 双树RRT（类似于双向广搜） 基本的RRT每次搜索都只有从初始状态点生长的快速扩展随机树来搜索整个状态空间，若是从初始状态点和目标状态点同时生长两棵快速扩展随机树来搜索状态空间，效率会更高。为此，基于双向扩展平衡的连结型双树RRT算法 DP DP（Dynamic Programming）算法又称动态规划算法，如图4.16所示，是一种强大的优化手段，允许人们在多项式级别时间内解决许多不同类型的问题。对于这些问题，一般的方法都需要指数级别的时间。 DP路径算法的基本思路是： 基于给定的一条中心路径（Reference Line，称为参考线）和车道边界条件，每隔一定间隔的纵向距离（称为不同级上的S值）对道路截面进行均匀采样（与中心点的横向偏移值称为为L值），这样会得到采样点（Waypoint，这些采样点称为航迹点）数组。 通常，道路中心线用于建造S-L坐标系，S代表沿中心线方向，L代表与中心线正交的方向。由于道路曲率的存在，路径规划过程中S-L坐标系通常优先于r-y坐标系的使用，二者可根据实际需要凭借坐标转换关系进行相互转换。 基于一定的规则，可以给出各航迹点迁移的代价值。航迹点迁移不一定需要逐级进行，可以从第一级跳到第三级甚至终点，只要迁移代价值。DP算法是一种聚合重复的计算过程，分解得到的子问题是相互重叠的（Overlap），子问题依赖于子子问题（Subsubproblem），子子问题又进一步依赖于下一级的子子问题，这样不断循环直至抵达不需再分解的初始条件。 局部路径平滑 拟合 点点通过式 适用于当前离散点比较精确、步长较小时 --> 插值曲线 平均通过 适用于存在一定误差、通过拟合反映走势 --> 逼近曲线 具体方式 3阶B样条曲线平滑 在连接处具有二阶的连续导数 满足路径平滑 型值点-- 反算--> 控制点 --构造 --> B样条曲线 --插值--> 离散路径点 主要就是根据边界条件解方程求取未知参数 QP优化 基于运动学和动力学的轨迹优化 运动学 非完整性约束：不可积的运动约束 即不能转化为几何约束的运动约束。车辆的速度项 无法通过积分 转化为空间位置，即控制变量少于系统的位姿自由度，因此是一个典型的非完整性约束系统。则在路径规划时不仅要满足几何约束和运动学约束，还要满足动力学约束。 动力学 对侧向加速度约束 转化为 一定车速下的方向盘转角约束，同时有转角连续的约束 速度规划算法 目的： 速度规划的目标是在给定的局部路径曲线上，在满足反馈控制的操作限制及符合行为决策的输出结果这两个前提下，将路径点赋予速度及加速度信息。速度规划主要考虑的是对动态障碍物的规避。 速度规划有以下常见的方法： 对路径指定线加速度来生成速度 样条插值 函数拟合 目标时刻点法 QP算法(用规划出的路径，或者直接参考线..) 障碍物预测 S—T图 路径纵向位移与时间 栅格化 ： 根据需要确定 采样周期 以及 纵向路径点间隔 起点，目标点(s_max, 或达到t_max) 搜索 代价 配合行为决策： 针对某id车，超车(上方cost可调小) 避让(下方cost可偏小) 速度 加速度 jerk， 速度平滑 多项式回归 回归分析 统计学中定量地找出两种或两种以上变量之间的对应关系称为回归分析。 根据自变量的个数、因变量的类型和回归线的形状等信息将回归分析的方法分为线性回归、逻辑回归、多项式回归、逐步回归、岭回归、套索回归等。 按照自变量和因变量之间的关系类型，回归分析可分为线性回归分析和非线性回归分析。研究一个因变量与一个或多个自变量间多项式的回归分析方法，称为多项式回归。如果自变量只有一个时，称为一元多项式回归；如果自变量有多个时，称为多元多项式回归。多项式回归的优势在于仅仅通过改变自变量的次数构建多项式去逼近数据点，不存在其他复杂的函数。 损失函数 对回归方程的拟合函数建立损失函数，用于评价拟合程度的好坏，损失函数的值越小，拟合程度越好。当损失函数为最小值时，则对应的参数theta为最优参数，即此时拟合达到最优。 方法： 利用最大似然和最小二乘法等对损失函数求导并且令导数为零，直接得到解析解； 要求逆矩阵，对于数据量小的问题可以快速有效地得到解析解，但是对于数据量大的问题求解逆矩阵需要消耗大量计算机内存，这是不现实的 迭代寻优 √ 缺点：难以考虑s约束，平滑后可能会发生碰撞 QP √ 机器学习 P88 模仿学习 基于激励函数的优化 强化学习？ 逆向增强学习 评价 ADE？ 控制 经典控制pid 结构简单、工作可靠、稳定性好、参数调整方便，以及系统的模型不精确时可选。 pid基本 尽管不同类型的控制器，其结构、原理各不相同，但是基本控制规律只有三个：比例（P）控制、积分（I）控制和微分（D）控制。这几种控制规律可以单独使用，但是更多场合是组合使用。如比例（P）控制、比例-积分（PI）控制、比例-积分-微分（PID）控制等。 比例（P）控制 　　单独的比例控制也称“有差控制”，输出的变化与输入控制器的偏差成比例关系，偏差越大输出越大。实际应用中，比例度的大小应视具体情况而定，比例度太小，控制作用太弱，不利于系统克服扰动，余差太大，控制质量差，也没有什么控制作用；比例度太大，控制作用太强，容易导致系统的稳定性变差，引发振荡。 　　对于反应灵敏、放大能力强的被控对象，为提高系统的稳定性，应当使比例度稍小些；而对于反应迟钝，放大能力又较弱的被控对象，比例度可选大一些，以提高整个系统的灵敏度，也可以相应减小余差。 　　单纯的比例控制适用于扰动不大，滞后较小，负荷变化小，要求不高，允许有一定余差存在的场合。工业生产中比例控制规律使用较为普遍。 比例积分（PI）控制 　　比例控制规律是基本控制规律中最基本的、应用最普遍的一种，其最大优点就是控制及时、迅速。只要有偏差产生，控制器立即产生控制作用。但是，不能最终消除余差的缺点限制了它的单独使用。克服余差的办法是在比例控制的基础上加上积分控制作用。 　　积分控制器的输出与输入偏差对时间的积分成正比。这里的“积分”指的是“积累”的意思。积分控制器的输出不仅与输入偏差的大小有关，而且还与偏差存在的时间有关。只要偏差存在，输出就会不断累积（输出值越来越大或越来越小），一直到偏差为零，累积才会停止。所以，积分控制可以消除余差。积分控制规律又称无差控制规律。 　　积分时间的大小表征了积分控制作用的强弱。积分时间越小，控制作用越强；反之，控制作用越弱，但有利于减少系统超调量、减小震荡，增加系统稳定性、但消除稳态误差的时间也会增加。 　　积分控制虽然能消除余差，但它存在着控制不及时的缺点。因为积分输出的累积是渐进的，其产生的控制作用总是落后于偏差的变化，不能及时有效地克服干扰的影响，难以使控制系统稳定下来。所以，实用中一般不单独使用积分控制，而是和比例控制作用结合起来，构成比例积分控制。这样取二者之长，互相弥补，既有比例控制作用的迅速及时，又有积分控制作用消除余差的能力。因此，比例积分控制可以实现较为理想的过程控制。 　　比例积分控制器是目前应用最为广泛的一种控制器，多用于工业生产中液位、压力、流量等控制系统。由于引入积分作用能消除余差，弥补了纯比例控制的缺陷，获得较好的控制质量。但是积分作用的引入，会使系统稳定性变差。对于有较大惯性滞后的控制系统，要尽量避免使用。 比例微分（PD）控制 　　比例积分控制对于时间滞后的被控对象使用不够理想。所谓“时间滞后”指的是：当被控对象受到扰动作用后，被控变量没有立即发生变化，而是有一个时间上的延迟，比如容量滞后，此时比例积分控制显得迟钝、不及时。为此，人们设想：能否根据偏差的变化趋势来做出相应的控制动作呢？犹如有经验的操作人员，即可根据偏差的大小来改变阀门的开度（比例作用），又可根据偏差变化的速度大小来预计将要出现的情况，提前进行过量控制，“防患于未然”。这就是具有“超前”控制作用的微分控制规律。微分控制器输出的大小取决于输入偏差变化的速度。 　　微分输出只与偏差的变化速度有关，而与偏差的大小以及偏差是否存在与否无关。如果偏差为一固定值，不管多大，只要不变化，则输出的变化一定为零，控制器没有任何控制作用。微分时间越大，微分输出维持的时间就越长，加快系统相应速度、减小系统超调量、增加系统稳定性、因此微分作用越强，但对系统的扰动的抵抗能力减弱；反之则越弱。当微分时间为0时，就没有微分控制作用了。同理，微分时间的选取，也是需要根据实际情况来确定的。 　　微分控制作用的特点是：动作迅速，具有超前调节功能，可有效改善被控对象有较大时间滞后的控制品质；但是它不能消除余差，尤其是对于恒定偏差输入时，根本就没有控制作用。因此，不能单独使用微分控制规律。 　　比例和微分作用结合，比单纯的比例作用更快。尤其是对容量滞后大的对象，可以减小动偏差的幅度，节省控制时间，显著改善控制质量。 比例积分微分（PID）控制 　　最为理想的控制当属比例-积分-微分控制规律。它集三者之长：既有比例作用的及时迅速，又有积分作用的消除余差能力，还有微分作用的超前控制功能。 　　当偏差阶跃出现时，微分立即大幅度动作，抑制偏差的这种跃变；比例也同时起消除偏差的作用，使偏差幅度减小，由于比例作用是持久和起主要作用的控制规律，因此可使系统比较稳定；而积分作用慢慢把余差克服掉。只要三个作用的控制参数选择得当，便可充分发挥三种控制规律的优点，得到较为理想的控制效果。pid参数调整 试凑法 现代控制 LQR 模糊控制 自适应控制 模型预测控制 具体见 控制笔记的MPC部分 1）基本内容 模型预测控制（Model Predictive Control，MPC）是一种特殊的控制方法。在每一个采样周期，通过求解一个有限时域开环最优控制问题来获得其当前的控制序列。系统的当前状态视为最优控制问题的初始状态，求得的最优控制序列中，只执行第一个控制动作。这是其与使用优先求解控制律的控制方法的最大区别。模型预测控制原理如图5.4所示，k轴为当前状态，左侧为过去状态，右侧为将来状态。也就是说，模型预测控制实际上是一种与时间相关的、利用系统当前状态和当前的控制量，来实现对系统未来状态的控制。而系统未来的状态是不定的，因此在控制过程中要不断地根据系统状态对未来的控制量做出调整。而且相较于经典的PID控制，它具有优化和预测的能力。也就是说，模型预测控制是一种致力于将更长时间跨度甚至于无穷时间的最优化控制问题，分解为若干更短时间跨度或者有限时间跨度的最优化控制问题，并且在一定程度上仍然追求最优解。本质上模型预测控制是要求解一个开环最优控制问题，它的思想与具体的模型无关，但是实现的过程则与模型有关。 2）模型预测控制的三个组成部分 预测模型 预测模型应该能够结合系统的现在的控制输人以及过程的历史信息，来预测控制系统未来的输出值，因此，需要一个描述系统动态行为的模型作为预测模型。在预测控制中的各种不同算法中，常采用不同类型的预测模型，如最基本的模型算法控制（Model Algorithm Contro，MAC），采用的是系统的单位脉冲响应曲线。而动态矩阵控制（Dynamic Matrix Control，DMC）采用的是系统的阶跃响应曲线。这两个模型之间可以互相转换，且都属于非参数模型，在实际的控制过程中比较容易通过实验测得，不必进行复杂的数据处理。尽管精度不是很高，但数据冗余量大，使其抗干扰能力较强。预测模型应具有表现控制系统将来动态行为的功能，就像在系统仿真时一样，可以任意地给出系统未来的控制策略。通过观察控制系统在不同控制策略下输出的变化情况，来比较控制策略的优劣。 反馈校正 利用预测模型进行预估系统的输出值，仅仅是一种理想情况。在实际过程中，可能会因为存在模型失配和干扰等不确定因素，使得基于模型的预测结果不能与实际情况相切合。因此，需要在预测过程中，增加对系统输出值的测量，并与模型预估值进行比较，从而得出模型的预测误差，然后利用预测误差对模型的预测值做修正。因为模型增加了反馈校正，所以预测控制具有较强的抗扰动能力和克服系统不确定性的能力。预测控制不仅是基于模型的，还增加了反馈控制，因此预测控制属于闭环优化控制。 滚动优化 预测控制需要通过某一性能指标的最优求解来确定未来的控制动作。 这一性能指标与控制系统未来的行为有关，由未来的控制策略决定。但是，预测控制的优化与一般的离散最优控制算法不同，其不是采用一个固定的全局最优目标，而是利用滚动式的有限时域内的优化策略。也就是说，优化过程不是单次离线完成的，而是多次在线进行的。在任意的采样时刻，优化性能指标只应用在自该时刻起到未来的有限时间区间，当进行到下个采样时刻时，该优化区间会同时向前。因此，预测控制不是去优化一个全局的性能指标，而是在每一个时刻都有一个局部优化性能指标 手写版推倒笔记 神经网络控制 神经网络控制是指应用神经网络技术，对控制系统中难以精确建模的复杂非线性对象进行神经网络模型辨识，可以作为控制器、可以对参数进行优化设计、可以进行推理、可以进行故障诊断，或者同时兼有以上多种功能。通常神经网络直接用作误差闭环系统的反馈控制器，神经网络控制器首先利用其已有的控制样本进行离线训练，而后以系统误差的均方差为评价函数进行在线学习。 神经网络控制就是利用神经网络这种工具从机理上对人脑进行简单结构模拟的新型控制和辨识方法。神经网络在控制系统中可充当对象的模型，还可充当控制器。常见的神经网络控制结构有： （1）参数估计自适应控制系统； （2）内模控制系统； （3）预测控制系统； （4）模型参考自适应系统； （5）变结构控制系统。 滑膜控制 滑模控制（Sliding Mode Control，SMC）也叫滑模变结构控制，其本质是一种特殊的非线性控制方法，但其非线性表现为控制序列的不连续性。这种控制方法与其他控制方法的区别在于系统结构不是固定不变的，而是能够在动态过程中，根据当前的系统状态（例如偏差以及偏差的各阶导数等）有目的地变化，使系统能够按照预定的滑动模态的轨迹运动。滑动模态需要提前设计且与控制对象参数和外界扰动无关，使得滑模控制具备响应迅速、参数变化平稳、外界扰动影响小、无须系统在线辨识、控制动作实现方式简单等优点。 滑模控制主要表现为控制的不连续性，也就是系统结构随时间变化的特性。该控制特性能够使系统在一定条件下沿着预设的状态轨迹做小幅度、高频率的运动，即滑动模态或者“滑模”运动。滑动模态是可以预设的，而且与系统的参数及外界扰动无关。因此，滑模控制的系统具有较好的鲁棒性， 鲁棒控制 鲁棒控制（Robust Control）方面的研究始于20世纪50年代。在过去的20年中，鲁棒控制一直是控制领域的研究热点。鲁棒性是指控制系统在一定的参数摄动下，维持某些特性的能力。根据对性能的不同定义，可分为稳定鲁棒性和性能鲁棒性。以闭环系统的鲁棒性作为目标设计得到的固定控制器称为鲁棒控制器。鲁棒性也称为系统的健壮性，它是系统在异常扰动情况下保持稳定的关键。例如，自动驾驶汽车的软件平台在输入错误、磁盘故障、网络过载或有意攻击情况下，能不死机、不崩溃，就是该平台的鲁棒性，鲁棒控制适用于稳定性和可靠性作为首要目标的应用，系统的动态特性已知，而且不确定因素的变化情况可以预估。在控制过程中，某些控制系统可以使用鲁棒控制，尤其是对那些不确定因素变化范围大且稳定裕度小的系统。通常，系统的分析方法和控制器的设计大多是基于数学模型而建立的，而且各类方法已经趋于成熟和完善。然而，系统总是存在这样或那样的不确定性。在系统建模时，有时只考虑了工作点附近的情况，造成了数学模型的人为简化；另外，执行部件与控制元件存在制造容差，系统运行过程也存在老化、磨损以及环境和运行条件恶化等现象，使得大多数系统存在结构或者参数的不确定性。这样，用精确数学模型设计出来的控制器常常不满足工程要求。 近年来，人们展开了对不确定系统鲁棒控制问题的研究，并取得了一系列研究成果。其中，H。鲁棒控制理论和u分析理论则是当前控制工程中最突出的研究成果，多年来一直是鲁棒控制研究领域的热门之一 汽车模型 考虑二自由度汽车的“自行车”模型。两个自由度分别用汽车侧向位置y和汽车方向角p表示。 运动学模型 汽车运动模型是指用数学方式描述汽车运动而不考虑影响汽车运动的力。运动方程是基于控制对象的几何关系而建立的。建立汽车的运动学模型需要以下假设作为前提： （1）不考虑汽车在Z轴方向的运动，只考虑XY水平面的运动； （2）左右侧车轮转角一致，这样可将左右侧轮胎合并为一个轮胎； （3）汽车行驶速度变化缓慢，忽略前后轴载荷的转移； （4）车身及悬架系统是刚性的。 动力学模型 控制 根据当前周围环境和车体位置、姿态、车速等信息按照一定的逻辑做出决策，并分别向油门、制动及转向等执行系统发出控制指令。 横向控制 主要研究自动驾驶汽车的路径跟踪能力，即如何控制汽车沿规划的路径行驶，并保证汽车的行驶安全性、平稳性与乘坐舒适性； 纵向控制 主要研究自动驾驶汽车的速度跟踪能力，控制汽车按照预定的速度巡航或与前方动态目标保持一定的距离；但独立的横向或纵向控制不能满足自动驾驶汽车的实际需求，因此，复杂场景下的横纵向协同控制研究，对于自动驾驶汽车来说至关重要般地，横向控制系统的实现主要依靠预腊跟随控制、前馈控制和反馈控制。预瞄控制 预喵跟随控制原理是根据驾驶员操纵特征（驾驶员模型）提出的。驾驶员模型是导航技术的重要组成部分，基于偏差调节的期望路径跟随控制系统可视为一个简易的驾驶员模型。驾驶员基于外界环境、道路信息以及当前汽车的运动状态进行汽车操纵，预测汽车当前实际位置与道路中心线之间的侧向位移偏差和航向偏差的大小，从而转动方向盘使预测偏差为零，该预测偏差叫作预腊侧向位移偏差或预腊航向偏差。驾驶员依据预喵偏差的大小转动对应的方向盘角度，从而完成对期望行驶路径的跟踪。综上，控制系统依据汽车行驶参数、道路曲率、预腊偏差和汽车的动力学模型得出所需方向盘转角或前轮转角，从而实现对期望目标路径的跟踪。预喵跟随控制器由“预腊环节”与“跟随环节”构成， 前馈控制 前馈控制系统是根据扰动或给定值的变化按补偿原理来工作的控制系统。其特点是当扰动产生后，被控变量还未变化以前，根据扰动作用的大小进行控制，以补偿扰动作用对被控变量的影响。 反馈控制 反馈控制是指将系统的输出信息返送到输入端，与输入信息进行比较，并利用二者的偏差进行控制的过程。反馈控制其实是用过去的情况来指导现在和将来。在控制系统中，如果返回的信息的作用是抵消输入信息，称为负反馈，负反馈可以使系统趋于稳定；若其作用是增强输人信息，则称为正反馈，正反馈可以使信号得到加强。 横向控制 自动驾驶汽车作为一个高度非线性的非完整运动约束系统，其模型和所处外界环境存在不确定性及测量不精确性，导致对汽车进行运动控制具有一定的难度。横向控制主要控制航向，通过改变方向盘扭矩或角度的大小等，使汽车按照想要的航向行驶。依据人类驾驶的经验，驾驶员在驾驶途中会习惯性地提前观察前方道路，并预估前方道路情况，提前获得预喵点与汽车所处位置的距离。如果汽车前方道路右转弯，驾驶员会依据道路曲率和行驶车速将方向盘向右转一定角度，为使汽车平顺转弯，驾驶员需要不断观察汽车实际运行位置与道路中心线间的横向位移偏差和航向角偏差，并调整方向盘转角来减小这些偏差，便于准确、快速地跟踪期望路径。但该过程容易受到周围环境的影响，且随车速的变化而变得更加复杂，郭孔辉院士提出的预腊跟随原理形象地描述了上述驾驶员操纵行为。后来在此基础上产生了驾驶员“稳态预测动态校正假说”\"预腊最优曲率模型”\"最优预描加速度模型”。而在自动驾驶汽车的研究中，预腊跟随理论同样适用。 建立自动驾驶汽车横向控制系统，首先需要搭建道路-汽车动力学控制模型，根据最优预腊驾驶员原理与模型设计侧向加速度最优跟踪PD控制器，从而得到汽车横向控制系统。其次，以汽车纵向速度及道路曲率为控制器输入，预腊距离为控制器输出，构建预喵距离自动选择的最优控制器，从而实现汽车横向运动的自适应预描最优控制。 纵向控制 直接式 跟踪位置或速度 直接式运动控制是通过纵向控制器直接控制期望制动压力和节气门开度，从而实现对跟随速度和跟随减速度直接控制，具有快速响应等特点。 分层式 将速度的跟踪转化为加速度，再跟踪加速度 基于分层控制结构，根据控制目标的不同，将自动驾驶汽车纵向控制系统分为上位控制器和下位控制器进行单独设计。 上位控制器控制策略设计的目的是产生期望车速或者期望加速度； 下位控制器接受上位控制器产生的期望状态值，并按照其控制算法产生期望的制动压力值与期望油门开度值，从而实现汽车纵向车间距离或速度跟踪控制的功能 切换逻辑难点 汽车在行驶过程中，同时踩下油门踏板与制动踏板的会损坏汽车动力系统和传动系统。 因此切换逻辑要保证以下两点。 （1）在油门踏板踩下的时候需要释放制动踏板，在制动踏板踩下的时候需要释放油门踏板，避免油门踏板和制动踏板同时工作； （2）避免油门、制动踏板频繁切换，由此设计油门踏板与制动踏板协调切换控制逻辑，根据期望车速与当前实际车速的误差来协调控制加速、制动的切换。 横纵向协同控制 纵向车速作为横纵向控制关键连接。 Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-11-15 20:09:05 "},"02_智能车PNC笔记/01_规划笔记/规划基础.html":{"url":"02_智能车PNC笔记/01_规划笔记/规划基础.html","title":"2.1 规划笔记","keywords":"","body":"基础知识点 解耦 降维规划 三维问题 转化 为两个二维问题 路径规划(处理静态障碍物)与速度规划(处理动态障碍物) 路径规划，借助中间变量路径的累计长度 s，先求解 s 映射到几何形状(x, y, θ, κ)的路径函数；速度规划，再求解时间 t，映射到中间变量 s 与 v，a 的速度函数。 Frenet坐标系 把无人车、道路边界、障碍物特征、障碍物位置等都放到坐标系中 优势：第一将复杂问题的难度降维，第二不受道路几何形状影响，更好的场景理解。 _^: 在弗莱纳坐标系下做运动规划的好处在于借助于指引线做运动分解，将高维度的规划问题，转换成了多个低维度的规划问题，极大的降低了规划的难度。另外一个好处在于方便理解场景，无论道路在地图坐标系下的形状与否，我们都能够很好的理解道路上物体的运动关系。相较直接使用地图坐标系下的坐标做分析，使用弗莱纳坐标，能够直观的体现道路上不同物体的运动关系。 在路径规划中，我们借助于弗莱纳坐标系，将当前车辆的运动状态(x, y, θ, κ, v, a)做分解。使用弗莱纳坐标系的前提是具有一条光滑的指引线。一般情况下，将指引线理解为道路中心线，车辆在没有障碍物情况下的理想运动路径。我们这里的光滑的指引线是指指引线的几何属性可以到曲率级别的光滑。指引线的光滑性至关重要，因为其直接决定了在弗莱纳坐标系下求得轨迹的平顺性。要求达到 曲率可导级别 在给定一条光滑指引线上，我们按照车辆位置，将其投影到指引线上，以投射点为基础，将地图坐标系下当前车辆的运动状态(x, y, θ, κ, v, a)进行分解，获得沿着指引线方向的位置、速度、加速度，以及相对于指引线运动的位置、 “速度”、 “加速度”。这里打引号的原因是横向的“速度”、“加速度”并非通常意义上位移对时间的一阶/二阶导数，而是横向位移对纵向位移的一阶/二阶导数，它们描述了几何形状的变化趋势。 路径规划 sl坐标系 路径优化 第一步将连续性问题离散化。以 ?s 为间隔采样，得到n 个点。?s不能太大也不能太小，如果特别小在工程上影响速度，所以?s通常设置为0.5厘米。 第二步是明确要满足的约束条件。包括三条，主车必须在道路边界内，同时不能和障碍物有碰撞；根据当前状态，主车的横向速度/加速度/加加速度有特定运动学限制；必须满足基本的物理原理。 第三步是明确要努力达到的目标。首先第一目标确保安全礼貌驾驶，不能四处乱窜，用数学语言表达相当于横向位移绝对值最小；第二确保舒适的体感，尽可能降低横向速度/加速度/加加速度。 第四步将优化问题转化为二次规划问题进行求解。转化为二次规划的问题之后，整个复杂问题简单化，运用一些现成比较好的求解二次规划算法，规划出比较合理的运动路径。 它的输出是比较平滑、舒适、能够合理避开所有障碍物尽快达目的地的路径。 在弗莱纳坐标系下的函数l(s)，表达了以指引线为参考，相对于指引线的几何形状；通过转换到地图坐标系下，就表达了在地图坐标系的路径。所以，本质上，路径规划问题在弗莱纳坐标系下，就是一个计算函数l(s)的过程。 Article:分享回顾 | Apollo 轨迹规划技术分享 为了解决这个问题，这里介绍由我提出的分段加加速度优化算法（Piecewise Jerk Path Optimization Algorithm），我们先来看一下算法的流程： 第一步，我们将环境中的静态障碍物从地图坐标系映射到依据指引线的弗莱纳坐标系下（红色方框）。 将环境中的静态障碍物映射到弗莱纳坐标系中 第二步，沿指引线的 s 轴方向，使用 Δs 将 s 方向等距离离散化。根据障碍物的信息、道路的边界，计算出每一个离散点所对应的可行区域(l_min^i，l_max^i )。为了方便描述，我们将无人驾驶车简化成一个点。为了避免碰撞，在计算可行区域的时候可以留出适当的缓冲区间。 弗莱纳坐标系离散化 第三步，介绍优化算法使用的优化变量。对于每一个离散点i，我们将该点的横向偏移 l_i，横向偏移相对于s的一阶和二阶导数 l_i^′ 和 l_i^″作为优化变量。l_i^′ 和 l_i^″可以近似理解为横向运动的“速度”与“加速度”。他们的大小决定了车辆靠近与偏离指引线的趋势。 假设每两个离散点之间，有一个常三阶导数项l(i→i+1)^?连接着相邻的离散点， 这个“常”三阶导数项可以由相邻的二阶导数通过差分的方式计算得到。在优化的迭代过程中，l(i→i+1)^? 会随着相邻点li^″ 与l(i+1)^″ 的变化而变化，但l_(i→i+1)^?在两个离散点之间会保持不变。 第四步，设置优化目标。首先，对于路径来讲，在没有环境因素影响的情况下，我们希望它尽可能的贴近指引线。对于一阶、二阶与三阶导数，我们希望它们尽可能的小, 这样可以控制横向运动的向心加速度，保证路径的舒适性。 算法完整描述中的输入和输出 下面，我们回顾一下这个算法，算法的输入由四个部分组成： 光滑的道路指引线，用于在弗莱纳坐标系下的运动分解。 当前无人驾驶车辆的运动状态，包括位置、朝向、即时转向、速度与加速度。车辆运动状态会依照光滑指引线进行分解 环境中态障碍物的信息，投影到指引线上 车辆自身的属性，运动学模型等，用于计算优化过程中合理的变量限制条件。 算法完整描述 算法的变量每一个离散点的横向位移，横向位移对指引线纵向长度 s 的一阶、二阶导数，对于有 n 个输入点的问题，优化变量有 3?n 个。对于限制条件，首先横向位移li需要在相对应的安全区间之内(l_min^i,l_max^i )。对于 l_i^′, 〖l_i〗^″, l(i→i+1)^?的取值范围，需要根据当前车辆移动速度, 车辆的动力学模型计算，涉及到具体的车辆模型。 一个非常关键的约束条件是路径的连续性。我们假设相邻两点之间有一个常三阶导数量 l_(i→i+1)^?来连接，我们需要确定经过这个常三阶导数量l(i→i+1)^?，相邻两个点的l, l^′, l″的数值能够吻合。举个例子，两个点之间就好比可以拉伸的绳子，l(i→i+1)^?决定了可以拉伸的程度，这两个式约束决定了在绳子拉伸的过程中保证绳子不被拉断。 优化目标函数 算法的优化目标，是减小横向位移的零阶，一阶，二阶和三阶导数，使路径尽可能贴近指引线的同时保证舒适性。当然，我们也可以根据需求，选择性的加入与边界距离的优化目标，使车辆与障碍物保持适当距离。分段加加速度算法由于其大密度分段的特性，使得能够表达的路径具有很高的灵活性，能够解决城市道路中（特别是国内拥挤的环境J）的路径规划问题；并且，由于是以加加速度级别的控制变量来改变路径的形状，能够做到曲率级别的连续性，保证了路径的平滑舒适。 速度规划 st坐标系 速度规划目标 安全 高效 舒适 1.坐标系 2.速度采样：首先对路程和时间进行采样，然后搜索出粗略的可行路线，最后选出代价最小的一条，代价函数需考虑限速、碰撞、路径形状、舒适度和完成时间等。 速度优化： 1) 以 ?s 为间隔采样。 2) 明确要满足的约束条件，考虑以下三个约束条件： 主车不能和障碍物有碰撞 根据当前状态，主车的加速度/加加速度有特定运动学限制 必须满足基本的物理原理 3) 明确要努力达到的目标，主要包括以下两个方面： 尽可能贴合决策时制定的速度分配 确保舒适的体感，尽可能降低加速度/加加速度 4) 转化为二次规划问题，求解。 图片 速度规划的目标 下一步，我们来看怎样为计算出的路径分配速度。对于速度规划，有如下要求： 速度分配具有灵活性，能够避让复杂、拥挤的城市环境中的众多移动障碍物。 速度分配需要遵守车辆运动学的限制条件， 比如最大速度、加速度、加加速度等，确保规划出的轨迹车辆实际可以执行。 规划的速度分配需要遵守考虑交通法规的限制，在限速范围内规划。 规划的速度分配需要完成到达指定位置或者指定速度的任务，并且在保证舒适度的前提下，完成时间尽可能的短。 速度规划的策略 在 Apollo 平台的实现中，采用了结合启发式速度规划和分段加加速度算法相结合的方式来解决速度规划问题。启发式速度规划提供考虑了动静态障碍物、路径几何信息、道路信息、舒适度、目标速度和地点多种因素综合下的速度规划粗略估计；分段加加速度算法对启发是速度规划提供的粗略分析进行平滑，输出安全舒适的速度分配。 在启发式速度规划中，采用了一个非常好的分析工具，路径-时间障碍物图（Path-Time Obstacle Graph）。路径-时间障碍物图非常适合在确定了路径的情况下，考虑动静态障碍物的规避问题。这个分析工具的核心思想就是将考虑了本车和周围障碍物几何形状和预测轨迹的情况下，将障碍物的轨迹投影到已经确定的本车路径上。障碍物所代表的含义是在何时（t）与何地（s）本车会与障碍物发生碰撞。 启发式速度规则 在 Apollo 的实现中，路径-时间障碍物图根据时间轴 t 和沿路径的累计距离s离散化，形成等距离、等时间的网格状图。然后根据需求，将各种因素使用不同的权重，建模成一个单一熟知的代价函数，每一个网格的节点会赋予一个代价，相邻网格之间的边也视为代价的一部分，用来建模加速度。整个过程可以看成是一个图搜索的过程，搜索出一个代价最优的路径。搜索的结果就是一系列的路径距离与时间的序列，代表何时（t），我们期望无人驾驶车到达何地（s）。 分段加加速度平滑算法 启发式速度规划的粗略结果只能提供位置，缺乏控制所需要的更高维信息，不适合控制模块直接使用。产生的结果需要进一步的平滑才能满足舒适度要求。我们进一步做平滑处理的方法使用的是分段常加加速度算法，其主要思想类似于前面介绍的路径优化算法，在给定趋近启发式速度规划结果的情况下，调整启发式速度规划，提高速度分配的平滑性。 分段加加速度算法 下面具体介绍应用在速度平滑上的分段加加速度算法。由于与前面的路径上使用的算法类似，相似的地方就不再赘述。该算法以时间作为离散参数（可以使用启发式算法使用的时间间隔），以每个离散点的位置、速度、加速度作为优化变量，并且假设相邻两点之间，是一个由相邻加速度变量差分得到的加加速度。 优化目标函数设置 在优化函数的设置上，与前面算法相似的地方是惩罚加速度与加加速度的以获得舒适的乘坐体验。不同的一个优化目标是希望位置变量与启发式规划所得到的位置信息尽可能贴近。启发式规划所得到的位置信息蕴含了根据路径几何形状、道路限速等等所做出的计算，这些计算绑定在相应的位置上，所以优化之后的轨迹需要贴近于相应的启发式结果才能体现启发式规划所做的选择。 算法评价与改进 大家可能有的一个问题是，在速度规划的时候，为什么分成启发式的速度规划与分段加加速度算法结合的形式？为何不直接使用加加速度算法进行求解？主要的问题在于在速度规划的时候，进行离散的维度、时间，也是优化目标的一部分。 位置与时间同为优化变量，与位置相关的限制条件， 比如路径曲率、道路限速信息等等，会影响到达位置的时间；而时间的变化又会引起优化速度的变化，进而导致位置发生变化。这就导致了一种变量间耦合变化的情况。启发式速度规划使用粗略的方法，近似解决了位置 s 决定的限制条件与时间 t 相互耦合的问题，使时间成为了常量。 但是，这样做也有很明显的不利影响，启发式速度规划的粒度影响了搜索的质量，在搜索过程不够准确，不能反映车辆的动态变化。平滑时单纯贴近启发式速度规划，速度规划并非最优。 参考线 拼接 五次多项式 凸优化 二次规划 碰撞检测 Article:技术文档｜Apollo中Lattice轨迹碰撞检测 方法：分离轴定理 其他叫法：超平面分离定理 分离轴定律：两个凸多边形物体，如果我们能找到一个轴，使得两个在物体在该轴上的投影互不重叠，则这两个物体之间没有碰撞发生，该轴为Separating Axis 包围盒：是根据物体的集合形状，来决定盒子的大小和方向，这样可以选择最紧凑的盒子来代表物体。 目的：剔除存在同障碍物碰撞风险的轨迹，具体详情如下，大致就是对于每个采样点，自车采用矩形Box包络，障碍物们采用矩形Box包络，然后检测是否有干涉。 原理：检查矩形框之间是否有重叠，自动泊车中车辆碰撞检测也是类似方法。 对于多边形分离轴定律变成，两个多边形在所有轴上的投影都发生重叠，则判定为碰撞；否则，没有发生碰撞。 两种常见的物体包络框： AABB—Axis Aligned Bounding Box OBB—Oriented Bounding Box 具体： AABB 包围盒: AABB 包围盒是与坐标轴对齐的包围盒, 简单性好, 紧密性较差(尤其对斜对角方向放置的瘦长形对象, 采用AABB, 将留下很大的边角空隙, 导致大量没必要的包围盒相交测试)。当物体旋转之后需对AABB 进行同样的旋转并更新; 当物体变形之后只需对变形了的基本几何元素对应的包围盒重新计算; 然后可以自下向上由子结点的AABB 合成父结点的AABB, 最后进行包围盒树的更新。 OBB 包围盒: OBB 碰撞检测方法紧密性是较好的, 可以大大减少参与相交测试的包围盒的数目, 因此总体性能要优于AABB 和包围球, 并且实时性程度较高。当物体发生旋转运动后, 只需对OBB 进行同样的旋转即可。因此, 对于刚体间的碰撞检测, OBB 不失为一种较好的选择。迄今为止, 还没一种有效的方法能够较好地解决对象变形后OBB 树的更新问题, 而重新计算每个结点的OBB 的代价又太大。所以OBB 不适用于包含软体对象的复杂环境中。 包围球: 包围球碰撞检测方法是用球体包围整个几何体, 无论是几何体还是相交测试都很简单; 但是它的紧密性太差。因为除了在3 个坐标轴上分布得比较均匀的几何体外, 几乎都会留下较大的空隙, 需要花费大量的预处理时间, 以构造一个好的层次结构逼近对象。当物体变形之后,包围球树需要重新计算。因此,它是使用得比较少的一种包围盒。当对象发生旋转运动时, 包围球不需作任何更新, 这是包围球的较优秀特性; 当几何对象进行频繁的旋转运动时, 采用包围球可能得到较好结果。 拓展： 任何实时三维交互式程序，如果没有碰撞检测，都是没有价值，甚至无法使用的。游戏中最常用的碰撞检测技术莫过于包围盒（bounding volume）碰撞检测。对于以60pfs运行的游戏来说，处理每一帧数据的时间只有0.0167s左右，对于不同的游戏，碰撞检测大概需要占10~30%的时间，也就是说，所有碰撞检测必须在0.002~0.005s内完成，非常巨大的挑战。因此，任何包围盒都应该满足以下特性: 1.快速的碰撞检测 2.能紧密覆盖所包围的对象 3.包围盒应该非常容易计算 4.能方便的旋转和变换坐标 5.低内存占用 最常见的包围盒有：Sphere，AABB，OBB等，外加一个比较特殊的frustum。Sphere能很好的满足1，3，4，5条，但通常包含了太多无用的空间，容易导致错误的碰撞结果。AABB应该是sphere与obb之间的解决方案，同时兼顾了效率和空间覆盖范围。OBB是三者中精度最高的，但检测代价也是最高的。 最终使用哪一种包围盒，是一个非常痛苦的过程，我们需要在效率和精度之间做出权衡取舍。 参考：Bounding Volume Performance Test：AABB vs OBB vs Sphere 如下图： AABB: OBB: Planning中自车采用OBB方式。在感知领域Box用的很多，图像处理、激光雷达分割聚类这些需要对物体标记跟踪。 方法： 1、建立自车Box const auto& trajectory_point = discretized_trajectory.TrajectoryPointAt(static_cast(i)); double ego_theta = trajectory_point.path_point().theta(); Box2d ego_box( {trajectory_point.path_point().x(), trajectory_point.path_point().y()}, ego_theta, ego_length, ego_width); // 车辆center和车辆的几何中心不重合，所以box需要校正一下 double shift_distance = ego_length / 2.0 - vehicle_config.vehicle_param().back_edge_to_center(); Vec2d shift_vec{shift_distance * std::cos(ego_theta), shift_distance * std::sin(ego_theta)}; ego_box.Shift(shift_vec); 这部分相对简单，锁定当前轨迹点，构建Box框，由于几何中心和车辆中心不一致(普通乘用车前后配比几乎没有1:1，除了柯尼塞格)，所以做了一下校正，最后的ego_box就是我们要的。 2、快速剔除非碰撞Box 因为检测过程是根据采样点遍历进行的，可以理解为逐帧进行，下一步可以知道精确的碰撞检测其实是比较繁琐的，对于显而易见的不会碰撞，方法相对简单。 if (box.max_x() max_x() || box.max_y() max_y()) { return false; } 如图所示：凡是在灰色区域外障碍物box，都是一定没有发生碰撞的，这是一个充分不必要条件。因为，会有类似t3时刻的发生。上述方法只能用在轴对齐的Box中，对于非轴对齐的，只能用于快速粗略的剔除不碰撞Box： 3、碰撞的精确检测 第2步中能够快速跳过无碰撞的时刻，对于出现t3时刻的情况，采取了另外的检测方法：分离轴定理。 通俗理解就是——投影。如果空间中两个物体，想知道是否接触，最直接的方法便是来回绕着看看，确认一下两者间是否有间隙。 人是立体的，而且还是凸多面体，这方法可还行？好在Planning中，我们是以上帝视觉观测，是二维空间，事情更加简单，最少投影数是几边形，就投几次影，Apollo中采用的是凸四边形，所以四次投影分别是： 在自车纵轴上投影 在自车横轴上投影 在障碍物纵轴上投影 在障碍物横轴上投影 如图： a_p中心连线构成的向量在投影线上的投影长，b_p,c_p分别为自车、障碍物在投影线上的投影长度 判断的依据： a_p \\le b_p+c_p 如果上式成立，两者就有接触或碰撞的可能了。很明显，从下面这张图已经看出它们并没有发生碰撞，不妨碍进行额外的三次确认，继续： 接下来 最后 从后三次来看，图中显示两者是有重叠的，所以这四次确认需要一套做完，可以看到第2步高效地跳过了很多不必要的计算。 4.具体实现 对于投影而言，向量运算这种方式是很便捷的，具体步骤如下：确定边界相对于自身坐标系的坐标→转换为笛卡尔坐标(全局)→向量常规运算→得到对应投影长度 Apollo具体代码部分： const double shift_x = box.center_x() - center_.x(); const double shift_y = box.center_y() - center_.y(); const double dx1 = cos_heading_ * half_length_; const double dy1 = sin_heading_ * half_length_; const double dx2 = sin_heading_ * half_width_; const double dy2 = -cos_heading_ * half_width_; const double dx3 = box.cos_heading() * box.half_length(); const double dy3 = box.sin_heading() * box.half_length(); const double dx4 = box.sin_heading() * box.half_width(); const double dy4 = -box.cos_heading() * box.half_width(); // 对于OBB边框，使用分离轴定理进行碰撞检测？？？ return std::abs(shift_x * cos_heading_ + shift_y * sin_heading_) 至此，障碍物碰撞检测完成，函数外部根据返回值，做下一步处理即可。 参考：OBB包围盒及其碰撞检测算法（一） 场景 无保护左转： 十字路口内同时发生一方左转 和 对向直行 这种情况下，对向直行的车辆前部有一大型车辆，更加危险。。。 Video:Apollo air - 无保护左转 每个场景不同的参数 Apollo 3.5中规划模块的体系结构已经有所改变，该架构能够反映针对不同驾驶场景的模块化设计方法。如下图所示， 在规划器中, 每一个独立的驾驶场景都和对应的场景处理器一一对应。每个驾驶场景都有其一组特定于该场景的驾驶参数，使其更安全、高效、更易于自定义和调试以及更灵活。因为每个阶段都被划分为多个任务，使得每个阶段也是可配置的，并且可以通过编辑该场景的配置文件config来删除或创建每个任务。 Article:技术文档丨Apollo规划模块技术指导 驾驶场景的分类 Article:入门必看丨解析百度Apollo之决策规划模块 Status PublicRoadPlanner::Plan(const TrajectoryPoint& planning_start_point, Frame* frame) { DCHECK_NOTNULL(frame); scenario_manager_.Update(planning_start_point, *frame); ① scenario_ = scenario_manager_.mutable_scenario(); ② auto result = scenario_->Process(planning_start_point, frame); ③ ... if (result == scenario::Scenario::STATUS_DONE) { scenario_manager_.Update(planning_start_point, *frame); ④ } else if (result == scenario::Scenario::STATUS_UNKNOWN) { return Status(common::PLANNING_ERROR, \"scenario returned unknown\"); } return Status::OK(); } 这段代码的几个关键步骤是： 1、确定当前Scenario：因为Frame中包含了当前状态的所有信息，所以通过它就可以确定目前是处于哪一个场景下。 2、获取当前Scenario。 3、通过Scenario进行具体的处理。 4、如果处理成功，则再次通过ScenarioManager更新。 车道保持 车道保持场景是默认的驾驶场景，它不仅仅包含单车道巡航。同时也包含了： 换道行驶。 遵循基本的交通约定。 基本转弯。 Side Pass 在这种情况下，如果在自动驾驶车辆（ADC）的车道上有静态车辆或静态障碍物，并且车辆不能在不接触障碍物的情况下安全地通过车道，则执行以下策略： 检查邻近车道是否接近通行。 如果无车辆，进行绕行，绕过当前车道进入邻道。 一旦障碍物安全通过，回到原车道上。 停止标识 停止标识有两种分离的驾驶场景： 1、未保护：在这种情况下，汽车预计会通过具有双向停车位的十字路口。因此，我们的ADC必须爬过并测量十字路口的交通密度，然后才能继续走上它的道路。 2、受保护：在此场景中，汽车预期通过具有四向停车位的十字路口导航。我们的ADC将必须对在它之前停下来的汽车进行测量，并在移动之前了解它在队列中的位置。 时间戳 规划模块发送给控制模块的轨迹上的时间戳为 绝对时间，更容易进行匹配控制时所需的点 lattice算法 Article:开发者说 | Lattice Planner从学习到实践（一） Article:Apollo问答 | 关于Lattice Planner规划算法的若干问答 osqp OSQP(Operator Splitting Quadratic Program)是一个求解凸二次规划问题的开源求解器，官网地址为https://osqp.org/。 OSQP的内核优化算法是交替方向乘子法(Alternating Direction Method of Multipliers, ADMM)，具体的算法原理可以阅读运筹OR帷幄的专栏文章 OSQP使用时无需调用其他第三方库，其内置的线性方程组求解算法是QDLDL，在求解中小规模的问题时效果较好；如果想要求解大规模的问题，官方建议使用Intel的MKL Pardiso，也可以使用其他求解器，具体可以参考官方帮助文档。这里只介绍OSQP的基本安装及调用方法。 more: see Eigen QR ,ADMM Eigen: Eigen C++ Eigen 线性回归（最小二乘法、牛顿法） 非线性最小二乘求解方法详解 QR: QR分解法是三种将矩阵分解的方式之一。这种方式，把矩阵分解成一个正交矩阵Q与一个上三角矩阵R的积。QR分解经常用来解线性最小二乘法问题。QR分解也是特定特征值算法即QR算法的基础。 QR分解之HouseHolder变换 QR分解 wiki ADMM: admm_talk video:ADMM 类算法的一些最新进展 交替方向乘子法（ADMM）算法的流程和原理是怎样的？ 优化 | 基于ADMM的OSQP求解器介绍 use demo // eigen 视觉SLAM十四讲（第二章作业） osqp 基本使用 OSQP使用说明 如何使用OSQP-Eigen 使用OSQP解决二次凸优化(QP)问题 osqp-eigen使用记录 凸函数 凸函数 矩阵基础 【矩阵学习】Jacobian矩阵和Hessian矩阵 Hessian 矩阵是半正定凸函数，可以利用这一点来判断驻点（critical point）是否为局部最大值、局部最小值或鞍点。假设驻点为 x ，判断方法如下： Hessian 矩阵是正定矩阵时（特征值全为正数），则 f 在点 x 处取到极小值； Hessian 矩阵是负定矩阵时（特征值全为负数），则 f 在点 x 处取到极大值； Hessian 矩阵是不定矩阵时（特征值有正有负），则 x 是 f 的鞍点； 否则，无法确定，需要利用其他方法判断。 如何判断一个函数是否是凸函数 参考：凸函数 　对于一元函数f(x)，可以通过其二阶导数f′′(x)的符号来判断。如果函数的二阶导数总是非负，即f′′(x)≥0，则f(x)是凸函数。 　对于多元函数f(X)，可以通过其Hessian矩阵（Hessian矩阵是由多元函数的二阶导数组成的方阵）的正定性来判断。如果Hessian矩阵是半正定矩阵，则是f(X)凸函数。 二次导数f''（x）大于零，一次导数f'（x）递增，函数f(x)下降的趋势越来越缓（或上升的趋势越来越大） 凸优化问题的局部最优解是全局最优解 上面的公式，完全可以推广到多元函数。在数据科学的模型求解中，如果优化的目标函数是凸函数，则局部极小值就是全局最小值。这也意味着我们求得的模型是全局最优的，不会陷入到局部最优值。 非凸函数优化图示 凸函数优化图示 二次规划 二次规划 二次规划问题 是一种典型的优化问题，包括凸二次规划和非凸二次规划，在此类问题中，目标函数是变量的二次函数，约束条件是变量的线性不等式。 apollo规划的osqp Apollo 6.0 QP（二次规划）算法解析 古月居 基于OSQP的二次规划 ipopt: 求解模型 状态变量 x = [x_1,x_2,x_3,x_4]^\\mathrm{T} 目标函数 $ f(x) = x_1 x_4 (x_1 + x_2+ x_3) + x_3 $ 约束条件：$ g_1(x) = x_1 x_2 x_3 * x_4 \\ge 25 $; $ g_2(x) = x^2_1 + x^2_2 + x^2_3 + x^2_4 = 40 $ 观察效果 和 用时 以及 极端例子 测试一下 参考线的平滑 百度Apollo代码阅读：参考线平滑FemPosDeviationSmoother map节点中 约束是距离初始的点距离0.2m 尤其是对初始点的约束要更小 防止因为总体的平滑 使得车辆当前点的约束失效 500个点 迭代500 次 优化用时 3ms 测试一下 路径搜索 仅仅是路径搜索 A* + qp大概20ms A* 3ms QP 12 - 20ms 迭代500次 knots 为40？？？ 0.2m的精度？？ 还是0.25m啊 A矩阵中连续性约束等问题的推倒 连续性约束 连续性约束，个人认为其目的是为了将零阶状态用一二阶状态进行线性表示，这样才更为合理地表示各界状态的关联关系，毕竟低阶的运动状态是由高阶状态积分得到的。 至于代码中出现的scale_factor，个人认为：保证了优化项之间差别不至于过大。如果优化项之间差别过大（比如跨了几个数量级）可能会导致过小的那个优化项无效。 对于P矩阵来说，为什么不直接将运动视作一个四阶运动系统？直接将其视作一个四阶系统，这样会会简化P矩阵的表达？ 个人认为主要原因是，在实际的车辆运动中，dddl没有实际对应的物理量，无法直接得到其上下边界值，所以只能改变P矩阵的形式，将三阶状态通过使用二阶状态表示出来。关于本问题的P矩阵，网上已经有很多资料方便理解，我大概推导了一下，发现有一些可以优化改进的地方，在工作中我也实现了对P矩阵的改进，欢迎大家和我一起来讨论。 之所以使用CSC矩阵是为了方便将稀疏矩阵进行高效地存储， mpc osqp MPC: basic: Apollo代码学习(五)—横纵向控制 src: Apollo代码学习(六)—模型预测控制(MPC) MPC求解（基于apollo代码的理解） mpc ipopt osqp代码流程： 1. 2. 3. Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2023-07-23 14:20:44 "},"02_智能车PNC笔记/02_控制笔记/控制笔记.html":{"url":"02_智能车PNC笔记/02_控制笔记/控制笔记.html","title":"2.2 控制笔记","keywords":"","body":"一级标题 一级标题的内容 MPC控制 基本原理 模型预测控制是一种先进的过程控制方法，在满足一定约束条件的前提下，被用来实现过程控制，它的实现依赖于过程的动态模型（通常为线性模型）。在控制时域（一段有限时间）内，它主要针对当前时刻进行优化，但也考虑未来时刻，求取当前时刻的最优控制解，然后反复优化，从而实现整个时域的优化求解。 也就是说，模型预测控制实际上是一种时间相关的，利用系统当前状态和当前的控制量，来实现对系统未来状态的控制。而系统未来的状态是不定的，因此在控制过程中要不断根据系统状态对未来的控制量作出调整。而且相较于经典的的PID控制，它具有优化和预测的能力，也就是说，模型预测控制是一种致力于将更长时间跨度、甚至于无穷时间的最优化控制问题，分解为若干个更短时间跨度，或者有限时间跨度的最优化控制问题，并且在一定程度上仍然追求最优解。 模型预测控制在实现上有三个要素： 预测模型:是模型预测控制的基础，用来预测系统未来的输出； 滚动优化:一种在线优化，用于优化短时间内的控制输入，以尽可能减小预测模型输出与参考值的差距； 反馈矫正:在新的采样时刻，基于被控对象的实际输出，对预测模型的输出进行矫正，然后进行新的优化，以防模型失配或外界干扰导致的控制输出与期望差距过大。 具体 其中， x(t) 为 t时刻车辆的观测状态，\\hat{x}(t) 为t时刻车辆的估计状态， u^*(t)为t时刻的最优控制解， y(t)为t时刻的系统输出。 模型预测控制的实现，依赖MPC控制器、被控车辆、状态估计器、轨迹规划等信息。结合图1和图4，模型预测控制器的一般工作步骤可以概括如下： 1、在t时刻，结合历史信息和当前状态以及预测模型，预测N步的系统输出； 2、结合约束条件等，设计目标函数，计算最优控制解 u^*(t)，输入到被控车辆，使其在当前控制量下运动； 3、获取车辆状态x(t)，输入到状态估计器中，对那些无法直接用传感器获取或观测成本较高的的状态量进行估计，然后将\\hat{x}(t)输入到MPC控制器，再次进行优化求解，以得到未来一段时间的预测控制序列； 4、然后在t+1时刻重复上述步骤，如此，滚动地实现带约束的优化问题，从而实现对被控对象的连续控制。 此外，x(t)也可在需要的时候，被用来更新规划轨迹，以便得到更好的控制效果。 1. 预测模型 无论是运动学模型，还是动力学模型，所搭建的均为非线性系统，而线性模型预测控制较非线性模型预测控制有更好的实时性，且更易于分析和计算。对于无人车来说，实时性显然很重要，因此，需要将非线性系统转化为线性系统，而非线性系统的线性化的方法大体可分为精确线性化和近似线性化，多采用近似的线性化方法。 线性化 雅克比矩阵 Article: 离散化 单轨模型 2.滚动优化 在设计代价函数时候，一般设计为二次型的样式，为的是避免在预测时域内，误差忽正忽负，导致误差相互抵消； 可考虑的代价有： a. 距离误差(Cross Track Error, CTE)，指实际轨迹点与参考轨迹点间的距离 b. 速度误差，指实际速度与期望速度的差 c. 刹车/油门调节量，目的是为了保证刹车/油门变化的平稳性 d. 航向误差等… 约束条件 a. 最大前轮转角 b. 最大刹车/油门调节量 c. 最大方向盘转角 d. 最大车速等 3.反馈矫正 代码实现 2. 3. 4. 具体代码(c++ ,from apollo) 参考：Article:Apollo代码学习(六)—模型预测控制(MPC) 三级标题 其他控制 滑模控制 Article:百度百科：滑模控制 pid控制 模糊自适应pid控制 Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2021-12-12 20:12:14 "},"03_车辆相关笔记/":{"url":"03_车辆相关笔记/","title":"第三部分：车辆相关笔记","keywords":"","body":"暂不开放 一级标题 一级标题的内容 二级标题 二级标题的内容 三级标题 三级标题的内容 Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2022-04-18 20:33:35 "},"10_环境配置/":{"url":"10_环境配置/","title":"第N部分：环境配置笔记","keywords":"","body":"一级标题 一级标题的内容 二级标题 二级标题的内容 三级标题 三级标题的内容 Copyright ©sunyf 2021-2026 all right reserved，powered by GitbookModified ： 2021-08-16 00:19:42 "}}